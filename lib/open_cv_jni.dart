// AUTO GENERATED BY JNIGEN 0.14.2. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `org.opencv.core.CvType`
class CvType extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<CvType> $type;

  @jni$_.internal
  CvType.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'org/opencv/core/CvType');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $CvType$NullableType();
  static const type = $CvType$Type();

  /// from: `static public final int CV_8U`
  static const CV_8U = 0;

  /// from: `static public final int CV_8S`
  static const CV_8S = 1;

  /// from: `static public final int CV_16U`
  static const CV_16U = 2;

  /// from: `static public final int CV_16S`
  static const CV_16S = 3;

  /// from: `static public final int CV_32S`
  static const CV_32S = 4;

  /// from: `static public final int CV_32F`
  static const CV_32F = 5;

  /// from: `static public final int CV_64F`
  static const CV_64F = 6;

  /// from: `static public final int CV_16F`
  static const CV_16F = 7;

  /// from: `static public final int CV_USRTYPE1`
  static const CV_USRTYPE1 = 7;
  static final _id_CV_8UC1 = _class.staticFieldId(r'CV_8UC1', r'I');

  /// from: `static public final int CV_8UC1`
  static int get CV_8UC1 => _id_CV_8UC1.get(_class, const jni$_.jintType());

  static final _id_CV_8UC2 = _class.staticFieldId(r'CV_8UC2', r'I');

  /// from: `static public final int CV_8UC2`
  static int get CV_8UC2 => _id_CV_8UC2.get(_class, const jni$_.jintType());

  static final _id_CV_8UC3 = _class.staticFieldId(r'CV_8UC3', r'I');

  /// from: `static public final int CV_8UC3`
  static int get CV_8UC3 => _id_CV_8UC3.get(_class, const jni$_.jintType());

  static final _id_CV_8UC4 = _class.staticFieldId(r'CV_8UC4', r'I');

  /// from: `static public final int CV_8UC4`
  static int get CV_8UC4 => _id_CV_8UC4.get(_class, const jni$_.jintType());

  static final _id_CV_8SC1 = _class.staticFieldId(r'CV_8SC1', r'I');

  /// from: `static public final int CV_8SC1`
  static int get CV_8SC1 => _id_CV_8SC1.get(_class, const jni$_.jintType());

  static final _id_CV_8SC2 = _class.staticFieldId(r'CV_8SC2', r'I');

  /// from: `static public final int CV_8SC2`
  static int get CV_8SC2 => _id_CV_8SC2.get(_class, const jni$_.jintType());

  static final _id_CV_8SC3 = _class.staticFieldId(r'CV_8SC3', r'I');

  /// from: `static public final int CV_8SC3`
  static int get CV_8SC3 => _id_CV_8SC3.get(_class, const jni$_.jintType());

  static final _id_CV_8SC4 = _class.staticFieldId(r'CV_8SC4', r'I');

  /// from: `static public final int CV_8SC4`
  static int get CV_8SC4 => _id_CV_8SC4.get(_class, const jni$_.jintType());

  static final _id_CV_16UC1 = _class.staticFieldId(r'CV_16UC1', r'I');

  /// from: `static public final int CV_16UC1`
  static int get CV_16UC1 => _id_CV_16UC1.get(_class, const jni$_.jintType());

  static final _id_CV_16UC2 = _class.staticFieldId(r'CV_16UC2', r'I');

  /// from: `static public final int CV_16UC2`
  static int get CV_16UC2 => _id_CV_16UC2.get(_class, const jni$_.jintType());

  static final _id_CV_16UC3 = _class.staticFieldId(r'CV_16UC3', r'I');

  /// from: `static public final int CV_16UC3`
  static int get CV_16UC3 => _id_CV_16UC3.get(_class, const jni$_.jintType());

  static final _id_CV_16UC4 = _class.staticFieldId(r'CV_16UC4', r'I');

  /// from: `static public final int CV_16UC4`
  static int get CV_16UC4 => _id_CV_16UC4.get(_class, const jni$_.jintType());

  static final _id_CV_16SC1 = _class.staticFieldId(r'CV_16SC1', r'I');

  /// from: `static public final int CV_16SC1`
  static int get CV_16SC1 => _id_CV_16SC1.get(_class, const jni$_.jintType());

  static final _id_CV_16SC2 = _class.staticFieldId(r'CV_16SC2', r'I');

  /// from: `static public final int CV_16SC2`
  static int get CV_16SC2 => _id_CV_16SC2.get(_class, const jni$_.jintType());

  static final _id_CV_16SC3 = _class.staticFieldId(r'CV_16SC3', r'I');

  /// from: `static public final int CV_16SC3`
  static int get CV_16SC3 => _id_CV_16SC3.get(_class, const jni$_.jintType());

  static final _id_CV_16SC4 = _class.staticFieldId(r'CV_16SC4', r'I');

  /// from: `static public final int CV_16SC4`
  static int get CV_16SC4 => _id_CV_16SC4.get(_class, const jni$_.jintType());

  static final _id_CV_32SC1 = _class.staticFieldId(r'CV_32SC1', r'I');

  /// from: `static public final int CV_32SC1`
  static int get CV_32SC1 => _id_CV_32SC1.get(_class, const jni$_.jintType());

  static final _id_CV_32SC2 = _class.staticFieldId(r'CV_32SC2', r'I');

  /// from: `static public final int CV_32SC2`
  static int get CV_32SC2 => _id_CV_32SC2.get(_class, const jni$_.jintType());

  static final _id_CV_32SC3 = _class.staticFieldId(r'CV_32SC3', r'I');

  /// from: `static public final int CV_32SC3`
  static int get CV_32SC3 => _id_CV_32SC3.get(_class, const jni$_.jintType());

  static final _id_CV_32SC4 = _class.staticFieldId(r'CV_32SC4', r'I');

  /// from: `static public final int CV_32SC4`
  static int get CV_32SC4 => _id_CV_32SC4.get(_class, const jni$_.jintType());

  static final _id_CV_32FC1 = _class.staticFieldId(r'CV_32FC1', r'I');

  /// from: `static public final int CV_32FC1`
  static int get CV_32FC1 => _id_CV_32FC1.get(_class, const jni$_.jintType());

  static final _id_CV_32FC2 = _class.staticFieldId(r'CV_32FC2', r'I');

  /// from: `static public final int CV_32FC2`
  static int get CV_32FC2 => _id_CV_32FC2.get(_class, const jni$_.jintType());

  static final _id_CV_32FC3 = _class.staticFieldId(r'CV_32FC3', r'I');

  /// from: `static public final int CV_32FC3`
  static int get CV_32FC3 => _id_CV_32FC3.get(_class, const jni$_.jintType());

  static final _id_CV_32FC4 = _class.staticFieldId(r'CV_32FC4', r'I');

  /// from: `static public final int CV_32FC4`
  static int get CV_32FC4 => _id_CV_32FC4.get(_class, const jni$_.jintType());

  static final _id_CV_64FC1 = _class.staticFieldId(r'CV_64FC1', r'I');

  /// from: `static public final int CV_64FC1`
  static int get CV_64FC1 => _id_CV_64FC1.get(_class, const jni$_.jintType());

  static final _id_CV_64FC2 = _class.staticFieldId(r'CV_64FC2', r'I');

  /// from: `static public final int CV_64FC2`
  static int get CV_64FC2 => _id_CV_64FC2.get(_class, const jni$_.jintType());

  static final _id_CV_64FC3 = _class.staticFieldId(r'CV_64FC3', r'I');

  /// from: `static public final int CV_64FC3`
  static int get CV_64FC3 => _id_CV_64FC3.get(_class, const jni$_.jintType());

  static final _id_CV_64FC4 = _class.staticFieldId(r'CV_64FC4', r'I');

  /// from: `static public final int CV_64FC4`
  static int get CV_64FC4 => _id_CV_64FC4.get(_class, const jni$_.jintType());

  static final _id_CV_16FC1 = _class.staticFieldId(r'CV_16FC1', r'I');

  /// from: `static public final int CV_16FC1`
  static int get CV_16FC1 => _id_CV_16FC1.get(_class, const jni$_.jintType());

  static final _id_CV_16FC2 = _class.staticFieldId(r'CV_16FC2', r'I');

  /// from: `static public final int CV_16FC2`
  static int get CV_16FC2 => _id_CV_16FC2.get(_class, const jni$_.jintType());

  static final _id_CV_16FC3 = _class.staticFieldId(r'CV_16FC3', r'I');

  /// from: `static public final int CV_16FC3`
  static int get CV_16FC3 => _id_CV_16FC3.get(_class, const jni$_.jintType());

  static final _id_CV_16FC4 = _class.staticFieldId(r'CV_16FC4', r'I');

  /// from: `static public final int CV_16FC4`
  static int get CV_16FC4 => _id_CV_16FC4.get(_class, const jni$_.jintType());

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory CvType() {
    return CvType.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_makeType = _class.staticMethodId(r'makeType', r'(II)I');

  static final _makeType =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `static public final int makeType(int i, int i1)`
  static int makeType(int i, int i1) {
    return _makeType(
      _class.reference.pointer,
      _id_makeType as jni$_.JMethodIDPtr,
      i,
      i1,
    ).integer;
  }

  static final _id_CV_8UC = _class.staticMethodId(r'CV_8UC', r'(I)I');

  static final _CV_8UC =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public final int CV_8UC(int i)`
  static int CV_8UC(int i) {
    return _CV_8UC(
      _class.reference.pointer,
      _id_CV_8UC as jni$_.JMethodIDPtr,
      i,
    ).integer;
  }

  static final _id_CV_8SC = _class.staticMethodId(r'CV_8SC', r'(I)I');

  static final _CV_8SC =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public final int CV_8SC(int i)`
  static int CV_8SC(int i) {
    return _CV_8SC(
      _class.reference.pointer,
      _id_CV_8SC as jni$_.JMethodIDPtr,
      i,
    ).integer;
  }

  static final _id_CV_16UC = _class.staticMethodId(r'CV_16UC', r'(I)I');

  static final _CV_16UC =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public final int CV_16UC(int i)`
  static int CV_16UC(int i) {
    return _CV_16UC(
      _class.reference.pointer,
      _id_CV_16UC as jni$_.JMethodIDPtr,
      i,
    ).integer;
  }

  static final _id_CV_16SC = _class.staticMethodId(r'CV_16SC', r'(I)I');

  static final _CV_16SC =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public final int CV_16SC(int i)`
  static int CV_16SC(int i) {
    return _CV_16SC(
      _class.reference.pointer,
      _id_CV_16SC as jni$_.JMethodIDPtr,
      i,
    ).integer;
  }

  static final _id_CV_32SC = _class.staticMethodId(r'CV_32SC', r'(I)I');

  static final _CV_32SC =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public final int CV_32SC(int i)`
  static int CV_32SC(int i) {
    return _CV_32SC(
      _class.reference.pointer,
      _id_CV_32SC as jni$_.JMethodIDPtr,
      i,
    ).integer;
  }

  static final _id_CV_32FC = _class.staticMethodId(r'CV_32FC', r'(I)I');

  static final _CV_32FC =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public final int CV_32FC(int i)`
  static int CV_32FC(int i) {
    return _CV_32FC(
      _class.reference.pointer,
      _id_CV_32FC as jni$_.JMethodIDPtr,
      i,
    ).integer;
  }

  static final _id_CV_64FC = _class.staticMethodId(r'CV_64FC', r'(I)I');

  static final _CV_64FC =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public final int CV_64FC(int i)`
  static int CV_64FC(int i) {
    return _CV_64FC(
      _class.reference.pointer,
      _id_CV_64FC as jni$_.JMethodIDPtr,
      i,
    ).integer;
  }

  static final _id_CV_16FC = _class.staticMethodId(r'CV_16FC', r'(I)I');

  static final _CV_16FC =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public final int CV_16FC(int i)`
  static int CV_16FC(int i) {
    return _CV_16FC(
      _class.reference.pointer,
      _id_CV_16FC as jni$_.JMethodIDPtr,
      i,
    ).integer;
  }

  static final _id_channels = _class.staticMethodId(r'channels', r'(I)I');

  static final _channels =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public final int channels(int i)`
  static int channels(int i) {
    return _channels(
      _class.reference.pointer,
      _id_channels as jni$_.JMethodIDPtr,
      i,
    ).integer;
  }

  static final _id_depth = _class.staticMethodId(r'depth', r'(I)I');

  static final _depth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public final int depth(int i)`
  static int depth(int i) {
    return _depth(
      _class.reference.pointer,
      _id_depth as jni$_.JMethodIDPtr,
      i,
    ).integer;
  }

  static final _id_isInteger = _class.staticMethodId(r'isInteger', r'(I)Z');

  static final _isInteger =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public final boolean isInteger(int i)`
  static bool isInteger(int i) {
    return _isInteger(
      _class.reference.pointer,
      _id_isInteger as jni$_.JMethodIDPtr,
      i,
    ).boolean;
  }

  static final _id_ELEM_SIZE = _class.staticMethodId(r'ELEM_SIZE', r'(I)I');

  static final _ELEM_SIZE =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public final int ELEM_SIZE(int i)`
  static int ELEM_SIZE(int i) {
    return _ELEM_SIZE(
      _class.reference.pointer,
      _id_ELEM_SIZE as jni$_.JMethodIDPtr,
      i,
    ).integer;
  }

  static final _id_typeToString = _class.staticMethodId(
    r'typeToString',
    r'(I)Ljava/lang/String;',
  );

  static final _typeToString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public final java.lang.String typeToString(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? typeToString(int i) {
    return _typeToString(
      _class.reference.pointer,
      _id_typeToString as jni$_.JMethodIDPtr,
      i,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $CvType$NullableType extends jni$_.JObjType<CvType?> {
  @jni$_.internal
  const $CvType$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/opencv/core/CvType;';

  @jni$_.internal
  @core$_.override
  CvType? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : CvType.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CvType?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($CvType$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($CvType$NullableType) &&
        other is $CvType$NullableType;
  }
}

final class $CvType$Type extends jni$_.JObjType<CvType> {
  @jni$_.internal
  const $CvType$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/opencv/core/CvType;';

  @jni$_.internal
  @core$_.override
  CvType fromReference(jni$_.JReference reference) =>
      CvType.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CvType?> get nullableType => const $CvType$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($CvType$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($CvType$Type) && other is $CvType$Type;
  }
}

/// from: `org.opencv.core.Mat$Atable`
class Mat$Atable<$T extends jni$_.JObject?> extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Mat$Atable<$T>> $type;

  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  Mat$Atable.fromReference(this.T, jni$_.JReference reference)
    : $type = type<$T>(T),
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'org/opencv/core/Mat$Atable');

  /// The type which includes information such as the signature of this class.
  static $Mat$Atable$NullableType<$T> nullableType<$T extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
  ) {
    return $Mat$Atable$NullableType<$T>(T);
  }

  static $Mat$Atable$Type<$T> type<$T extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
  ) {
    return $Mat$Atable$Type<$T>(T);
  }

  static final _id_getV = _class.instanceMethodId(
    r'getV',
    r'()Ljava/lang/Object;',
  );

  static final _getV =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract T getV()`
  /// The returned object must be released after use, by calling the [release] method.
  $T? getV() {
    return _getV(
      reference.pointer,
      _id_getV as jni$_.JMethodIDPtr,
    ).object<$T?>(T.nullableType);
  }

  static final _id_setV = _class.instanceMethodId(
    r'setV',
    r'(Ljava/lang/Object;)V',
  );

  static final _setV =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void setV(T object)`
  void setV($T? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    _setV(
      reference.pointer,
      _id_setV as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).check();
  }

  static final _id_getV2c = _class.instanceMethodId(
    r'getV2c',
    r'()Lorg/opencv/core/Mat$Tuple2;',
  );

  static final _getV2c =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract org.opencv.core.Mat$Tuple2<T> getV2c()`
  /// The returned object must be released after use, by calling the [release] method.
  Mat$Tuple2<$T?>? getV2c() {
    return _getV2c(
      reference.pointer,
      _id_getV2c as jni$_.JMethodIDPtr,
    ).object<Mat$Tuple2<$T?>?>($Mat$Tuple2$NullableType<$T?>(T.nullableType));
  }

  static final _id_setV2c = _class.instanceMethodId(
    r'setV2c',
    r'(Lorg/opencv/core/Mat$Tuple2;)V',
  );

  static final _setV2c =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void setV2c(org.opencv.core.Mat$Tuple2<T> tuple2)`
  void setV2c(Mat$Tuple2<$T?>? tuple2) {
    final _$tuple2 = tuple2?.reference ?? jni$_.jNullReference;
    _setV2c(
      reference.pointer,
      _id_setV2c as jni$_.JMethodIDPtr,
      _$tuple2.pointer,
    ).check();
  }

  static final _id_getV3c = _class.instanceMethodId(
    r'getV3c',
    r'()Lorg/opencv/core/Mat$Tuple3;',
  );

  static final _getV3c =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract org.opencv.core.Mat$Tuple3<T> getV3c()`
  /// The returned object must be released after use, by calling the [release] method.
  Mat$Tuple3<$T?>? getV3c() {
    return _getV3c(
      reference.pointer,
      _id_getV3c as jni$_.JMethodIDPtr,
    ).object<Mat$Tuple3<$T?>?>($Mat$Tuple3$NullableType<$T?>(T.nullableType));
  }

  static final _id_setV3c = _class.instanceMethodId(
    r'setV3c',
    r'(Lorg/opencv/core/Mat$Tuple3;)V',
  );

  static final _setV3c =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void setV3c(org.opencv.core.Mat$Tuple3<T> tuple3)`
  void setV3c(Mat$Tuple3<$T?>? tuple3) {
    final _$tuple3 = tuple3?.reference ?? jni$_.jNullReference;
    _setV3c(
      reference.pointer,
      _id_setV3c as jni$_.JMethodIDPtr,
      _$tuple3.pointer,
    ).check();
  }

  static final _id_getV4c = _class.instanceMethodId(
    r'getV4c',
    r'()Lorg/opencv/core/Mat$Tuple4;',
  );

  static final _getV4c =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract org.opencv.core.Mat$Tuple4<T> getV4c()`
  /// The returned object must be released after use, by calling the [release] method.
  Mat$Tuple4<$T?>? getV4c() {
    return _getV4c(
      reference.pointer,
      _id_getV4c as jni$_.JMethodIDPtr,
    ).object<Mat$Tuple4<$T?>?>($Mat$Tuple4$NullableType<$T?>(T.nullableType));
  }

  static final _id_setV4c = _class.instanceMethodId(
    r'setV4c',
    r'(Lorg/opencv/core/Mat$Tuple4;)V',
  );

  static final _setV4c =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void setV4c(org.opencv.core.Mat$Tuple4<T> tuple4)`
  void setV4c(Mat$Tuple4<$T?>? tuple4) {
    final _$tuple4 = tuple4?.reference ?? jni$_.jNullReference;
    _setV4c(
      reference.pointer,
      _id_setV4c as jni$_.JMethodIDPtr,
      _$tuple4.pointer,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Mat$Atable> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'getV()Ljava/lang/Object;') {
        final $r = _$impls[$p]!.getV();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'setV(Ljava/lang/Object;)V') {
        _$impls[$p]!.setV($a![0]?.as(_$impls[$p]!.T, releaseOriginal: true));
        return jni$_.nullptr;
      }
      if ($d == r'getV2c()Lorg/opencv/core/Mat$Tuple2;') {
        final $r = _$impls[$p]!.getV2c();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'setV2c(Lorg/opencv/core/Mat$Tuple2;)V') {
        _$impls[$p]!.setV2c(
          $a![0]?.as(
            const $Mat$Tuple2$Type<jni$_.JObject?>(jni$_.JObjectNullableType()),
            releaseOriginal: true,
          ),
        );
        return jni$_.nullptr;
      }
      if ($d == r'getV3c()Lorg/opencv/core/Mat$Tuple3;') {
        final $r = _$impls[$p]!.getV3c();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'setV3c(Lorg/opencv/core/Mat$Tuple3;)V') {
        _$impls[$p]!.setV3c(
          $a![0]?.as(
            const $Mat$Tuple3$Type<jni$_.JObject?>(jni$_.JObjectNullableType()),
            releaseOriginal: true,
          ),
        );
        return jni$_.nullptr;
      }
      if ($d == r'getV4c()Lorg/opencv/core/Mat$Tuple4;') {
        final $r = _$impls[$p]!.getV4c();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'setV4c(Lorg/opencv/core/Mat$Tuple4;)V') {
        _$impls[$p]!.setV4c(
          $a![0]?.as(
            const $Mat$Tuple4$Type<jni$_.JObject?>(jni$_.JObjectNullableType()),
            releaseOriginal: true,
          ),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn<$T extends jni$_.JObject?>(
    jni$_.JImplementer implementer,
    $Mat$Atable<$T> $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'org.opencv.core.Mat$Atable', $p, _$invokePointer, [
      if ($impl.setV$async) r'setV(Ljava/lang/Object;)V',
      if ($impl.setV2c$async) r'setV2c(Lorg/opencv/core/Mat$Tuple2;)V',
      if ($impl.setV3c$async) r'setV3c(Lorg/opencv/core/Mat$Tuple3;)V',
      if ($impl.setV4c$async) r'setV4c(Lorg/opencv/core/Mat$Tuple4;)V',
    ]);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Mat$Atable.implement($Mat$Atable<$T> $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Mat$Atable<$T>.fromReference($impl.T, $i.implementReference());
  }
}

abstract base mixin class $Mat$Atable<$T extends jni$_.JObject?> {
  factory $Mat$Atable({
    required jni$_.JObjType<$T> T,
    required $T? Function() getV,
    required void Function($T? object) setV,
    bool setV$async,
    required Mat$Tuple2<jni$_.JObject?>? Function() getV2c,
    required void Function(Mat$Tuple2<jni$_.JObject?>? tuple2) setV2c,
    bool setV2c$async,
    required Mat$Tuple3<jni$_.JObject?>? Function() getV3c,
    required void Function(Mat$Tuple3<jni$_.JObject?>? tuple3) setV3c,
    bool setV3c$async,
    required Mat$Tuple4<jni$_.JObject?>? Function() getV4c,
    required void Function(Mat$Tuple4<jni$_.JObject?>? tuple4) setV4c,
    bool setV4c$async,
  }) = _$Mat$Atable<$T>;

  jni$_.JObjType<$T> get T;

  $T? getV();
  void setV($T? object);
  bool get setV$async => false;
  Mat$Tuple2<jni$_.JObject?>? getV2c();
  void setV2c(Mat$Tuple2<jni$_.JObject?>? tuple2);
  bool get setV2c$async => false;
  Mat$Tuple3<jni$_.JObject?>? getV3c();
  void setV3c(Mat$Tuple3<jni$_.JObject?>? tuple3);
  bool get setV3c$async => false;
  Mat$Tuple4<jni$_.JObject?>? getV4c();
  void setV4c(Mat$Tuple4<jni$_.JObject?>? tuple4);
  bool get setV4c$async => false;
}

final class _$Mat$Atable<$T extends jni$_.JObject?> with $Mat$Atable<$T> {
  _$Mat$Atable({
    required this.T,
    required $T? Function() getV,
    required void Function($T? object) setV,
    this.setV$async = false,
    required Mat$Tuple2<jni$_.JObject?>? Function() getV2c,
    required void Function(Mat$Tuple2<jni$_.JObject?>? tuple2) setV2c,
    this.setV2c$async = false,
    required Mat$Tuple3<jni$_.JObject?>? Function() getV3c,
    required void Function(Mat$Tuple3<jni$_.JObject?>? tuple3) setV3c,
    this.setV3c$async = false,
    required Mat$Tuple4<jni$_.JObject?>? Function() getV4c,
    required void Function(Mat$Tuple4<jni$_.JObject?>? tuple4) setV4c,
    this.setV4c$async = false,
  }) : _getV = getV,
       _setV = setV,
       _getV2c = getV2c,
       _setV2c = setV2c,
       _getV3c = getV3c,
       _setV3c = setV3c,
       _getV4c = getV4c,
       _setV4c = setV4c;

  @core$_.override
  final jni$_.JObjType<$T> T;

  final $T? Function() _getV;
  final void Function($T? object) _setV;
  final bool setV$async;
  final Mat$Tuple2<jni$_.JObject?>? Function() _getV2c;
  final void Function(Mat$Tuple2<jni$_.JObject?>? tuple2) _setV2c;
  final bool setV2c$async;
  final Mat$Tuple3<jni$_.JObject?>? Function() _getV3c;
  final void Function(Mat$Tuple3<jni$_.JObject?>? tuple3) _setV3c;
  final bool setV3c$async;
  final Mat$Tuple4<jni$_.JObject?>? Function() _getV4c;
  final void Function(Mat$Tuple4<jni$_.JObject?>? tuple4) _setV4c;
  final bool setV4c$async;

  $T? getV() {
    return _getV();
  }

  void setV($T? object) {
    return _setV(object);
  }

  Mat$Tuple2<jni$_.JObject?>? getV2c() {
    return _getV2c();
  }

  void setV2c(Mat$Tuple2<jni$_.JObject?>? tuple2) {
    return _setV2c(tuple2);
  }

  Mat$Tuple3<jni$_.JObject?>? getV3c() {
    return _getV3c();
  }

  void setV3c(Mat$Tuple3<jni$_.JObject?>? tuple3) {
    return _setV3c(tuple3);
  }

  Mat$Tuple4<jni$_.JObject?>? getV4c() {
    return _getV4c();
  }

  void setV4c(Mat$Tuple4<jni$_.JObject?>? tuple4) {
    return _setV4c(tuple4);
  }
}

final class $Mat$Atable$NullableType<$T extends jni$_.JObject?>
    extends jni$_.JObjType<Mat$Atable<$T>?> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  const $Mat$Atable$NullableType(this.T);

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/opencv/core/Mat$Atable;';

  @jni$_.internal
  @core$_.override
  Mat$Atable<$T>? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Mat$Atable<$T>.fromReference(T, reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Mat$Atable<$T>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($Mat$Atable$NullableType, T);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Mat$Atable$NullableType<$T>) &&
        other is $Mat$Atable$NullableType<$T> &&
        T == other.T;
  }
}

final class $Mat$Atable$Type<$T extends jni$_.JObject?>
    extends jni$_.JObjType<Mat$Atable<$T>> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  const $Mat$Atable$Type(this.T);

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/opencv/core/Mat$Atable;';

  @jni$_.internal
  @core$_.override
  Mat$Atable<$T> fromReference(jni$_.JReference reference) =>
      Mat$Atable<$T>.fromReference(T, reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Mat$Atable<$T>?> get nullableType =>
      $Mat$Atable$NullableType<$T>(T);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($Mat$Atable$Type, T);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Mat$Atable$Type<$T>) &&
        other is $Mat$Atable$Type<$T> &&
        T == other.T;
  }
}

/// from: `org.opencv.core.Mat$Tuple2`
class Mat$Tuple2<$T extends jni$_.JObject?> extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Mat$Tuple2<$T>> $type;

  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  Mat$Tuple2.fromReference(this.T, jni$_.JReference reference)
    : $type = type<$T>(T),
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'org/opencv/core/Mat$Tuple2');

  /// The type which includes information such as the signature of this class.
  static $Mat$Tuple2$NullableType<$T> nullableType<$T extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
  ) {
    return $Mat$Tuple2$NullableType<$T>(T);
  }

  static $Mat$Tuple2$Type<$T> type<$T extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
  ) {
    return $Mat$Tuple2$Type<$T>(T);
  }

  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/Object;Ljava/lang/Object;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(T object, T object1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Mat$Tuple2($T? object, $T? object1, {required jni$_.JObjType<$T> T}) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    return Mat$Tuple2<$T>.fromReference(
      T,
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$object.pointer,
        _$object1.pointer,
      ).reference,
    );
  }

  static final _id_get_0 = _class.instanceMethodId(
    r'get_0',
    r'()Ljava/lang/Object;',
  );

  static final _get_0 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public T get_0()`
  /// The returned object must be released after use, by calling the [release] method.
  $T? get_0() {
    return _get_0(
      reference.pointer,
      _id_get_0 as jni$_.JMethodIDPtr,
    ).object<$T?>(T.nullableType);
  }

  static final _id_get_1 = _class.instanceMethodId(
    r'get_1',
    r'()Ljava/lang/Object;',
  );

  static final _get_1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public T get_1()`
  /// The returned object must be released after use, by calling the [release] method.
  $T? get_1() {
    return _get_1(
      reference.pointer,
      _id_get_1 as jni$_.JMethodIDPtr,
    ).object<$T?>(T.nullableType);
  }
}

final class $Mat$Tuple2$NullableType<$T extends jni$_.JObject?>
    extends jni$_.JObjType<Mat$Tuple2<$T>?> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  const $Mat$Tuple2$NullableType(this.T);

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/opencv/core/Mat$Tuple2;';

  @jni$_.internal
  @core$_.override
  Mat$Tuple2<$T>? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Mat$Tuple2<$T>.fromReference(T, reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Mat$Tuple2<$T>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($Mat$Tuple2$NullableType, T);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Mat$Tuple2$NullableType<$T>) &&
        other is $Mat$Tuple2$NullableType<$T> &&
        T == other.T;
  }
}

final class $Mat$Tuple2$Type<$T extends jni$_.JObject?>
    extends jni$_.JObjType<Mat$Tuple2<$T>> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  const $Mat$Tuple2$Type(this.T);

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/opencv/core/Mat$Tuple2;';

  @jni$_.internal
  @core$_.override
  Mat$Tuple2<$T> fromReference(jni$_.JReference reference) =>
      Mat$Tuple2<$T>.fromReference(T, reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Mat$Tuple2<$T>?> get nullableType =>
      $Mat$Tuple2$NullableType<$T>(T);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($Mat$Tuple2$Type, T);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Mat$Tuple2$Type<$T>) &&
        other is $Mat$Tuple2$Type<$T> &&
        T == other.T;
  }
}

/// from: `org.opencv.core.Mat$Tuple3`
class Mat$Tuple3<$T extends jni$_.JObject?> extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Mat$Tuple3<$T>> $type;

  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  Mat$Tuple3.fromReference(this.T, jni$_.JReference reference)
    : $type = type<$T>(T),
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'org/opencv/core/Mat$Tuple3');

  /// The type which includes information such as the signature of this class.
  static $Mat$Tuple3$NullableType<$T> nullableType<$T extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
  ) {
    return $Mat$Tuple3$NullableType<$T>(T);
  }

  static $Mat$Tuple3$Type<$T> type<$T extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
  ) {
    return $Mat$Tuple3$Type<$T>(T);
  }

  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(T object, T object1, T object2)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Mat$Tuple3(
    $T? object,
    $T? object1,
    $T? object2, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    final _$object2 = object2?.reference ?? jni$_.jNullReference;
    return Mat$Tuple3<$T>.fromReference(
      T,
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$object.pointer,
        _$object1.pointer,
        _$object2.pointer,
      ).reference,
    );
  }

  static final _id_get_0 = _class.instanceMethodId(
    r'get_0',
    r'()Ljava/lang/Object;',
  );

  static final _get_0 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public T get_0()`
  /// The returned object must be released after use, by calling the [release] method.
  $T? get_0() {
    return _get_0(
      reference.pointer,
      _id_get_0 as jni$_.JMethodIDPtr,
    ).object<$T?>(T.nullableType);
  }

  static final _id_get_1 = _class.instanceMethodId(
    r'get_1',
    r'()Ljava/lang/Object;',
  );

  static final _get_1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public T get_1()`
  /// The returned object must be released after use, by calling the [release] method.
  $T? get_1() {
    return _get_1(
      reference.pointer,
      _id_get_1 as jni$_.JMethodIDPtr,
    ).object<$T?>(T.nullableType);
  }

  static final _id_get_2 = _class.instanceMethodId(
    r'get_2',
    r'()Ljava/lang/Object;',
  );

  static final _get_2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public T get_2()`
  /// The returned object must be released after use, by calling the [release] method.
  $T? get_2() {
    return _get_2(
      reference.pointer,
      _id_get_2 as jni$_.JMethodIDPtr,
    ).object<$T?>(T.nullableType);
  }
}

final class $Mat$Tuple3$NullableType<$T extends jni$_.JObject?>
    extends jni$_.JObjType<Mat$Tuple3<$T>?> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  const $Mat$Tuple3$NullableType(this.T);

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/opencv/core/Mat$Tuple3;';

  @jni$_.internal
  @core$_.override
  Mat$Tuple3<$T>? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Mat$Tuple3<$T>.fromReference(T, reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Mat$Tuple3<$T>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($Mat$Tuple3$NullableType, T);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Mat$Tuple3$NullableType<$T>) &&
        other is $Mat$Tuple3$NullableType<$T> &&
        T == other.T;
  }
}

final class $Mat$Tuple3$Type<$T extends jni$_.JObject?>
    extends jni$_.JObjType<Mat$Tuple3<$T>> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  const $Mat$Tuple3$Type(this.T);

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/opencv/core/Mat$Tuple3;';

  @jni$_.internal
  @core$_.override
  Mat$Tuple3<$T> fromReference(jni$_.JReference reference) =>
      Mat$Tuple3<$T>.fromReference(T, reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Mat$Tuple3<$T>?> get nullableType =>
      $Mat$Tuple3$NullableType<$T>(T);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($Mat$Tuple3$Type, T);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Mat$Tuple3$Type<$T>) &&
        other is $Mat$Tuple3$Type<$T> &&
        T == other.T;
  }
}

/// from: `org.opencv.core.Mat$Tuple4`
class Mat$Tuple4<$T extends jni$_.JObject?> extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Mat$Tuple4<$T>> $type;

  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  Mat$Tuple4.fromReference(this.T, jni$_.JReference reference)
    : $type = type<$T>(T),
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'org/opencv/core/Mat$Tuple4');

  /// The type which includes information such as the signature of this class.
  static $Mat$Tuple4$NullableType<$T> nullableType<$T extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
  ) {
    return $Mat$Tuple4$NullableType<$T>(T);
  }

  static $Mat$Tuple4$Type<$T> type<$T extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
  ) {
    return $Mat$Tuple4$Type<$T>(T);
  }

  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(T object, T object1, T object2, T object3)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Mat$Tuple4(
    $T? object,
    $T? object1,
    $T? object2,
    $T? object3, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    final _$object2 = object2?.reference ?? jni$_.jNullReference;
    final _$object3 = object3?.reference ?? jni$_.jNullReference;
    return Mat$Tuple4<$T>.fromReference(
      T,
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$object.pointer,
        _$object1.pointer,
        _$object2.pointer,
        _$object3.pointer,
      ).reference,
    );
  }

  static final _id_get_0 = _class.instanceMethodId(
    r'get_0',
    r'()Ljava/lang/Object;',
  );

  static final _get_0 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public T get_0()`
  /// The returned object must be released after use, by calling the [release] method.
  $T? get_0() {
    return _get_0(
      reference.pointer,
      _id_get_0 as jni$_.JMethodIDPtr,
    ).object<$T?>(T.nullableType);
  }

  static final _id_get_1 = _class.instanceMethodId(
    r'get_1',
    r'()Ljava/lang/Object;',
  );

  static final _get_1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public T get_1()`
  /// The returned object must be released after use, by calling the [release] method.
  $T? get_1() {
    return _get_1(
      reference.pointer,
      _id_get_1 as jni$_.JMethodIDPtr,
    ).object<$T?>(T.nullableType);
  }

  static final _id_get_2 = _class.instanceMethodId(
    r'get_2',
    r'()Ljava/lang/Object;',
  );

  static final _get_2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public T get_2()`
  /// The returned object must be released after use, by calling the [release] method.
  $T? get_2() {
    return _get_2(
      reference.pointer,
      _id_get_2 as jni$_.JMethodIDPtr,
    ).object<$T?>(T.nullableType);
  }

  static final _id_get_3 = _class.instanceMethodId(
    r'get_3',
    r'()Ljava/lang/Object;',
  );

  static final _get_3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public T get_3()`
  /// The returned object must be released after use, by calling the [release] method.
  $T? get_3() {
    return _get_3(
      reference.pointer,
      _id_get_3 as jni$_.JMethodIDPtr,
    ).object<$T?>(T.nullableType);
  }
}

final class $Mat$Tuple4$NullableType<$T extends jni$_.JObject?>
    extends jni$_.JObjType<Mat$Tuple4<$T>?> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  const $Mat$Tuple4$NullableType(this.T);

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/opencv/core/Mat$Tuple4;';

  @jni$_.internal
  @core$_.override
  Mat$Tuple4<$T>? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Mat$Tuple4<$T>.fromReference(T, reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Mat$Tuple4<$T>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($Mat$Tuple4$NullableType, T);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Mat$Tuple4$NullableType<$T>) &&
        other is $Mat$Tuple4$NullableType<$T> &&
        T == other.T;
  }
}

final class $Mat$Tuple4$Type<$T extends jni$_.JObject?>
    extends jni$_.JObjType<Mat$Tuple4<$T>> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  const $Mat$Tuple4$Type(this.T);

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/opencv/core/Mat$Tuple4;';

  @jni$_.internal
  @core$_.override
  Mat$Tuple4<$T> fromReference(jni$_.JReference reference) =>
      Mat$Tuple4<$T>.fromReference(T, reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Mat$Tuple4<$T>?> get nullableType =>
      $Mat$Tuple4$NullableType<$T>(T);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($Mat$Tuple4$Type, T);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Mat$Tuple4$Type<$T>) &&
        other is $Mat$Tuple4$Type<$T> &&
        T == other.T;
  }
}

/// from: `org.opencv.core.Mat`
class Mat extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Mat> $type;

  @jni$_.internal
  Mat.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'org/opencv/core/Mat');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Mat$NullableType();
  static const type = $Mat$Type();
  static final _id_nativeObj = _class.instanceFieldId(r'nativeObj', r'J');

  /// from: `public final long nativeObj`
  int get nativeObj => _id_nativeObj.get(this, const jni$_.jlongType());

  static final _id_new$ = _class.constructorId(r'(J)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void <init>(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Mat(int j) {
    return Mat.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        j,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'()V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Mat.new$1() {
    return Mat.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(r'(III)V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
            )
          >();

  /// from: `public void <init>(int i, int i1, int i2)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Mat.new$2(int i, int i1, int i2) {
    return Mat.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        i,
        i1,
        i2,
      ).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(r'(IIILjava/nio/ByteBuffer;)V');

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(int i, int i1, int i2, java.nio.ByteBuffer byteBuffer)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Mat.new$3(int i, int i1, int i2, jni$_.JByteBuffer? byteBuffer) {
    final _$byteBuffer = byteBuffer?.reference ?? jni$_.jNullReference;
    return Mat.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        i,
        i1,
        i2,
        _$byteBuffer.pointer,
      ).reference,
    );
  }

  static final _id_new$4 = _class.constructorId(
    r'(IIILjava/nio/ByteBuffer;J)V',
  );

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int64,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(int i, int i1, int i2, java.nio.ByteBuffer byteBuffer, long j)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Mat.new$4(
    int i,
    int i1,
    int i2,
    jni$_.JByteBuffer? byteBuffer,
    int j,
  ) {
    final _$byteBuffer = byteBuffer?.reference ?? jni$_.jNullReference;
    return Mat.fromReference(
      _new$4(
        _class.reference.pointer,
        _id_new$4 as jni$_.JMethodIDPtr,
        i,
        i1,
        i2,
        _$byteBuffer.pointer,
        j,
      ).reference,
    );
  }

  static final _id_new$5 = _class.constructorId(r'(Lorg/opencv/core/Size;I)V');

  static final _new$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(org.opencv.core.Size size, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Mat.new$5(jni$_.JObject? size, int i) {
    final _$size = size?.reference ?? jni$_.jNullReference;
    return Mat.fromReference(
      _new$5(
        _class.reference.pointer,
        _id_new$5 as jni$_.JMethodIDPtr,
        _$size.pointer,
        i,
      ).reference,
    );
  }

  static final _id_new$6 = _class.constructorId(r'([II)V');

  static final _new$6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(int[] is, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Mat.new$6(jni$_.JIntArray? is$, int i) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return Mat.fromReference(
      _new$6(
        _class.reference.pointer,
        _id_new$6 as jni$_.JMethodIDPtr,
        _$is$.pointer,
        i,
      ).reference,
    );
  }

  static final _id_new$7 = _class.constructorId(
    r'(IIILorg/opencv/core/Scalar;)V',
  );

  static final _new$7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(int i, int i1, int i2, org.opencv.core.Scalar scalar)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Mat.new$7(int i, int i1, int i2, jni$_.JObject? scalar) {
    final _$scalar = scalar?.reference ?? jni$_.jNullReference;
    return Mat.fromReference(
      _new$7(
        _class.reference.pointer,
        _id_new$7 as jni$_.JMethodIDPtr,
        i,
        i1,
        i2,
        _$scalar.pointer,
      ).reference,
    );
  }

  static final _id_new$8 = _class.constructorId(
    r'(Lorg/opencv/core/Size;ILorg/opencv/core/Scalar;)V',
  );

  static final _new$8 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(org.opencv.core.Size size, int i, org.opencv.core.Scalar scalar)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Mat.new$8(jni$_.JObject? size, int i, jni$_.JObject? scalar) {
    final _$size = size?.reference ?? jni$_.jNullReference;
    final _$scalar = scalar?.reference ?? jni$_.jNullReference;
    return Mat.fromReference(
      _new$8(
        _class.reference.pointer,
        _id_new$8 as jni$_.JMethodIDPtr,
        _$size.pointer,
        i,
        _$scalar.pointer,
      ).reference,
    );
  }

  static final _id_new$9 = _class.constructorId(
    r'([IILorg/opencv/core/Scalar;)V',
  );

  static final _new$9 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(int[] is, int i, org.opencv.core.Scalar scalar)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Mat.new$9(jni$_.JIntArray? is$, int i, jni$_.JObject? scalar) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$scalar = scalar?.reference ?? jni$_.jNullReference;
    return Mat.fromReference(
      _new$9(
        _class.reference.pointer,
        _id_new$9 as jni$_.JMethodIDPtr,
        _$is$.pointer,
        i,
        _$scalar.pointer,
      ).reference,
    );
  }

  static final _id_new$10 = _class.constructorId(
    r'(Lorg/opencv/core/Mat;Lorg/opencv/core/Range;Lorg/opencv/core/Range;)V',
  );

  static final _new$10 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(org.opencv.core.Mat mat, org.opencv.core.Range range, org.opencv.core.Range range1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Mat.new$10(Mat? mat, jni$_.JObject? range, jni$_.JObject? range1) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    final _$range = range?.reference ?? jni$_.jNullReference;
    final _$range1 = range1?.reference ?? jni$_.jNullReference;
    return Mat.fromReference(
      _new$10(
        _class.reference.pointer,
        _id_new$10 as jni$_.JMethodIDPtr,
        _$mat.pointer,
        _$range.pointer,
        _$range1.pointer,
      ).reference,
    );
  }

  static final _id_new$11 = _class.constructorId(
    r'(Lorg/opencv/core/Mat;Lorg/opencv/core/Range;)V',
  );

  static final _new$11 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(org.opencv.core.Mat mat, org.opencv.core.Range range)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Mat.new$11(Mat? mat, jni$_.JObject? range) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    final _$range = range?.reference ?? jni$_.jNullReference;
    return Mat.fromReference(
      _new$11(
        _class.reference.pointer,
        _id_new$11 as jni$_.JMethodIDPtr,
        _$mat.pointer,
        _$range.pointer,
      ).reference,
    );
  }

  static final _id_new$12 = _class.constructorId(
    r'(Lorg/opencv/core/Mat;[Lorg/opencv/core/Range;)V',
  );

  static final _new$12 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(org.opencv.core.Mat mat, org.opencv.core.Range[] ranges)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Mat.new$12(Mat? mat, jni$_.JArray<jni$_.JObject?>? ranges) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    final _$ranges = ranges?.reference ?? jni$_.jNullReference;
    return Mat.fromReference(
      _new$12(
        _class.reference.pointer,
        _id_new$12 as jni$_.JMethodIDPtr,
        _$mat.pointer,
        _$ranges.pointer,
      ).reference,
    );
  }

  static final _id_new$13 = _class.constructorId(
    r'(Lorg/opencv/core/Mat;Lorg/opencv/core/Rect;)V',
  );

  static final _new$13 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(org.opencv.core.Mat mat, org.opencv.core.Rect rect)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Mat.new$13(Mat? mat, jni$_.JObject? rect) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    final _$rect = rect?.reference ?? jni$_.jNullReference;
    return Mat.fromReference(
      _new$13(
        _class.reference.pointer,
        _id_new$13 as jni$_.JMethodIDPtr,
        _$mat.pointer,
        _$rect.pointer,
      ).reference,
    );
  }

  static final _id_adjustROI = _class.instanceMethodId(
    r'adjustROI',
    r'(IIII)Lorg/opencv/core/Mat;',
  );

  static final _adjustROI =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Int32, jni$_.Int32, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              int,
            )
          >();

  /// from: `public org.opencv.core.Mat adjustROI(int i, int i1, int i2, int i3)`
  /// The returned object must be released after use, by calling the [release] method.
  Mat? adjustROI(int i, int i1, int i2, int i3) {
    return _adjustROI(
      reference.pointer,
      _id_adjustROI as jni$_.JMethodIDPtr,
      i,
      i1,
      i2,
      i3,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_assignTo = _class.instanceMethodId(
    r'assignTo',
    r'(Lorg/opencv/core/Mat;I)V',
  );

  static final _assignTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void assignTo(org.opencv.core.Mat mat, int i)`
  void assignTo(Mat? mat, int i) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    _assignTo(
      reference.pointer,
      _id_assignTo as jni$_.JMethodIDPtr,
      _$mat.pointer,
      i,
    ).check();
  }

  static final _id_assignTo$1 = _class.instanceMethodId(
    r'assignTo',
    r'(Lorg/opencv/core/Mat;)V',
  );

  static final _assignTo$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void assignTo(org.opencv.core.Mat mat)`
  void assignTo$1(Mat? mat) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    _assignTo$1(
      reference.pointer,
      _id_assignTo$1 as jni$_.JMethodIDPtr,
      _$mat.pointer,
    ).check();
  }

  static final _id_channels = _class.instanceMethodId(r'channels', r'()I');

  static final _channels =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int channels()`
  int channels() {
    return _channels(
      reference.pointer,
      _id_channels as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_checkVector = _class.instanceMethodId(
    r'checkVector',
    r'(IIZ)I',
  );

  static final _checkVector =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
            )
          >();

  /// from: `public int checkVector(int i, int i1, boolean z)`
  int checkVector(int i, int i1, bool z) {
    return _checkVector(
      reference.pointer,
      _id_checkVector as jni$_.JMethodIDPtr,
      i,
      i1,
      z ? 1 : 0,
    ).integer;
  }

  static final _id_checkVector$1 = _class.instanceMethodId(
    r'checkVector',
    r'(II)I',
  );

  static final _checkVector$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public int checkVector(int i, int i1)`
  int checkVector$1(int i, int i1) {
    return _checkVector$1(
      reference.pointer,
      _id_checkVector$1 as jni$_.JMethodIDPtr,
      i,
      i1,
    ).integer;
  }

  static final _id_checkVector$2 = _class.instanceMethodId(
    r'checkVector',
    r'(I)I',
  );

  static final _checkVector$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public int checkVector(int i)`
  int checkVector$2(int i) {
    return _checkVector$2(
      reference.pointer,
      _id_checkVector$2 as jni$_.JMethodIDPtr,
      i,
    ).integer;
  }

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Lorg/opencv/core/Mat;',
  );

  static final _clone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.opencv.core.Mat clone()`
  /// The returned object must be released after use, by calling the [release] method.
  Mat? clone() {
    return _clone(
      reference.pointer,
      _id_clone as jni$_.JMethodIDPtr,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_col = _class.instanceMethodId(
    r'col',
    r'(I)Lorg/opencv/core/Mat;',
  );

  static final _col =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public org.opencv.core.Mat col(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  Mat? col(int i) {
    return _col(
      reference.pointer,
      _id_col as jni$_.JMethodIDPtr,
      i,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_colRange = _class.instanceMethodId(
    r'colRange',
    r'(II)Lorg/opencv/core/Mat;',
  );

  static final _colRange =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public org.opencv.core.Mat colRange(int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  Mat? colRange(int i, int i1) {
    return _colRange(
      reference.pointer,
      _id_colRange as jni$_.JMethodIDPtr,
      i,
      i1,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_colRange$1 = _class.instanceMethodId(
    r'colRange',
    r'(Lorg/opencv/core/Range;)Lorg/opencv/core/Mat;',
  );

  static final _colRange$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.opencv.core.Mat colRange(org.opencv.core.Range range)`
  /// The returned object must be released after use, by calling the [release] method.
  Mat? colRange$1(jni$_.JObject? range) {
    final _$range = range?.reference ?? jni$_.jNullReference;
    return _colRange$1(
      reference.pointer,
      _id_colRange$1 as jni$_.JMethodIDPtr,
      _$range.pointer,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_dims = _class.instanceMethodId(r'dims', r'()I');

  static final _dims =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int dims()`
  int dims() {
    return _dims(reference.pointer, _id_dims as jni$_.JMethodIDPtr).integer;
  }

  static final _id_cols = _class.instanceMethodId(r'cols', r'()I');

  static final _cols =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int cols()`
  int cols() {
    return _cols(reference.pointer, _id_cols as jni$_.JMethodIDPtr).integer;
  }

  static final _id_convertTo = _class.instanceMethodId(
    r'convertTo',
    r'(Lorg/opencv/core/Mat;IDD)V',
  );

  static final _convertTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Double,
                    jni$_.Double,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              double,
              double,
            )
          >();

  /// from: `public void convertTo(org.opencv.core.Mat mat, int i, double d, double d1)`
  void convertTo(Mat? mat, int i, double d, double d1) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    _convertTo(
      reference.pointer,
      _id_convertTo as jni$_.JMethodIDPtr,
      _$mat.pointer,
      i,
      d,
      d1,
    ).check();
  }

  static final _id_convertTo$1 = _class.instanceMethodId(
    r'convertTo',
    r'(Lorg/opencv/core/Mat;ID)V',
  );

  static final _convertTo$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Double)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              double,
            )
          >();

  /// from: `public void convertTo(org.opencv.core.Mat mat, int i, double d)`
  void convertTo$1(Mat? mat, int i, double d) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    _convertTo$1(
      reference.pointer,
      _id_convertTo$1 as jni$_.JMethodIDPtr,
      _$mat.pointer,
      i,
      d,
    ).check();
  }

  static final _id_convertTo$2 = _class.instanceMethodId(
    r'convertTo',
    r'(Lorg/opencv/core/Mat;I)V',
  );

  static final _convertTo$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void convertTo(org.opencv.core.Mat mat, int i)`
  void convertTo$2(Mat? mat, int i) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    _convertTo$2(
      reference.pointer,
      _id_convertTo$2 as jni$_.JMethodIDPtr,
      _$mat.pointer,
      i,
    ).check();
  }

  static final _id_copyTo = _class.instanceMethodId(
    r'copyTo',
    r'(Lorg/opencv/core/Mat;)V',
  );

  static final _copyTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void copyTo(org.opencv.core.Mat mat)`
  void copyTo(Mat? mat) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    _copyTo(
      reference.pointer,
      _id_copyTo as jni$_.JMethodIDPtr,
      _$mat.pointer,
    ).check();
  }

  static final _id_copyTo$1 = _class.instanceMethodId(
    r'copyTo',
    r'(Lorg/opencv/core/Mat;Lorg/opencv/core/Mat;)V',
  );

  static final _copyTo$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void copyTo(org.opencv.core.Mat mat, org.opencv.core.Mat mat1)`
  void copyTo$1(Mat? mat, Mat? mat1) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    final _$mat1 = mat1?.reference ?? jni$_.jNullReference;
    _copyTo$1(
      reference.pointer,
      _id_copyTo$1 as jni$_.JMethodIDPtr,
      _$mat.pointer,
      _$mat1.pointer,
    ).check();
  }

  static final _id_create = _class.instanceMethodId(r'create', r'(III)V');

  static final _create =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
            )
          >();

  /// from: `public void create(int i, int i1, int i2)`
  void create(int i, int i1, int i2) {
    _create(
      reference.pointer,
      _id_create as jni$_.JMethodIDPtr,
      i,
      i1,
      i2,
    ).check();
  }

  static final _id_create$1 = _class.instanceMethodId(
    r'create',
    r'(Lorg/opencv/core/Size;I)V',
  );

  static final _create$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void create(org.opencv.core.Size size, int i)`
  void create$1(jni$_.JObject? size, int i) {
    final _$size = size?.reference ?? jni$_.jNullReference;
    _create$1(
      reference.pointer,
      _id_create$1 as jni$_.JMethodIDPtr,
      _$size.pointer,
      i,
    ).check();
  }

  static final _id_create$2 = _class.instanceMethodId(r'create', r'([II)V');

  static final _create$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void create(int[] is, int i)`
  void create$2(jni$_.JIntArray? is$, int i) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    _create$2(
      reference.pointer,
      _id_create$2 as jni$_.JMethodIDPtr,
      _$is$.pointer,
      i,
    ).check();
  }

  static final _id_copySize = _class.instanceMethodId(
    r'copySize',
    r'(Lorg/opencv/core/Mat;)V',
  );

  static final _copySize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void copySize(org.opencv.core.Mat mat)`
  void copySize(Mat? mat) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    _copySize(
      reference.pointer,
      _id_copySize as jni$_.JMethodIDPtr,
      _$mat.pointer,
    ).check();
  }

  static final _id_cross = _class.instanceMethodId(
    r'cross',
    r'(Lorg/opencv/core/Mat;)Lorg/opencv/core/Mat;',
  );

  static final _cross =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.opencv.core.Mat cross(org.opencv.core.Mat mat)`
  /// The returned object must be released after use, by calling the [release] method.
  Mat? cross(Mat? mat) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    return _cross(
      reference.pointer,
      _id_cross as jni$_.JMethodIDPtr,
      _$mat.pointer,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_dataAddr = _class.instanceMethodId(r'dataAddr', r'()J');

  static final _dataAddr =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long dataAddr()`
  int dataAddr() {
    return _dataAddr(
      reference.pointer,
      _id_dataAddr as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_depth = _class.instanceMethodId(r'depth', r'()I');

  static final _depth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int depth()`
  int depth() {
    return _depth(reference.pointer, _id_depth as jni$_.JMethodIDPtr).integer;
  }

  static final _id_diag = _class.instanceMethodId(
    r'diag',
    r'(I)Lorg/opencv/core/Mat;',
  );

  static final _diag =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public org.opencv.core.Mat diag(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  Mat? diag(int i) {
    return _diag(
      reference.pointer,
      _id_diag as jni$_.JMethodIDPtr,
      i,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_diag$1 = _class.instanceMethodId(
    r'diag',
    r'()Lorg/opencv/core/Mat;',
  );

  static final _diag$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.opencv.core.Mat diag()`
  /// The returned object must be released after use, by calling the [release] method.
  Mat? diag$1() {
    return _diag$1(
      reference.pointer,
      _id_diag$1 as jni$_.JMethodIDPtr,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_diag$2 = _class.staticMethodId(
    r'diag',
    r'(Lorg/opencv/core/Mat;)Lorg/opencv/core/Mat;',
  );

  static final _diag$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public org.opencv.core.Mat diag(org.opencv.core.Mat mat)`
  /// The returned object must be released after use, by calling the [release] method.
  static Mat? diag$2(Mat? mat) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    return _diag$2(
      _class.reference.pointer,
      _id_diag$2 as jni$_.JMethodIDPtr,
      _$mat.pointer,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_dot = _class.instanceMethodId(
    r'dot',
    r'(Lorg/opencv/core/Mat;)D',
  );

  static final _dot =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public double dot(org.opencv.core.Mat mat)`
  double dot(Mat? mat) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    return _dot(
      reference.pointer,
      _id_dot as jni$_.JMethodIDPtr,
      _$mat.pointer,
    ).doubleFloat;
  }

  static final _id_elemSize = _class.instanceMethodId(r'elemSize', r'()J');

  static final _elemSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long elemSize()`
  int elemSize() {
    return _elemSize(
      reference.pointer,
      _id_elemSize as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_elemSize1 = _class.instanceMethodId(r'elemSize1', r'()J');

  static final _elemSize1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long elemSize1()`
  int elemSize1() {
    return _elemSize1(
      reference.pointer,
      _id_elemSize1 as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_empty = _class.instanceMethodId(r'empty', r'()Z');

  static final _empty =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean empty()`
  bool empty() {
    return _empty(reference.pointer, _id_empty as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_eye = _class.staticMethodId(
    r'eye',
    r'(III)Lorg/opencv/core/Mat;',
  );

  static final _eye =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
            )
          >();

  /// from: `static public org.opencv.core.Mat eye(int i, int i1, int i2)`
  /// The returned object must be released after use, by calling the [release] method.
  static Mat? eye(int i, int i1, int i2) {
    return _eye(
      _class.reference.pointer,
      _id_eye as jni$_.JMethodIDPtr,
      i,
      i1,
      i2,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_eye$1 = _class.staticMethodId(
    r'eye',
    r'(Lorg/opencv/core/Size;I)Lorg/opencv/core/Mat;',
  );

  static final _eye$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public org.opencv.core.Mat eye(org.opencv.core.Size size, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static Mat? eye$1(jni$_.JObject? size, int i) {
    final _$size = size?.reference ?? jni$_.jNullReference;
    return _eye$1(
      _class.reference.pointer,
      _id_eye$1 as jni$_.JMethodIDPtr,
      _$size.pointer,
      i,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_inv = _class.instanceMethodId(
    r'inv',
    r'(I)Lorg/opencv/core/Mat;',
  );

  static final _inv =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public org.opencv.core.Mat inv(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  Mat? inv(int i) {
    return _inv(
      reference.pointer,
      _id_inv as jni$_.JMethodIDPtr,
      i,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_inv$1 = _class.instanceMethodId(
    r'inv',
    r'()Lorg/opencv/core/Mat;',
  );

  static final _inv$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.opencv.core.Mat inv()`
  /// The returned object must be released after use, by calling the [release] method.
  Mat? inv$1() {
    return _inv$1(
      reference.pointer,
      _id_inv$1 as jni$_.JMethodIDPtr,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_isContinuous = _class.instanceMethodId(
    r'isContinuous',
    r'()Z',
  );

  static final _isContinuous =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isContinuous()`
  bool isContinuous() {
    return _isContinuous(
      reference.pointer,
      _id_isContinuous as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isSubmatrix = _class.instanceMethodId(
    r'isSubmatrix',
    r'()Z',
  );

  static final _isSubmatrix =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isSubmatrix()`
  bool isSubmatrix() {
    return _isSubmatrix(
      reference.pointer,
      _id_isSubmatrix as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_locateROI = _class.instanceMethodId(
    r'locateROI',
    r'(Lorg/opencv/core/Size;Lorg/opencv/core/Point;)V',
  );

  static final _locateROI =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void locateROI(org.opencv.core.Size size, org.opencv.core.Point point)`
  void locateROI(jni$_.JObject? size, Point? point) {
    final _$size = size?.reference ?? jni$_.jNullReference;
    final _$point = point?.reference ?? jni$_.jNullReference;
    _locateROI(
      reference.pointer,
      _id_locateROI as jni$_.JMethodIDPtr,
      _$size.pointer,
      _$point.pointer,
    ).check();
  }

  static final _id_mul = _class.instanceMethodId(
    r'mul',
    r'(Lorg/opencv/core/Mat;D)Lorg/opencv/core/Mat;',
  );

  static final _mul =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Double)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              double,
            )
          >();

  /// from: `public org.opencv.core.Mat mul(org.opencv.core.Mat mat, double d)`
  /// The returned object must be released after use, by calling the [release] method.
  Mat? mul(Mat? mat, double d) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    return _mul(
      reference.pointer,
      _id_mul as jni$_.JMethodIDPtr,
      _$mat.pointer,
      d,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_mul$1 = _class.instanceMethodId(
    r'mul',
    r'(Lorg/opencv/core/Mat;)Lorg/opencv/core/Mat;',
  );

  static final _mul$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.opencv.core.Mat mul(org.opencv.core.Mat mat)`
  /// The returned object must be released after use, by calling the [release] method.
  Mat? mul$1(Mat? mat) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    return _mul$1(
      reference.pointer,
      _id_mul$1 as jni$_.JMethodIDPtr,
      _$mat.pointer,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_matMul = _class.instanceMethodId(
    r'matMul',
    r'(Lorg/opencv/core/Mat;)Lorg/opencv/core/Mat;',
  );

  static final _matMul =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.opencv.core.Mat matMul(org.opencv.core.Mat mat)`
  /// The returned object must be released after use, by calling the [release] method.
  Mat? matMul(Mat? mat) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    return _matMul(
      reference.pointer,
      _id_matMul as jni$_.JMethodIDPtr,
      _$mat.pointer,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_ones = _class.staticMethodId(
    r'ones',
    r'(III)Lorg/opencv/core/Mat;',
  );

  static final _ones =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
            )
          >();

  /// from: `static public org.opencv.core.Mat ones(int i, int i1, int i2)`
  /// The returned object must be released after use, by calling the [release] method.
  static Mat? ones(int i, int i1, int i2) {
    return _ones(
      _class.reference.pointer,
      _id_ones as jni$_.JMethodIDPtr,
      i,
      i1,
      i2,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_ones$1 = _class.staticMethodId(
    r'ones',
    r'(Lorg/opencv/core/Size;I)Lorg/opencv/core/Mat;',
  );

  static final _ones$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public org.opencv.core.Mat ones(org.opencv.core.Size size, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static Mat? ones$1(jni$_.JObject? size, int i) {
    final _$size = size?.reference ?? jni$_.jNullReference;
    return _ones$1(
      _class.reference.pointer,
      _id_ones$1 as jni$_.JMethodIDPtr,
      _$size.pointer,
      i,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_ones$2 = _class.staticMethodId(
    r'ones',
    r'([II)Lorg/opencv/core/Mat;',
  );

  static final _ones$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public org.opencv.core.Mat ones(int[] is, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static Mat? ones$2(jni$_.JIntArray? is$, int i) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _ones$2(
      _class.reference.pointer,
      _id_ones$2 as jni$_.JMethodIDPtr,
      _$is$.pointer,
      i,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_push_back = _class.instanceMethodId(
    r'push_back',
    r'(Lorg/opencv/core/Mat;)V',
  );

  static final _push_back =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void push_back(org.opencv.core.Mat mat)`
  void push_back(Mat? mat) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    _push_back(
      reference.pointer,
      _id_push_back as jni$_.JMethodIDPtr,
      _$mat.pointer,
    ).check();
  }

  static final _id_release$1 = _class.instanceMethodId(r'release', r'()V');

  static final _release$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void release()`
  void release$1() {
    _release$1(reference.pointer, _id_release$1 as jni$_.JMethodIDPtr).check();
  }

  static final _id_reshape = _class.instanceMethodId(
    r'reshape',
    r'(II)Lorg/opencv/core/Mat;',
  );

  static final _reshape =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public org.opencv.core.Mat reshape(int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  Mat? reshape(int i, int i1) {
    return _reshape(
      reference.pointer,
      _id_reshape as jni$_.JMethodIDPtr,
      i,
      i1,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_reshape$1 = _class.instanceMethodId(
    r'reshape',
    r'(I)Lorg/opencv/core/Mat;',
  );

  static final _reshape$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public org.opencv.core.Mat reshape(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  Mat? reshape$1(int i) {
    return _reshape$1(
      reference.pointer,
      _id_reshape$1 as jni$_.JMethodIDPtr,
      i,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_reshape$2 = _class.instanceMethodId(
    r'reshape',
    r'(I[I)Lorg/opencv/core/Mat;',
  );

  static final _reshape$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.opencv.core.Mat reshape(int i, int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  Mat? reshape$2(int i, jni$_.JIntArray? is$) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _reshape$2(
      reference.pointer,
      _id_reshape$2 as jni$_.JMethodIDPtr,
      i,
      _$is$.pointer,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_row = _class.instanceMethodId(
    r'row',
    r'(I)Lorg/opencv/core/Mat;',
  );

  static final _row =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public org.opencv.core.Mat row(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  Mat? row(int i) {
    return _row(
      reference.pointer,
      _id_row as jni$_.JMethodIDPtr,
      i,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_rowRange = _class.instanceMethodId(
    r'rowRange',
    r'(II)Lorg/opencv/core/Mat;',
  );

  static final _rowRange =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public org.opencv.core.Mat rowRange(int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  Mat? rowRange(int i, int i1) {
    return _rowRange(
      reference.pointer,
      _id_rowRange as jni$_.JMethodIDPtr,
      i,
      i1,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_rowRange$1 = _class.instanceMethodId(
    r'rowRange',
    r'(Lorg/opencv/core/Range;)Lorg/opencv/core/Mat;',
  );

  static final _rowRange$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.opencv.core.Mat rowRange(org.opencv.core.Range range)`
  /// The returned object must be released after use, by calling the [release] method.
  Mat? rowRange$1(jni$_.JObject? range) {
    final _$range = range?.reference ?? jni$_.jNullReference;
    return _rowRange$1(
      reference.pointer,
      _id_rowRange$1 as jni$_.JMethodIDPtr,
      _$range.pointer,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_rows = _class.instanceMethodId(r'rows', r'()I');

  static final _rows =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int rows()`
  int rows() {
    return _rows(reference.pointer, _id_rows as jni$_.JMethodIDPtr).integer;
  }

  static final _id_setTo = _class.instanceMethodId(
    r'setTo',
    r'(Lorg/opencv/core/Scalar;)Lorg/opencv/core/Mat;',
  );

  static final _setTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.opencv.core.Mat setTo(org.opencv.core.Scalar scalar)`
  /// The returned object must be released after use, by calling the [release] method.
  Mat? setTo(jni$_.JObject? scalar) {
    final _$scalar = scalar?.reference ?? jni$_.jNullReference;
    return _setTo(
      reference.pointer,
      _id_setTo as jni$_.JMethodIDPtr,
      _$scalar.pointer,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_setTo$1 = _class.instanceMethodId(
    r'setTo',
    r'(Lorg/opencv/core/Scalar;Lorg/opencv/core/Mat;)Lorg/opencv/core/Mat;',
  );

  static final _setTo$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.opencv.core.Mat setTo(org.opencv.core.Scalar scalar, org.opencv.core.Mat mat)`
  /// The returned object must be released after use, by calling the [release] method.
  Mat? setTo$1(jni$_.JObject? scalar, Mat? mat) {
    final _$scalar = scalar?.reference ?? jni$_.jNullReference;
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    return _setTo$1(
      reference.pointer,
      _id_setTo$1 as jni$_.JMethodIDPtr,
      _$scalar.pointer,
      _$mat.pointer,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_setTo$2 = _class.instanceMethodId(
    r'setTo',
    r'(Lorg/opencv/core/Mat;Lorg/opencv/core/Mat;)Lorg/opencv/core/Mat;',
  );

  static final _setTo$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.opencv.core.Mat setTo(org.opencv.core.Mat mat, org.opencv.core.Mat mat1)`
  /// The returned object must be released after use, by calling the [release] method.
  Mat? setTo$2(Mat? mat, Mat? mat1) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    final _$mat1 = mat1?.reference ?? jni$_.jNullReference;
    return _setTo$2(
      reference.pointer,
      _id_setTo$2 as jni$_.JMethodIDPtr,
      _$mat.pointer,
      _$mat1.pointer,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_setTo$3 = _class.instanceMethodId(
    r'setTo',
    r'(Lorg/opencv/core/Mat;)Lorg/opencv/core/Mat;',
  );

  static final _setTo$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.opencv.core.Mat setTo(org.opencv.core.Mat mat)`
  /// The returned object must be released after use, by calling the [release] method.
  Mat? setTo$3(Mat? mat) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    return _setTo$3(
      reference.pointer,
      _id_setTo$3 as jni$_.JMethodIDPtr,
      _$mat.pointer,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_size = _class.instanceMethodId(
    r'size',
    r'()Lorg/opencv/core/Size;',
  );

  static final _size =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.opencv.core.Size size()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? size() {
    return _size(
      reference.pointer,
      _id_size as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_size$1 = _class.instanceMethodId(r'size', r'(I)I');

  static final _size$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public int size(int i)`
  int size$1(int i) {
    return _size$1(
      reference.pointer,
      _id_size$1 as jni$_.JMethodIDPtr,
      i,
    ).integer;
  }

  static final _id_step1 = _class.instanceMethodId(r'step1', r'(I)J');

  static final _step1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public long step1(int i)`
  int step1(int i) {
    return _step1(reference.pointer, _id_step1 as jni$_.JMethodIDPtr, i).long;
  }

  static final _id_step1$1 = _class.instanceMethodId(r'step1', r'()J');

  static final _step1$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long step1()`
  int step1$1() {
    return _step1$1(reference.pointer, _id_step1$1 as jni$_.JMethodIDPtr).long;
  }

  static final _id_submat = _class.instanceMethodId(
    r'submat',
    r'(IIII)Lorg/opencv/core/Mat;',
  );

  static final _submat =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Int32, jni$_.Int32, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              int,
            )
          >();

  /// from: `public org.opencv.core.Mat submat(int i, int i1, int i2, int i3)`
  /// The returned object must be released after use, by calling the [release] method.
  Mat? submat(int i, int i1, int i2, int i3) {
    return _submat(
      reference.pointer,
      _id_submat as jni$_.JMethodIDPtr,
      i,
      i1,
      i2,
      i3,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_submat$1 = _class.instanceMethodId(
    r'submat',
    r'(Lorg/opencv/core/Range;Lorg/opencv/core/Range;)Lorg/opencv/core/Mat;',
  );

  static final _submat$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.opencv.core.Mat submat(org.opencv.core.Range range, org.opencv.core.Range range1)`
  /// The returned object must be released after use, by calling the [release] method.
  Mat? submat$1(jni$_.JObject? range, jni$_.JObject? range1) {
    final _$range = range?.reference ?? jni$_.jNullReference;
    final _$range1 = range1?.reference ?? jni$_.jNullReference;
    return _submat$1(
      reference.pointer,
      _id_submat$1 as jni$_.JMethodIDPtr,
      _$range.pointer,
      _$range1.pointer,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_submat$2 = _class.instanceMethodId(
    r'submat',
    r'([Lorg/opencv/core/Range;)Lorg/opencv/core/Mat;',
  );

  static final _submat$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.opencv.core.Mat submat(org.opencv.core.Range[] ranges)`
  /// The returned object must be released after use, by calling the [release] method.
  Mat? submat$2(jni$_.JArray<jni$_.JObject?>? ranges) {
    final _$ranges = ranges?.reference ?? jni$_.jNullReference;
    return _submat$2(
      reference.pointer,
      _id_submat$2 as jni$_.JMethodIDPtr,
      _$ranges.pointer,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_submat$3 = _class.instanceMethodId(
    r'submat',
    r'(Lorg/opencv/core/Rect;)Lorg/opencv/core/Mat;',
  );

  static final _submat$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.opencv.core.Mat submat(org.opencv.core.Rect rect)`
  /// The returned object must be released after use, by calling the [release] method.
  Mat? submat$3(jni$_.JObject? rect) {
    final _$rect = rect?.reference ?? jni$_.jNullReference;
    return _submat$3(
      reference.pointer,
      _id_submat$3 as jni$_.JMethodIDPtr,
      _$rect.pointer,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_t = _class.instanceMethodId(
    r't',
    r'()Lorg/opencv/core/Mat;',
  );

  static final _t =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.opencv.core.Mat t()`
  /// The returned object must be released after use, by calling the [release] method.
  Mat? t() {
    return _t(
      reference.pointer,
      _id_t as jni$_.JMethodIDPtr,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_total = _class.instanceMethodId(r'total', r'()J');

  static final _total =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long total()`
  int total() {
    return _total(reference.pointer, _id_total as jni$_.JMethodIDPtr).long;
  }

  static final _id_type$1 = _class.instanceMethodId(r'type', r'()I');

  static final _type$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int type()`
  int type$1() {
    return _type$1(reference.pointer, _id_type$1 as jni$_.JMethodIDPtr).integer;
  }

  static final _id_zeros = _class.staticMethodId(
    r'zeros',
    r'(III)Lorg/opencv/core/Mat;',
  );

  static final _zeros =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
            )
          >();

  /// from: `static public org.opencv.core.Mat zeros(int i, int i1, int i2)`
  /// The returned object must be released after use, by calling the [release] method.
  static Mat? zeros(int i, int i1, int i2) {
    return _zeros(
      _class.reference.pointer,
      _id_zeros as jni$_.JMethodIDPtr,
      i,
      i1,
      i2,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_zeros$1 = _class.staticMethodId(
    r'zeros',
    r'(Lorg/opencv/core/Size;I)Lorg/opencv/core/Mat;',
  );

  static final _zeros$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public org.opencv.core.Mat zeros(org.opencv.core.Size size, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static Mat? zeros$1(jni$_.JObject? size, int i) {
    final _$size = size?.reference ?? jni$_.jNullReference;
    return _zeros$1(
      _class.reference.pointer,
      _id_zeros$1 as jni$_.JMethodIDPtr,
      _$size.pointer,
      i,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_zeros$2 = _class.staticMethodId(
    r'zeros',
    r'([II)Lorg/opencv/core/Mat;',
  );

  static final _zeros$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public org.opencv.core.Mat zeros(int[] is, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static Mat? zeros$2(jni$_.JIntArray? is$, int i) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _zeros$2(
      _class.reference.pointer,
      _id_zeros$2 as jni$_.JMethodIDPtr,
      _$is$.pointer,
      i,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_dump = _class.instanceMethodId(
    r'dump',
    r'()Ljava/lang/String;',
  );

  static final _dump =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String dump()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? dump() {
    return _dump(
      reference.pointer,
      _id_dump as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_put = _class.instanceMethodId(r'put', r'(II[D)I');

  static final _put =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Int32, jni$_.Int32, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int put(int i, int i1, double[] ds)`
  int put(int i, int i1, jni$_.JDoubleArray? ds) {
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    return _put(
      reference.pointer,
      _id_put as jni$_.JMethodIDPtr,
      i,
      i1,
      _$ds.pointer,
    ).integer;
  }

  static final _id_put$1 = _class.instanceMethodId(r'put', r'([I[D)I');

  static final _put$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int put(int[] is, double[] ds)`
  int put$1(jni$_.JIntArray? is$, jni$_.JDoubleArray? ds) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    return _put$1(
      reference.pointer,
      _id_put$1 as jni$_.JMethodIDPtr,
      _$is$.pointer,
      _$ds.pointer,
    ).integer;
  }

  static final _id_put$2 = _class.instanceMethodId(r'put', r'(II[F)I');

  static final _put$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Int32, jni$_.Int32, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int put(int i, int i1, float[] fs)`
  int put$2(int i, int i1, jni$_.JFloatArray? fs) {
    final _$fs = fs?.reference ?? jni$_.jNullReference;
    return _put$2(
      reference.pointer,
      _id_put$2 as jni$_.JMethodIDPtr,
      i,
      i1,
      _$fs.pointer,
    ).integer;
  }

  static final _id_put$3 = _class.instanceMethodId(r'put', r'([I[F)I');

  static final _put$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int put(int[] is, float[] fs)`
  int put$3(jni$_.JIntArray? is$, jni$_.JFloatArray? fs) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$fs = fs?.reference ?? jni$_.jNullReference;
    return _put$3(
      reference.pointer,
      _id_put$3 as jni$_.JMethodIDPtr,
      _$is$.pointer,
      _$fs.pointer,
    ).integer;
  }

  static final _id_put$4 = _class.instanceMethodId(r'put', r'(II[I)I');

  static final _put$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Int32, jni$_.Int32, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int put(int i, int i1, int[] is)`
  int put$4(int i, int i1, jni$_.JIntArray? is$) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _put$4(
      reference.pointer,
      _id_put$4 as jni$_.JMethodIDPtr,
      i,
      i1,
      _$is$.pointer,
    ).integer;
  }

  static final _id_put$5 = _class.instanceMethodId(r'put', r'([I[I)I');

  static final _put$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int put(int[] is, int[] is1)`
  int put$5(jni$_.JIntArray? is$, jni$_.JIntArray? is1) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$is1 = is1?.reference ?? jni$_.jNullReference;
    return _put$5(
      reference.pointer,
      _id_put$5 as jni$_.JMethodIDPtr,
      _$is$.pointer,
      _$is1.pointer,
    ).integer;
  }

  static final _id_put$6 = _class.instanceMethodId(r'put', r'(II[S)I');

  static final _put$6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Int32, jni$_.Int32, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int put(int i, int i1, short[] ss)`
  int put$6(int i, int i1, jni$_.JShortArray? ss) {
    final _$ss = ss?.reference ?? jni$_.jNullReference;
    return _put$6(
      reference.pointer,
      _id_put$6 as jni$_.JMethodIDPtr,
      i,
      i1,
      _$ss.pointer,
    ).integer;
  }

  static final _id_put$7 = _class.instanceMethodId(r'put', r'([I[S)I');

  static final _put$7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int put(int[] is, short[] ss)`
  int put$7(jni$_.JIntArray? is$, jni$_.JShortArray? ss) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$ss = ss?.reference ?? jni$_.jNullReference;
    return _put$7(
      reference.pointer,
      _id_put$7 as jni$_.JMethodIDPtr,
      _$is$.pointer,
      _$ss.pointer,
    ).integer;
  }

  static final _id_put$8 = _class.instanceMethodId(r'put', r'(II[B)I');

  static final _put$8 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Int32, jni$_.Int32, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int put(int i, int i1, byte[] bs)`
  int put$8(int i, int i1, jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _put$8(
      reference.pointer,
      _id_put$8 as jni$_.JMethodIDPtr,
      i,
      i1,
      _$bs.pointer,
    ).integer;
  }

  static final _id_put$9 = _class.instanceMethodId(r'put', r'([I[B)I');

  static final _put$9 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int put(int[] is, byte[] bs)`
  int put$9(jni$_.JIntArray? is$, jni$_.JByteArray? bs) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _put$9(
      reference.pointer,
      _id_put$9 as jni$_.JMethodIDPtr,
      _$is$.pointer,
      _$bs.pointer,
    ).integer;
  }

  static final _id_put$10 = _class.instanceMethodId(r'put', r'(II[BII)I');

  static final _put$10 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int put(int i, int i1, byte[] bs, int i2, int i3)`
  int put$10(int i, int i1, jni$_.JByteArray? bs, int i2, int i3) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _put$10(
      reference.pointer,
      _id_put$10 as jni$_.JMethodIDPtr,
      i,
      i1,
      _$bs.pointer,
      i2,
      i3,
    ).integer;
  }

  static final _id_put$11 = _class.instanceMethodId(r'put', r'([I[BII)I');

  static final _put$11 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int put(int[] is, byte[] bs, int i, int i1)`
  int put$11(jni$_.JIntArray? is$, jni$_.JByteArray? bs, int i, int i1) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _put$11(
      reference.pointer,
      _id_put$11 as jni$_.JMethodIDPtr,
      _$is$.pointer,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_get = _class.instanceMethodId(r'get', r'(II[B)I');

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Int32, jni$_.Int32, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(int i, int i1, byte[] bs)`
  int get(int i, int i1, jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      i,
      i1,
      _$bs.pointer,
    ).integer;
  }

  static final _id_get$1 = _class.instanceMethodId(r'get', r'([I[B)I');

  static final _get$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(int[] is, byte[] bs)`
  int get$1(jni$_.JIntArray? is$, jni$_.JByteArray? bs) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _get$1(
      reference.pointer,
      _id_get$1 as jni$_.JMethodIDPtr,
      _$is$.pointer,
      _$bs.pointer,
    ).integer;
  }

  static final _id_get$2 = _class.instanceMethodId(r'get', r'(II[S)I');

  static final _get$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Int32, jni$_.Int32, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(int i, int i1, short[] ss)`
  int get$2(int i, int i1, jni$_.JShortArray? ss) {
    final _$ss = ss?.reference ?? jni$_.jNullReference;
    return _get$2(
      reference.pointer,
      _id_get$2 as jni$_.JMethodIDPtr,
      i,
      i1,
      _$ss.pointer,
    ).integer;
  }

  static final _id_get$3 = _class.instanceMethodId(r'get', r'([I[S)I');

  static final _get$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(int[] is, short[] ss)`
  int get$3(jni$_.JIntArray? is$, jni$_.JShortArray? ss) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$ss = ss?.reference ?? jni$_.jNullReference;
    return _get$3(
      reference.pointer,
      _id_get$3 as jni$_.JMethodIDPtr,
      _$is$.pointer,
      _$ss.pointer,
    ).integer;
  }

  static final _id_get$4 = _class.instanceMethodId(r'get', r'(II[I)I');

  static final _get$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Int32, jni$_.Int32, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(int i, int i1, int[] is)`
  int get$4(int i, int i1, jni$_.JIntArray? is$) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _get$4(
      reference.pointer,
      _id_get$4 as jni$_.JMethodIDPtr,
      i,
      i1,
      _$is$.pointer,
    ).integer;
  }

  static final _id_get$5 = _class.instanceMethodId(r'get', r'([I[I)I');

  static final _get$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(int[] is, int[] is1)`
  int get$5(jni$_.JIntArray? is$, jni$_.JIntArray? is1) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$is1 = is1?.reference ?? jni$_.jNullReference;
    return _get$5(
      reference.pointer,
      _id_get$5 as jni$_.JMethodIDPtr,
      _$is$.pointer,
      _$is1.pointer,
    ).integer;
  }

  static final _id_get$6 = _class.instanceMethodId(r'get', r'(II[F)I');

  static final _get$6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Int32, jni$_.Int32, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(int i, int i1, float[] fs)`
  int get$6(int i, int i1, jni$_.JFloatArray? fs) {
    final _$fs = fs?.reference ?? jni$_.jNullReference;
    return _get$6(
      reference.pointer,
      _id_get$6 as jni$_.JMethodIDPtr,
      i,
      i1,
      _$fs.pointer,
    ).integer;
  }

  static final _id_get$7 = _class.instanceMethodId(r'get', r'([I[F)I');

  static final _get$7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(int[] is, float[] fs)`
  int get$7(jni$_.JIntArray? is$, jni$_.JFloatArray? fs) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$fs = fs?.reference ?? jni$_.jNullReference;
    return _get$7(
      reference.pointer,
      _id_get$7 as jni$_.JMethodIDPtr,
      _$is$.pointer,
      _$fs.pointer,
    ).integer;
  }

  static final _id_get$8 = _class.instanceMethodId(r'get', r'(II[D)I');

  static final _get$8 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Int32, jni$_.Int32, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(int i, int i1, double[] ds)`
  int get$8(int i, int i1, jni$_.JDoubleArray? ds) {
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    return _get$8(
      reference.pointer,
      _id_get$8 as jni$_.JMethodIDPtr,
      i,
      i1,
      _$ds.pointer,
    ).integer;
  }

  static final _id_get$9 = _class.instanceMethodId(r'get', r'([I[D)I');

  static final _get$9 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(int[] is, double[] ds)`
  int get$9(jni$_.JIntArray? is$, jni$_.JDoubleArray? ds) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    return _get$9(
      reference.pointer,
      _id_get$9 as jni$_.JMethodIDPtr,
      _$is$.pointer,
      _$ds.pointer,
    ).integer;
  }

  static final _id_get$10 = _class.instanceMethodId(r'get', r'(II)[D');

  static final _get$10 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public double[] get(int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray? get$10(int i, int i1) {
    return _get$10(
      reference.pointer,
      _id_get$10 as jni$_.JMethodIDPtr,
      i,
      i1,
    ).object<jni$_.JDoubleArray?>(const jni$_.JDoubleArrayNullableType());
  }

  static final _id_get$11 = _class.instanceMethodId(r'get', r'([I)[D');

  static final _get$11 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public double[] get(int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray? get$11(jni$_.JIntArray? is$) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _get$11(
      reference.pointer,
      _id_get$11 as jni$_.JMethodIDPtr,
      _$is$.pointer,
    ).object<jni$_.JDoubleArray?>(const jni$_.JDoubleArrayNullableType());
  }

  static final _id_height = _class.instanceMethodId(r'height', r'()I');

  static final _height =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int height()`
  int height() {
    return _height(reference.pointer, _id_height as jni$_.JMethodIDPtr).integer;
  }

  static final _id_width = _class.instanceMethodId(r'width', r'()I');

  static final _width =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int width()`
  int width() {
    return _width(reference.pointer, _id_width as jni$_.JMethodIDPtr).integer;
  }

  static final _id_at = _class.instanceMethodId(
    r'at',
    r'(Ljava/lang/Class;II)Lorg/opencv/core/Mat$Atable;',
  );

  static final _at =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public org.opencv.core.Mat$Atable<T> at(java.lang.Class<T> class, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  Mat$Atable<$T?>? at<$T extends jni$_.JObject?>(
    jni$_.JObject? class$,
    int i,
    int i1, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$class$ = class$?.reference ?? jni$_.jNullReference;
    return _at(
      reference.pointer,
      _id_at as jni$_.JMethodIDPtr,
      _$class$.pointer,
      i,
      i1,
    ).object<Mat$Atable<$T?>?>($Mat$Atable$NullableType<$T?>(T.nullableType));
  }

  static final _id_at$1 = _class.instanceMethodId(
    r'at',
    r'(Ljava/lang/Class;[I)Lorg/opencv/core/Mat$Atable;',
  );

  static final _at$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.opencv.core.Mat$Atable<T> at(java.lang.Class<T> class, int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  Mat$Atable<$T?>? at$1<$T extends jni$_.JObject?>(
    jni$_.JObject? class$,
    jni$_.JIntArray? is$, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$class$ = class$?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _at$1(
      reference.pointer,
      _id_at$1 as jni$_.JMethodIDPtr,
      _$class$.pointer,
      _$is$.pointer,
    ).object<Mat$Atable<$T?>?>($Mat$Atable$NullableType<$T?>(T.nullableType));
  }

  static final _id_getNativeObjAddr = _class.instanceMethodId(
    r'getNativeObjAddr',
    r'()J',
  );

  static final _getNativeObjAddr =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getNativeObjAddr()`
  int getNativeObjAddr() {
    return _getNativeObjAddr(
      reference.pointer,
      _id_getNativeObjAddr as jni$_.JMethodIDPtr,
    ).long;
  }
}

final class $Mat$NullableType extends jni$_.JObjType<Mat?> {
  @jni$_.internal
  const $Mat$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/opencv/core/Mat;';

  @jni$_.internal
  @core$_.override
  Mat? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Mat.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Mat?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Mat$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Mat$NullableType) &&
        other is $Mat$NullableType;
  }
}

final class $Mat$Type extends jni$_.JObjType<Mat> {
  @jni$_.internal
  const $Mat$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/opencv/core/Mat;';

  @jni$_.internal
  @core$_.override
  Mat fromReference(jni$_.JReference reference) => Mat.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Mat?> get nullableType => const $Mat$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Mat$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Mat$Type) && other is $Mat$Type;
  }
}

/// from: `org.opencv.core.Point`
class Point extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Point> $type;

  @jni$_.internal
  Point.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'org/opencv/core/Point');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Point$NullableType();
  static const type = $Point$Type();
  static final _id_x = _class.instanceFieldId(r'x', r'D');

  /// from: `public double x`
  double get x => _id_x.get(this, const jni$_.jdoubleType());

  /// from: `public double x`
  set x(double value) => _id_x.set(this, const jni$_.jdoubleType(), value);

  static final _id_y = _class.instanceFieldId(r'y', r'D');

  /// from: `public double y`
  double get y => _id_y.get(this, const jni$_.jdoubleType());

  /// from: `public double y`
  set y(double value) => _id_y.set(this, const jni$_.jdoubleType(), value);

  static final _id_new$ = _class.constructorId(r'(DD)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double, jni$_.Double)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
              double,
            )
          >();

  /// from: `public void <init>(double d, double d1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Point(double d, double d1) {
    return Point.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        d,
        d1,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'()V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Point.new$1() {
    return Point.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(r'([D)V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(double[] ds)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Point.new$2(jni$_.JDoubleArray? ds) {
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    return Point.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$ds.pointer,
      ).reference,
    );
  }

  static final _id_set = _class.instanceMethodId(r'set', r'([D)V');

  static final _set =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void set(double[] ds)`
  void set(jni$_.JDoubleArray? ds) {
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    _set(
      reference.pointer,
      _id_set as jni$_.JMethodIDPtr,
      _$ds.pointer,
    ).check();
  }

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Lorg/opencv/core/Point;',
  );

  static final _clone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.opencv.core.Point clone()`
  /// The returned object must be released after use, by calling the [release] method.
  Point? clone() {
    return _clone(
      reference.pointer,
      _id_clone as jni$_.JMethodIDPtr,
    ).object<Point?>(const $Point$NullableType());
  }

  static final _id_dot = _class.instanceMethodId(
    r'dot',
    r'(Lorg/opencv/core/Point;)D',
  );

  static final _dot =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public double dot(org.opencv.core.Point point)`
  double dot(Point? point) {
    final _$point = point?.reference ?? jni$_.jNullReference;
    return _dot(
      reference.pointer,
      _id_dot as jni$_.JMethodIDPtr,
      _$point.pointer,
    ).doubleFloat;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_inside = _class.instanceMethodId(
    r'inside',
    r'(Lorg/opencv/core/Rect;)Z',
  );

  static final _inside =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean inside(org.opencv.core.Rect rect)`
  bool inside(jni$_.JObject? rect) {
    final _$rect = rect?.reference ?? jni$_.jNullReference;
    return _inside(
      reference.pointer,
      _id_inside as jni$_.JMethodIDPtr,
      _$rect.pointer,
    ).boolean;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $Point$NullableType extends jni$_.JObjType<Point?> {
  @jni$_.internal
  const $Point$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/opencv/core/Point;';

  @jni$_.internal
  @core$_.override
  Point? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Point.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Point?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Point$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Point$NullableType) &&
        other is $Point$NullableType;
  }
}

final class $Point$Type extends jni$_.JObjType<Point> {
  @jni$_.internal
  const $Point$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/opencv/core/Point;';

  @jni$_.internal
  @core$_.override
  Point fromReference(jni$_.JReference reference) =>
      Point.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Point?> get nullableType => const $Point$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Point$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Point$Type) && other is $Point$Type;
  }
}

/// from: `org.opencv.objdetect.Dictionary`
class Dictionary extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Dictionary> $type;

  @jni$_.internal
  Dictionary.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/opencv/objdetect/Dictionary',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Dictionary$NullableType();
  static const type = $Dictionary$Type();
  static final _id_getNativeObjAddr = _class.instanceMethodId(
    r'getNativeObjAddr',
    r'()J',
  );

  static final _getNativeObjAddr =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getNativeObjAddr()`
  int getNativeObjAddr() {
    return _getNativeObjAddr(
      reference.pointer,
      _id_getNativeObjAddr as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_$__fromPtr__ = _class.staticMethodId(
    r'__fromPtr__',
    r'(J)Lorg/opencv/objdetect/Dictionary;',
  );

  static final _$__fromPtr__ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public org.opencv.objdetect.Dictionary __fromPtr__(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  static Dictionary? $__fromPtr__(int j) {
    return _$__fromPtr__(
      _class.reference.pointer,
      _id_$__fromPtr__ as jni$_.JMethodIDPtr,
      j,
    ).object<Dictionary?>(const $Dictionary$NullableType());
  }

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Dictionary() {
    return Dictionary.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Lorg/opencv/core/Mat;II)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void <init>(org.opencv.core.Mat mat, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Dictionary.new$1(Mat? mat, int i, int i1) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    return Dictionary.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$mat.pointer,
        i,
        i1,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(r'(Lorg/opencv/core/Mat;I)V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(org.opencv.core.Mat mat, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Dictionary.new$2(Mat? mat, int i) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    return Dictionary.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$mat.pointer,
        i,
      ).reference,
    );
  }

  static final _id_identify = _class.instanceMethodId(
    r'identify',
    r'(Lorg/opencv/core/Mat;[I[ID)Z',
  );

  static final _identify =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Double,
                  )
                >,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              double,
            )
          >();

  /// from: `public boolean identify(org.opencv.core.Mat mat, int[] is, int[] is1, double d)`
  bool identify(
    Mat? mat,
    jni$_.JIntArray? is$,
    jni$_.JIntArray? is1,
    double d,
  ) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$is1 = is1?.reference ?? jni$_.jNullReference;
    return _identify(
      reference.pointer,
      _id_identify as jni$_.JMethodIDPtr,
      _$mat.pointer,
      _$is$.pointer,
      _$is1.pointer,
      d,
    ).boolean;
  }

  static final _id_getDistanceToId = _class.instanceMethodId(
    r'getDistanceToId',
    r'(Lorg/opencv/core/Mat;IZ)I',
  );

  static final _getDistanceToId =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int getDistanceToId(org.opencv.core.Mat mat, int i, boolean z)`
  int getDistanceToId(Mat? mat, int i, bool z) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    return _getDistanceToId(
      reference.pointer,
      _id_getDistanceToId as jni$_.JMethodIDPtr,
      _$mat.pointer,
      i,
      z ? 1 : 0,
    ).integer;
  }

  static final _id_getDistanceToId$1 = _class.instanceMethodId(
    r'getDistanceToId',
    r'(Lorg/opencv/core/Mat;I)I',
  );

  static final _getDistanceToId$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public int getDistanceToId(org.opencv.core.Mat mat, int i)`
  int getDistanceToId$1(Mat? mat, int i) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    return _getDistanceToId$1(
      reference.pointer,
      _id_getDistanceToId$1 as jni$_.JMethodIDPtr,
      _$mat.pointer,
      i,
    ).integer;
  }

  static final _id_generateImageMarker = _class.instanceMethodId(
    r'generateImageMarker',
    r'(IILorg/opencv/core/Mat;I)V',
  );

  static final _generateImageMarker =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void generateImageMarker(int i, int i1, org.opencv.core.Mat mat, int i2)`
  void generateImageMarker(int i, int i1, Mat? mat, int i2) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    _generateImageMarker(
      reference.pointer,
      _id_generateImageMarker as jni$_.JMethodIDPtr,
      i,
      i1,
      _$mat.pointer,
      i2,
    ).check();
  }

  static final _id_generateImageMarker$1 = _class.instanceMethodId(
    r'generateImageMarker',
    r'(IILorg/opencv/core/Mat;)V',
  );

  static final _generateImageMarker$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Int32, jni$_.Int32, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void generateImageMarker(int i, int i1, org.opencv.core.Mat mat)`
  void generateImageMarker$1(int i, int i1, Mat? mat) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    _generateImageMarker$1(
      reference.pointer,
      _id_generateImageMarker$1 as jni$_.JMethodIDPtr,
      i,
      i1,
      _$mat.pointer,
    ).check();
  }

  static final _id_getByteListFromBits = _class.staticMethodId(
    r'getByteListFromBits',
    r'(Lorg/opencv/core/Mat;)Lorg/opencv/core/Mat;',
  );

  static final _getByteListFromBits =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public org.opencv.core.Mat getByteListFromBits(org.opencv.core.Mat mat)`
  /// The returned object must be released after use, by calling the [release] method.
  static Mat? getByteListFromBits(Mat? mat) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    return _getByteListFromBits(
      _class.reference.pointer,
      _id_getByteListFromBits as jni$_.JMethodIDPtr,
      _$mat.pointer,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_getBitsFromByteList = _class.staticMethodId(
    r'getBitsFromByteList',
    r'(Lorg/opencv/core/Mat;I)Lorg/opencv/core/Mat;',
  );

  static final _getBitsFromByteList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public org.opencv.core.Mat getBitsFromByteList(org.opencv.core.Mat mat, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static Mat? getBitsFromByteList(Mat? mat, int i) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    return _getBitsFromByteList(
      _class.reference.pointer,
      _id_getBitsFromByteList as jni$_.JMethodIDPtr,
      _$mat.pointer,
      i,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_get_bytesList = _class.instanceMethodId(
    r'get_bytesList',
    r'()Lorg/opencv/core/Mat;',
  );

  static final _get_bytesList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.opencv.core.Mat get_bytesList()`
  /// The returned object must be released after use, by calling the [release] method.
  Mat? get_bytesList() {
    return _get_bytesList(
      reference.pointer,
      _id_get_bytesList as jni$_.JMethodIDPtr,
    ).object<Mat?>(const $Mat$NullableType());
  }

  static final _id_set_bytesList = _class.instanceMethodId(
    r'set_bytesList',
    r'(Lorg/opencv/core/Mat;)V',
  );

  static final _set_bytesList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void set_bytesList(org.opencv.core.Mat mat)`
  void set_bytesList(Mat? mat) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    _set_bytesList(
      reference.pointer,
      _id_set_bytesList as jni$_.JMethodIDPtr,
      _$mat.pointer,
    ).check();
  }

  static final _id_get_markerSize = _class.instanceMethodId(
    r'get_markerSize',
    r'()I',
  );

  static final _get_markerSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int get_markerSize()`
  int get_markerSize() {
    return _get_markerSize(
      reference.pointer,
      _id_get_markerSize as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_set_markerSize = _class.instanceMethodId(
    r'set_markerSize',
    r'(I)V',
  );

  static final _set_markerSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void set_markerSize(int i)`
  void set_markerSize(int i) {
    _set_markerSize(
      reference.pointer,
      _id_set_markerSize as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_get_maxCorrectionBits = _class.instanceMethodId(
    r'get_maxCorrectionBits',
    r'()I',
  );

  static final _get_maxCorrectionBits =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int get_maxCorrectionBits()`
  int get_maxCorrectionBits() {
    return _get_maxCorrectionBits(
      reference.pointer,
      _id_get_maxCorrectionBits as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_set_maxCorrectionBits = _class.instanceMethodId(
    r'set_maxCorrectionBits',
    r'(I)V',
  );

  static final _set_maxCorrectionBits =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void set_maxCorrectionBits(int i)`
  void set_maxCorrectionBits(int i) {
    _set_maxCorrectionBits(
      reference.pointer,
      _id_set_maxCorrectionBits as jni$_.JMethodIDPtr,
      i,
    ).check();
  }
}

final class $Dictionary$NullableType extends jni$_.JObjType<Dictionary?> {
  @jni$_.internal
  const $Dictionary$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/opencv/objdetect/Dictionary;';

  @jni$_.internal
  @core$_.override
  Dictionary? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Dictionary.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Dictionary?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Dictionary$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Dictionary$NullableType) &&
        other is $Dictionary$NullableType;
  }
}

final class $Dictionary$Type extends jni$_.JObjType<Dictionary> {
  @jni$_.internal
  const $Dictionary$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/opencv/objdetect/Dictionary;';

  @jni$_.internal
  @core$_.override
  Dictionary fromReference(jni$_.JReference reference) =>
      Dictionary.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Dictionary?> get nullableType =>
      const $Dictionary$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Dictionary$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Dictionary$Type) && other is $Dictionary$Type;
  }
}

/// from: `org.opencv.objdetect.ArucoDetector`
class ArucoDetector extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ArucoDetector> $type;

  @jni$_.internal
  ArucoDetector.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/opencv/objdetect/ArucoDetector',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ArucoDetector$NullableType();
  static const type = $ArucoDetector$Type();
  static final _id_$__fromPtr__ = _class.staticMethodId(
    r'__fromPtr__',
    r'(J)Lorg/opencv/objdetect/ArucoDetector;',
  );

  static final _$__fromPtr__ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public org.opencv.objdetect.ArucoDetector __fromPtr__(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  static ArucoDetector? $__fromPtr__(int j) {
    return _$__fromPtr__(
      _class.reference.pointer,
      _id_$__fromPtr__ as jni$_.JMethodIDPtr,
      j,
    ).object<ArucoDetector?>(const $ArucoDetector$NullableType());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lorg/opencv/objdetect/Dictionary;Lorg/opencv/objdetect/DetectorParameters;Lorg/opencv/objdetect/RefineParameters;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(org.opencv.objdetect.Dictionary dictionary, org.opencv.objdetect.DetectorParameters detectorParameters, org.opencv.objdetect.RefineParameters refineParameters)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ArucoDetector(
    Dictionary? dictionary,
    DetectorParameters? detectorParameters,
    jni$_.JObject? refineParameters,
  ) {
    final _$dictionary = dictionary?.reference ?? jni$_.jNullReference;
    final _$detectorParameters =
        detectorParameters?.reference ?? jni$_.jNullReference;
    final _$refineParameters =
        refineParameters?.reference ?? jni$_.jNullReference;
    return ArucoDetector.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$dictionary.pointer,
        _$detectorParameters.pointer,
        _$refineParameters.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Lorg/opencv/objdetect/Dictionary;Lorg/opencv/objdetect/DetectorParameters;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(org.opencv.objdetect.Dictionary dictionary, org.opencv.objdetect.DetectorParameters detectorParameters)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ArucoDetector.new$1(
    Dictionary? dictionary,
    DetectorParameters? detectorParameters,
  ) {
    final _$dictionary = dictionary?.reference ?? jni$_.jNullReference;
    final _$detectorParameters =
        detectorParameters?.reference ?? jni$_.jNullReference;
    return ArucoDetector.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$dictionary.pointer,
        _$detectorParameters.pointer,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(
    r'(Lorg/opencv/objdetect/Dictionary;)V',
  );

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(org.opencv.objdetect.Dictionary dictionary)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ArucoDetector.new$2(Dictionary? dictionary) {
    final _$dictionary = dictionary?.reference ?? jni$_.jNullReference;
    return ArucoDetector.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$dictionary.pointer,
      ).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(r'()V');

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory ArucoDetector.new$3() {
    return ArucoDetector.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
      ).reference,
    );
  }

  static final _id_detectMarkers = _class.instanceMethodId(
    r'detectMarkers',
    r'(Lorg/opencv/core/Mat;Ljava/util/List;Lorg/opencv/core/Mat;Ljava/util/List;)V',
  );

  static final _detectMarkers =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void detectMarkers(org.opencv.core.Mat mat, java.util.List<org.opencv.core.Mat> list, org.opencv.core.Mat mat1, java.util.List<org.opencv.core.Mat> list1)`
  void detectMarkers(
    Mat? mat,
    jni$_.JList<Mat?>? list,
    Mat? mat1,
    jni$_.JList<Mat?>? list1,
  ) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$mat1 = mat1?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    _detectMarkers(
      reference.pointer,
      _id_detectMarkers as jni$_.JMethodIDPtr,
      _$mat.pointer,
      _$list.pointer,
      _$mat1.pointer,
      _$list1.pointer,
    ).check();
  }

  static final _id_detectMarkers$1 = _class.instanceMethodId(
    r'detectMarkers',
    r'(Lorg/opencv/core/Mat;Ljava/util/List;Lorg/opencv/core/Mat;)V',
  );

  static final _detectMarkers$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void detectMarkers(org.opencv.core.Mat mat, java.util.List<org.opencv.core.Mat> list, org.opencv.core.Mat mat1)`
  void detectMarkers$1(Mat? mat, jni$_.JList<Mat?>? list, Mat? mat1) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$mat1 = mat1?.reference ?? jni$_.jNullReference;
    _detectMarkers$1(
      reference.pointer,
      _id_detectMarkers$1 as jni$_.JMethodIDPtr,
      _$mat.pointer,
      _$list.pointer,
      _$mat1.pointer,
    ).check();
  }

  static final _id_refineDetectedMarkers = _class.instanceMethodId(
    r'refineDetectedMarkers',
    r'(Lorg/opencv/core/Mat;Lorg/opencv/objdetect/Board;Ljava/util/List;Lorg/opencv/core/Mat;Ljava/util/List;Lorg/opencv/core/Mat;Lorg/opencv/core/Mat;Lorg/opencv/core/Mat;)V',
  );

  static final _refineDetectedMarkers =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void refineDetectedMarkers(org.opencv.core.Mat mat, org.opencv.objdetect.Board board, java.util.List<org.opencv.core.Mat> list, org.opencv.core.Mat mat1, java.util.List<org.opencv.core.Mat> list1, org.opencv.core.Mat mat2, org.opencv.core.Mat mat3, org.opencv.core.Mat mat4)`
  void refineDetectedMarkers(
    Mat? mat,
    jni$_.JObject? board,
    jni$_.JList<Mat?>? list,
    Mat? mat1,
    jni$_.JList<Mat?>? list1,
    Mat? mat2,
    Mat? mat3,
    Mat? mat4,
  ) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    final _$board = board?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$mat1 = mat1?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$mat2 = mat2?.reference ?? jni$_.jNullReference;
    final _$mat3 = mat3?.reference ?? jni$_.jNullReference;
    final _$mat4 = mat4?.reference ?? jni$_.jNullReference;
    _refineDetectedMarkers(
      reference.pointer,
      _id_refineDetectedMarkers as jni$_.JMethodIDPtr,
      _$mat.pointer,
      _$board.pointer,
      _$list.pointer,
      _$mat1.pointer,
      _$list1.pointer,
      _$mat2.pointer,
      _$mat3.pointer,
      _$mat4.pointer,
    ).check();
  }

  static final _id_refineDetectedMarkers$1 = _class.instanceMethodId(
    r'refineDetectedMarkers',
    r'(Lorg/opencv/core/Mat;Lorg/opencv/objdetect/Board;Ljava/util/List;Lorg/opencv/core/Mat;Ljava/util/List;Lorg/opencv/core/Mat;Lorg/opencv/core/Mat;)V',
  );

  static final _refineDetectedMarkers$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void refineDetectedMarkers(org.opencv.core.Mat mat, org.opencv.objdetect.Board board, java.util.List<org.opencv.core.Mat> list, org.opencv.core.Mat mat1, java.util.List<org.opencv.core.Mat> list1, org.opencv.core.Mat mat2, org.opencv.core.Mat mat3)`
  void refineDetectedMarkers$1(
    Mat? mat,
    jni$_.JObject? board,
    jni$_.JList<Mat?>? list,
    Mat? mat1,
    jni$_.JList<Mat?>? list1,
    Mat? mat2,
    Mat? mat3,
  ) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    final _$board = board?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$mat1 = mat1?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$mat2 = mat2?.reference ?? jni$_.jNullReference;
    final _$mat3 = mat3?.reference ?? jni$_.jNullReference;
    _refineDetectedMarkers$1(
      reference.pointer,
      _id_refineDetectedMarkers$1 as jni$_.JMethodIDPtr,
      _$mat.pointer,
      _$board.pointer,
      _$list.pointer,
      _$mat1.pointer,
      _$list1.pointer,
      _$mat2.pointer,
      _$mat3.pointer,
    ).check();
  }

  static final _id_refineDetectedMarkers$2 = _class.instanceMethodId(
    r'refineDetectedMarkers',
    r'(Lorg/opencv/core/Mat;Lorg/opencv/objdetect/Board;Ljava/util/List;Lorg/opencv/core/Mat;Ljava/util/List;Lorg/opencv/core/Mat;)V',
  );

  static final _refineDetectedMarkers$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void refineDetectedMarkers(org.opencv.core.Mat mat, org.opencv.objdetect.Board board, java.util.List<org.opencv.core.Mat> list, org.opencv.core.Mat mat1, java.util.List<org.opencv.core.Mat> list1, org.opencv.core.Mat mat2)`
  void refineDetectedMarkers$2(
    Mat? mat,
    jni$_.JObject? board,
    jni$_.JList<Mat?>? list,
    Mat? mat1,
    jni$_.JList<Mat?>? list1,
    Mat? mat2,
  ) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    final _$board = board?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$mat1 = mat1?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$mat2 = mat2?.reference ?? jni$_.jNullReference;
    _refineDetectedMarkers$2(
      reference.pointer,
      _id_refineDetectedMarkers$2 as jni$_.JMethodIDPtr,
      _$mat.pointer,
      _$board.pointer,
      _$list.pointer,
      _$mat1.pointer,
      _$list1.pointer,
      _$mat2.pointer,
    ).check();
  }

  static final _id_refineDetectedMarkers$3 = _class.instanceMethodId(
    r'refineDetectedMarkers',
    r'(Lorg/opencv/core/Mat;Lorg/opencv/objdetect/Board;Ljava/util/List;Lorg/opencv/core/Mat;Ljava/util/List;)V',
  );

  static final _refineDetectedMarkers$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void refineDetectedMarkers(org.opencv.core.Mat mat, org.opencv.objdetect.Board board, java.util.List<org.opencv.core.Mat> list, org.opencv.core.Mat mat1, java.util.List<org.opencv.core.Mat> list1)`
  void refineDetectedMarkers$3(
    Mat? mat,
    jni$_.JObject? board,
    jni$_.JList<Mat?>? list,
    Mat? mat1,
    jni$_.JList<Mat?>? list1,
  ) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    final _$board = board?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$mat1 = mat1?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    _refineDetectedMarkers$3(
      reference.pointer,
      _id_refineDetectedMarkers$3 as jni$_.JMethodIDPtr,
      _$mat.pointer,
      _$board.pointer,
      _$list.pointer,
      _$mat1.pointer,
      _$list1.pointer,
    ).check();
  }

  static final _id_getDictionary = _class.instanceMethodId(
    r'getDictionary',
    r'()Lorg/opencv/objdetect/Dictionary;',
  );

  static final _getDictionary =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.opencv.objdetect.Dictionary getDictionary()`
  /// The returned object must be released after use, by calling the [release] method.
  Dictionary? getDictionary() {
    return _getDictionary(
      reference.pointer,
      _id_getDictionary as jni$_.JMethodIDPtr,
    ).object<Dictionary?>(const $Dictionary$NullableType());
  }

  static final _id_setDictionary = _class.instanceMethodId(
    r'setDictionary',
    r'(Lorg/opencv/objdetect/Dictionary;)V',
  );

  static final _setDictionary =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setDictionary(org.opencv.objdetect.Dictionary dictionary)`
  void setDictionary(Dictionary? dictionary) {
    final _$dictionary = dictionary?.reference ?? jni$_.jNullReference;
    _setDictionary(
      reference.pointer,
      _id_setDictionary as jni$_.JMethodIDPtr,
      _$dictionary.pointer,
    ).check();
  }

  static final _id_getDetectorParameters = _class.instanceMethodId(
    r'getDetectorParameters',
    r'()Lorg/opencv/objdetect/DetectorParameters;',
  );

  static final _getDetectorParameters =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.opencv.objdetect.DetectorParameters getDetectorParameters()`
  /// The returned object must be released after use, by calling the [release] method.
  DetectorParameters? getDetectorParameters() {
    return _getDetectorParameters(
      reference.pointer,
      _id_getDetectorParameters as jni$_.JMethodIDPtr,
    ).object<DetectorParameters?>(const $DetectorParameters$NullableType());
  }

  static final _id_setDetectorParameters = _class.instanceMethodId(
    r'setDetectorParameters',
    r'(Lorg/opencv/objdetect/DetectorParameters;)V',
  );

  static final _setDetectorParameters =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setDetectorParameters(org.opencv.objdetect.DetectorParameters detectorParameters)`
  void setDetectorParameters(DetectorParameters? detectorParameters) {
    final _$detectorParameters =
        detectorParameters?.reference ?? jni$_.jNullReference;
    _setDetectorParameters(
      reference.pointer,
      _id_setDetectorParameters as jni$_.JMethodIDPtr,
      _$detectorParameters.pointer,
    ).check();
  }

  static final _id_getRefineParameters = _class.instanceMethodId(
    r'getRefineParameters',
    r'()Lorg/opencv/objdetect/RefineParameters;',
  );

  static final _getRefineParameters =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.opencv.objdetect.RefineParameters getRefineParameters()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getRefineParameters() {
    return _getRefineParameters(
      reference.pointer,
      _id_getRefineParameters as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setRefineParameters = _class.instanceMethodId(
    r'setRefineParameters',
    r'(Lorg/opencv/objdetect/RefineParameters;)V',
  );

  static final _setRefineParameters =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setRefineParameters(org.opencv.objdetect.RefineParameters refineParameters)`
  void setRefineParameters(jni$_.JObject? refineParameters) {
    final _$refineParameters =
        refineParameters?.reference ?? jni$_.jNullReference;
    _setRefineParameters(
      reference.pointer,
      _id_setRefineParameters as jni$_.JMethodIDPtr,
      _$refineParameters.pointer,
    ).check();
  }
}

final class $ArucoDetector$NullableType extends jni$_.JObjType<ArucoDetector?> {
  @jni$_.internal
  const $ArucoDetector$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/opencv/objdetect/ArucoDetector;';

  @jni$_.internal
  @core$_.override
  ArucoDetector? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ArucoDetector.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ArucoDetector?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ArucoDetector$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ArucoDetector$NullableType) &&
        other is $ArucoDetector$NullableType;
  }
}

final class $ArucoDetector$Type extends jni$_.JObjType<ArucoDetector> {
  @jni$_.internal
  const $ArucoDetector$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/opencv/objdetect/ArucoDetector;';

  @jni$_.internal
  @core$_.override
  ArucoDetector fromReference(jni$_.JReference reference) =>
      ArucoDetector.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ArucoDetector?> get nullableType =>
      const $ArucoDetector$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ArucoDetector$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ArucoDetector$Type) &&
        other is $ArucoDetector$Type;
  }
}

/// from: `org.opencv.objdetect.DetectorParameters`
class DetectorParameters extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<DetectorParameters> $type;

  @jni$_.internal
  DetectorParameters.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/opencv/objdetect/DetectorParameters',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $DetectorParameters$NullableType();
  static const type = $DetectorParameters$Type();
  static final _id_getNativeObjAddr = _class.instanceMethodId(
    r'getNativeObjAddr',
    r'()J',
  );

  static final _getNativeObjAddr =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getNativeObjAddr()`
  int getNativeObjAddr() {
    return _getNativeObjAddr(
      reference.pointer,
      _id_getNativeObjAddr as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_$__fromPtr__ = _class.staticMethodId(
    r'__fromPtr__',
    r'(J)Lorg/opencv/objdetect/DetectorParameters;',
  );

  static final _$__fromPtr__ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public org.opencv.objdetect.DetectorParameters __fromPtr__(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  static DetectorParameters? $__fromPtr__(int j) {
    return _$__fromPtr__(
      _class.reference.pointer,
      _id_$__fromPtr__ as jni$_.JMethodIDPtr,
      j,
    ).object<DetectorParameters?>(const $DetectorParameters$NullableType());
  }

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory DetectorParameters() {
    return DetectorParameters.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_get_adaptiveThreshWinSizeMin = _class.instanceMethodId(
    r'get_adaptiveThreshWinSizeMin',
    r'()I',
  );

  static final _get_adaptiveThreshWinSizeMin =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int get_adaptiveThreshWinSizeMin()`
  int get_adaptiveThreshWinSizeMin() {
    return _get_adaptiveThreshWinSizeMin(
      reference.pointer,
      _id_get_adaptiveThreshWinSizeMin as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_set_adaptiveThreshWinSizeMin = _class.instanceMethodId(
    r'set_adaptiveThreshWinSizeMin',
    r'(I)V',
  );

  static final _set_adaptiveThreshWinSizeMin =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void set_adaptiveThreshWinSizeMin(int i)`
  void set_adaptiveThreshWinSizeMin(int i) {
    _set_adaptiveThreshWinSizeMin(
      reference.pointer,
      _id_set_adaptiveThreshWinSizeMin as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_get_adaptiveThreshWinSizeMax = _class.instanceMethodId(
    r'get_adaptiveThreshWinSizeMax',
    r'()I',
  );

  static final _get_adaptiveThreshWinSizeMax =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int get_adaptiveThreshWinSizeMax()`
  int get_adaptiveThreshWinSizeMax() {
    return _get_adaptiveThreshWinSizeMax(
      reference.pointer,
      _id_get_adaptiveThreshWinSizeMax as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_set_adaptiveThreshWinSizeMax = _class.instanceMethodId(
    r'set_adaptiveThreshWinSizeMax',
    r'(I)V',
  );

  static final _set_adaptiveThreshWinSizeMax =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void set_adaptiveThreshWinSizeMax(int i)`
  void set_adaptiveThreshWinSizeMax(int i) {
    _set_adaptiveThreshWinSizeMax(
      reference.pointer,
      _id_set_adaptiveThreshWinSizeMax as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_get_adaptiveThreshWinSizeStep = _class.instanceMethodId(
    r'get_adaptiveThreshWinSizeStep',
    r'()I',
  );

  static final _get_adaptiveThreshWinSizeStep =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int get_adaptiveThreshWinSizeStep()`
  int get_adaptiveThreshWinSizeStep() {
    return _get_adaptiveThreshWinSizeStep(
      reference.pointer,
      _id_get_adaptiveThreshWinSizeStep as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_set_adaptiveThreshWinSizeStep = _class.instanceMethodId(
    r'set_adaptiveThreshWinSizeStep',
    r'(I)V',
  );

  static final _set_adaptiveThreshWinSizeStep =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void set_adaptiveThreshWinSizeStep(int i)`
  void set_adaptiveThreshWinSizeStep(int i) {
    _set_adaptiveThreshWinSizeStep(
      reference.pointer,
      _id_set_adaptiveThreshWinSizeStep as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_get_adaptiveThreshConstant = _class.instanceMethodId(
    r'get_adaptiveThreshConstant',
    r'()D',
  );

  static final _get_adaptiveThreshConstant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public double get_adaptiveThreshConstant()`
  double get_adaptiveThreshConstant() {
    return _get_adaptiveThreshConstant(
      reference.pointer,
      _id_get_adaptiveThreshConstant as jni$_.JMethodIDPtr,
    ).doubleFloat;
  }

  static final _id_set_adaptiveThreshConstant = _class.instanceMethodId(
    r'set_adaptiveThreshConstant',
    r'(D)V',
  );

  static final _set_adaptiveThreshConstant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void set_adaptiveThreshConstant(double d)`
  void set_adaptiveThreshConstant(double d) {
    _set_adaptiveThreshConstant(
      reference.pointer,
      _id_set_adaptiveThreshConstant as jni$_.JMethodIDPtr,
      d,
    ).check();
  }

  static final _id_get_minMarkerPerimeterRate = _class.instanceMethodId(
    r'get_minMarkerPerimeterRate',
    r'()D',
  );

  static final _get_minMarkerPerimeterRate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public double get_minMarkerPerimeterRate()`
  double get_minMarkerPerimeterRate() {
    return _get_minMarkerPerimeterRate(
      reference.pointer,
      _id_get_minMarkerPerimeterRate as jni$_.JMethodIDPtr,
    ).doubleFloat;
  }

  static final _id_set_minMarkerPerimeterRate = _class.instanceMethodId(
    r'set_minMarkerPerimeterRate',
    r'(D)V',
  );

  static final _set_minMarkerPerimeterRate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void set_minMarkerPerimeterRate(double d)`
  void set_minMarkerPerimeterRate(double d) {
    _set_minMarkerPerimeterRate(
      reference.pointer,
      _id_set_minMarkerPerimeterRate as jni$_.JMethodIDPtr,
      d,
    ).check();
  }

  static final _id_get_maxMarkerPerimeterRate = _class.instanceMethodId(
    r'get_maxMarkerPerimeterRate',
    r'()D',
  );

  static final _get_maxMarkerPerimeterRate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public double get_maxMarkerPerimeterRate()`
  double get_maxMarkerPerimeterRate() {
    return _get_maxMarkerPerimeterRate(
      reference.pointer,
      _id_get_maxMarkerPerimeterRate as jni$_.JMethodIDPtr,
    ).doubleFloat;
  }

  static final _id_set_maxMarkerPerimeterRate = _class.instanceMethodId(
    r'set_maxMarkerPerimeterRate',
    r'(D)V',
  );

  static final _set_maxMarkerPerimeterRate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void set_maxMarkerPerimeterRate(double d)`
  void set_maxMarkerPerimeterRate(double d) {
    _set_maxMarkerPerimeterRate(
      reference.pointer,
      _id_set_maxMarkerPerimeterRate as jni$_.JMethodIDPtr,
      d,
    ).check();
  }

  static final _id_get_polygonalApproxAccuracyRate = _class.instanceMethodId(
    r'get_polygonalApproxAccuracyRate',
    r'()D',
  );

  static final _get_polygonalApproxAccuracyRate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public double get_polygonalApproxAccuracyRate()`
  double get_polygonalApproxAccuracyRate() {
    return _get_polygonalApproxAccuracyRate(
      reference.pointer,
      _id_get_polygonalApproxAccuracyRate as jni$_.JMethodIDPtr,
    ).doubleFloat;
  }

  static final _id_set_polygonalApproxAccuracyRate = _class.instanceMethodId(
    r'set_polygonalApproxAccuracyRate',
    r'(D)V',
  );

  static final _set_polygonalApproxAccuracyRate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void set_polygonalApproxAccuracyRate(double d)`
  void set_polygonalApproxAccuracyRate(double d) {
    _set_polygonalApproxAccuracyRate(
      reference.pointer,
      _id_set_polygonalApproxAccuracyRate as jni$_.JMethodIDPtr,
      d,
    ).check();
  }

  static final _id_get_minCornerDistanceRate = _class.instanceMethodId(
    r'get_minCornerDistanceRate',
    r'()D',
  );

  static final _get_minCornerDistanceRate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public double get_minCornerDistanceRate()`
  double get_minCornerDistanceRate() {
    return _get_minCornerDistanceRate(
      reference.pointer,
      _id_get_minCornerDistanceRate as jni$_.JMethodIDPtr,
    ).doubleFloat;
  }

  static final _id_set_minCornerDistanceRate = _class.instanceMethodId(
    r'set_minCornerDistanceRate',
    r'(D)V',
  );

  static final _set_minCornerDistanceRate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void set_minCornerDistanceRate(double d)`
  void set_minCornerDistanceRate(double d) {
    _set_minCornerDistanceRate(
      reference.pointer,
      _id_set_minCornerDistanceRate as jni$_.JMethodIDPtr,
      d,
    ).check();
  }

  static final _id_get_minDistanceToBorder = _class.instanceMethodId(
    r'get_minDistanceToBorder',
    r'()I',
  );

  static final _get_minDistanceToBorder =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int get_minDistanceToBorder()`
  int get_minDistanceToBorder() {
    return _get_minDistanceToBorder(
      reference.pointer,
      _id_get_minDistanceToBorder as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_set_minDistanceToBorder = _class.instanceMethodId(
    r'set_minDistanceToBorder',
    r'(I)V',
  );

  static final _set_minDistanceToBorder =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void set_minDistanceToBorder(int i)`
  void set_minDistanceToBorder(int i) {
    _set_minDistanceToBorder(
      reference.pointer,
      _id_set_minDistanceToBorder as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_get_minMarkerDistanceRate = _class.instanceMethodId(
    r'get_minMarkerDistanceRate',
    r'()D',
  );

  static final _get_minMarkerDistanceRate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public double get_minMarkerDistanceRate()`
  double get_minMarkerDistanceRate() {
    return _get_minMarkerDistanceRate(
      reference.pointer,
      _id_get_minMarkerDistanceRate as jni$_.JMethodIDPtr,
    ).doubleFloat;
  }

  static final _id_set_minMarkerDistanceRate = _class.instanceMethodId(
    r'set_minMarkerDistanceRate',
    r'(D)V',
  );

  static final _set_minMarkerDistanceRate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void set_minMarkerDistanceRate(double d)`
  void set_minMarkerDistanceRate(double d) {
    _set_minMarkerDistanceRate(
      reference.pointer,
      _id_set_minMarkerDistanceRate as jni$_.JMethodIDPtr,
      d,
    ).check();
  }

  static final _id_get_minGroupDistance = _class.instanceMethodId(
    r'get_minGroupDistance',
    r'()F',
  );

  static final _get_minGroupDistance =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public float get_minGroupDistance()`
  double get_minGroupDistance() {
    return _get_minGroupDistance(
      reference.pointer,
      _id_get_minGroupDistance as jni$_.JMethodIDPtr,
    ).float;
  }

  static final _id_set_minGroupDistance = _class.instanceMethodId(
    r'set_minGroupDistance',
    r'(F)V',
  );

  static final _set_minGroupDistance =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void set_minGroupDistance(float f)`
  void set_minGroupDistance(double f) {
    _set_minGroupDistance(
      reference.pointer,
      _id_set_minGroupDistance as jni$_.JMethodIDPtr,
      f,
    ).check();
  }

  static final _id_get_cornerRefinementMethod = _class.instanceMethodId(
    r'get_cornerRefinementMethod',
    r'()I',
  );

  static final _get_cornerRefinementMethod =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int get_cornerRefinementMethod()`
  int get_cornerRefinementMethod() {
    return _get_cornerRefinementMethod(
      reference.pointer,
      _id_get_cornerRefinementMethod as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_set_cornerRefinementMethod = _class.instanceMethodId(
    r'set_cornerRefinementMethod',
    r'(I)V',
  );

  static final _set_cornerRefinementMethod =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void set_cornerRefinementMethod(int i)`
  void set_cornerRefinementMethod(int i) {
    _set_cornerRefinementMethod(
      reference.pointer,
      _id_set_cornerRefinementMethod as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_get_cornerRefinementWinSize = _class.instanceMethodId(
    r'get_cornerRefinementWinSize',
    r'()I',
  );

  static final _get_cornerRefinementWinSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int get_cornerRefinementWinSize()`
  int get_cornerRefinementWinSize() {
    return _get_cornerRefinementWinSize(
      reference.pointer,
      _id_get_cornerRefinementWinSize as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_set_cornerRefinementWinSize = _class.instanceMethodId(
    r'set_cornerRefinementWinSize',
    r'(I)V',
  );

  static final _set_cornerRefinementWinSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void set_cornerRefinementWinSize(int i)`
  void set_cornerRefinementWinSize(int i) {
    _set_cornerRefinementWinSize(
      reference.pointer,
      _id_set_cornerRefinementWinSize as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_get_relativeCornerRefinmentWinSize = _class.instanceMethodId(
    r'get_relativeCornerRefinmentWinSize',
    r'()F',
  );

  static final _get_relativeCornerRefinmentWinSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public float get_relativeCornerRefinmentWinSize()`
  double get_relativeCornerRefinmentWinSize() {
    return _get_relativeCornerRefinmentWinSize(
      reference.pointer,
      _id_get_relativeCornerRefinmentWinSize as jni$_.JMethodIDPtr,
    ).float;
  }

  static final _id_set_relativeCornerRefinmentWinSize = _class.instanceMethodId(
    r'set_relativeCornerRefinmentWinSize',
    r'(F)V',
  );

  static final _set_relativeCornerRefinmentWinSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void set_relativeCornerRefinmentWinSize(float f)`
  void set_relativeCornerRefinmentWinSize(double f) {
    _set_relativeCornerRefinmentWinSize(
      reference.pointer,
      _id_set_relativeCornerRefinmentWinSize as jni$_.JMethodIDPtr,
      f,
    ).check();
  }

  static final _id_get_cornerRefinementMaxIterations = _class.instanceMethodId(
    r'get_cornerRefinementMaxIterations',
    r'()I',
  );

  static final _get_cornerRefinementMaxIterations =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int get_cornerRefinementMaxIterations()`
  int get_cornerRefinementMaxIterations() {
    return _get_cornerRefinementMaxIterations(
      reference.pointer,
      _id_get_cornerRefinementMaxIterations as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_set_cornerRefinementMaxIterations = _class.instanceMethodId(
    r'set_cornerRefinementMaxIterations',
    r'(I)V',
  );

  static final _set_cornerRefinementMaxIterations =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void set_cornerRefinementMaxIterations(int i)`
  void set_cornerRefinementMaxIterations(int i) {
    _set_cornerRefinementMaxIterations(
      reference.pointer,
      _id_set_cornerRefinementMaxIterations as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_get_cornerRefinementMinAccuracy = _class.instanceMethodId(
    r'get_cornerRefinementMinAccuracy',
    r'()D',
  );

  static final _get_cornerRefinementMinAccuracy =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public double get_cornerRefinementMinAccuracy()`
  double get_cornerRefinementMinAccuracy() {
    return _get_cornerRefinementMinAccuracy(
      reference.pointer,
      _id_get_cornerRefinementMinAccuracy as jni$_.JMethodIDPtr,
    ).doubleFloat;
  }

  static final _id_set_cornerRefinementMinAccuracy = _class.instanceMethodId(
    r'set_cornerRefinementMinAccuracy',
    r'(D)V',
  );

  static final _set_cornerRefinementMinAccuracy =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void set_cornerRefinementMinAccuracy(double d)`
  void set_cornerRefinementMinAccuracy(double d) {
    _set_cornerRefinementMinAccuracy(
      reference.pointer,
      _id_set_cornerRefinementMinAccuracy as jni$_.JMethodIDPtr,
      d,
    ).check();
  }

  static final _id_get_markerBorderBits = _class.instanceMethodId(
    r'get_markerBorderBits',
    r'()I',
  );

  static final _get_markerBorderBits =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int get_markerBorderBits()`
  int get_markerBorderBits() {
    return _get_markerBorderBits(
      reference.pointer,
      _id_get_markerBorderBits as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_set_markerBorderBits = _class.instanceMethodId(
    r'set_markerBorderBits',
    r'(I)V',
  );

  static final _set_markerBorderBits =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void set_markerBorderBits(int i)`
  void set_markerBorderBits(int i) {
    _set_markerBorderBits(
      reference.pointer,
      _id_set_markerBorderBits as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_get_perspectiveRemovePixelPerCell = _class.instanceMethodId(
    r'get_perspectiveRemovePixelPerCell',
    r'()I',
  );

  static final _get_perspectiveRemovePixelPerCell =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int get_perspectiveRemovePixelPerCell()`
  int get_perspectiveRemovePixelPerCell() {
    return _get_perspectiveRemovePixelPerCell(
      reference.pointer,
      _id_get_perspectiveRemovePixelPerCell as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_set_perspectiveRemovePixelPerCell = _class.instanceMethodId(
    r'set_perspectiveRemovePixelPerCell',
    r'(I)V',
  );

  static final _set_perspectiveRemovePixelPerCell =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void set_perspectiveRemovePixelPerCell(int i)`
  void set_perspectiveRemovePixelPerCell(int i) {
    _set_perspectiveRemovePixelPerCell(
      reference.pointer,
      _id_set_perspectiveRemovePixelPerCell as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_get_perspectiveRemoveIgnoredMarginPerCell = _class
      .instanceMethodId(r'get_perspectiveRemoveIgnoredMarginPerCell', r'()D');

  static final _get_perspectiveRemoveIgnoredMarginPerCell =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public double get_perspectiveRemoveIgnoredMarginPerCell()`
  double get_perspectiveRemoveIgnoredMarginPerCell() {
    return _get_perspectiveRemoveIgnoredMarginPerCell(
      reference.pointer,
      _id_get_perspectiveRemoveIgnoredMarginPerCell as jni$_.JMethodIDPtr,
    ).doubleFloat;
  }

  static final _id_set_perspectiveRemoveIgnoredMarginPerCell = _class
      .instanceMethodId(r'set_perspectiveRemoveIgnoredMarginPerCell', r'(D)V');

  static final _set_perspectiveRemoveIgnoredMarginPerCell =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void set_perspectiveRemoveIgnoredMarginPerCell(double d)`
  void set_perspectiveRemoveIgnoredMarginPerCell(double d) {
    _set_perspectiveRemoveIgnoredMarginPerCell(
      reference.pointer,
      _id_set_perspectiveRemoveIgnoredMarginPerCell as jni$_.JMethodIDPtr,
      d,
    ).check();
  }

  static final _id_get_maxErroneousBitsInBorderRate = _class.instanceMethodId(
    r'get_maxErroneousBitsInBorderRate',
    r'()D',
  );

  static final _get_maxErroneousBitsInBorderRate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public double get_maxErroneousBitsInBorderRate()`
  double get_maxErroneousBitsInBorderRate() {
    return _get_maxErroneousBitsInBorderRate(
      reference.pointer,
      _id_get_maxErroneousBitsInBorderRate as jni$_.JMethodIDPtr,
    ).doubleFloat;
  }

  static final _id_set_maxErroneousBitsInBorderRate = _class.instanceMethodId(
    r'set_maxErroneousBitsInBorderRate',
    r'(D)V',
  );

  static final _set_maxErroneousBitsInBorderRate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void set_maxErroneousBitsInBorderRate(double d)`
  void set_maxErroneousBitsInBorderRate(double d) {
    _set_maxErroneousBitsInBorderRate(
      reference.pointer,
      _id_set_maxErroneousBitsInBorderRate as jni$_.JMethodIDPtr,
      d,
    ).check();
  }

  static final _id_get_minOtsuStdDev = _class.instanceMethodId(
    r'get_minOtsuStdDev',
    r'()D',
  );

  static final _get_minOtsuStdDev =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public double get_minOtsuStdDev()`
  double get_minOtsuStdDev() {
    return _get_minOtsuStdDev(
      reference.pointer,
      _id_get_minOtsuStdDev as jni$_.JMethodIDPtr,
    ).doubleFloat;
  }

  static final _id_set_minOtsuStdDev = _class.instanceMethodId(
    r'set_minOtsuStdDev',
    r'(D)V',
  );

  static final _set_minOtsuStdDev =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void set_minOtsuStdDev(double d)`
  void set_minOtsuStdDev(double d) {
    _set_minOtsuStdDev(
      reference.pointer,
      _id_set_minOtsuStdDev as jni$_.JMethodIDPtr,
      d,
    ).check();
  }

  static final _id_get_errorCorrectionRate = _class.instanceMethodId(
    r'get_errorCorrectionRate',
    r'()D',
  );

  static final _get_errorCorrectionRate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public double get_errorCorrectionRate()`
  double get_errorCorrectionRate() {
    return _get_errorCorrectionRate(
      reference.pointer,
      _id_get_errorCorrectionRate as jni$_.JMethodIDPtr,
    ).doubleFloat;
  }

  static final _id_set_errorCorrectionRate = _class.instanceMethodId(
    r'set_errorCorrectionRate',
    r'(D)V',
  );

  static final _set_errorCorrectionRate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void set_errorCorrectionRate(double d)`
  void set_errorCorrectionRate(double d) {
    _set_errorCorrectionRate(
      reference.pointer,
      _id_set_errorCorrectionRate as jni$_.JMethodIDPtr,
      d,
    ).check();
  }

  static final _id_get_aprilTagQuadDecimate = _class.instanceMethodId(
    r'get_aprilTagQuadDecimate',
    r'()F',
  );

  static final _get_aprilTagQuadDecimate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public float get_aprilTagQuadDecimate()`
  double get_aprilTagQuadDecimate() {
    return _get_aprilTagQuadDecimate(
      reference.pointer,
      _id_get_aprilTagQuadDecimate as jni$_.JMethodIDPtr,
    ).float;
  }

  static final _id_set_aprilTagQuadDecimate = _class.instanceMethodId(
    r'set_aprilTagQuadDecimate',
    r'(F)V',
  );

  static final _set_aprilTagQuadDecimate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void set_aprilTagQuadDecimate(float f)`
  void set_aprilTagQuadDecimate(double f) {
    _set_aprilTagQuadDecimate(
      reference.pointer,
      _id_set_aprilTagQuadDecimate as jni$_.JMethodIDPtr,
      f,
    ).check();
  }

  static final _id_get_aprilTagQuadSigma = _class.instanceMethodId(
    r'get_aprilTagQuadSigma',
    r'()F',
  );

  static final _get_aprilTagQuadSigma =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public float get_aprilTagQuadSigma()`
  double get_aprilTagQuadSigma() {
    return _get_aprilTagQuadSigma(
      reference.pointer,
      _id_get_aprilTagQuadSigma as jni$_.JMethodIDPtr,
    ).float;
  }

  static final _id_set_aprilTagQuadSigma = _class.instanceMethodId(
    r'set_aprilTagQuadSigma',
    r'(F)V',
  );

  static final _set_aprilTagQuadSigma =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void set_aprilTagQuadSigma(float f)`
  void set_aprilTagQuadSigma(double f) {
    _set_aprilTagQuadSigma(
      reference.pointer,
      _id_set_aprilTagQuadSigma as jni$_.JMethodIDPtr,
      f,
    ).check();
  }

  static final _id_get_aprilTagMinClusterPixels = _class.instanceMethodId(
    r'get_aprilTagMinClusterPixels',
    r'()I',
  );

  static final _get_aprilTagMinClusterPixels =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int get_aprilTagMinClusterPixels()`
  int get_aprilTagMinClusterPixels() {
    return _get_aprilTagMinClusterPixels(
      reference.pointer,
      _id_get_aprilTagMinClusterPixels as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_set_aprilTagMinClusterPixels = _class.instanceMethodId(
    r'set_aprilTagMinClusterPixels',
    r'(I)V',
  );

  static final _set_aprilTagMinClusterPixels =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void set_aprilTagMinClusterPixels(int i)`
  void set_aprilTagMinClusterPixels(int i) {
    _set_aprilTagMinClusterPixels(
      reference.pointer,
      _id_set_aprilTagMinClusterPixels as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_get_aprilTagMaxNmaxima = _class.instanceMethodId(
    r'get_aprilTagMaxNmaxima',
    r'()I',
  );

  static final _get_aprilTagMaxNmaxima =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int get_aprilTagMaxNmaxima()`
  int get_aprilTagMaxNmaxima() {
    return _get_aprilTagMaxNmaxima(
      reference.pointer,
      _id_get_aprilTagMaxNmaxima as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_set_aprilTagMaxNmaxima = _class.instanceMethodId(
    r'set_aprilTagMaxNmaxima',
    r'(I)V',
  );

  static final _set_aprilTagMaxNmaxima =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void set_aprilTagMaxNmaxima(int i)`
  void set_aprilTagMaxNmaxima(int i) {
    _set_aprilTagMaxNmaxima(
      reference.pointer,
      _id_set_aprilTagMaxNmaxima as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_get_aprilTagCriticalRad = _class.instanceMethodId(
    r'get_aprilTagCriticalRad',
    r'()F',
  );

  static final _get_aprilTagCriticalRad =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public float get_aprilTagCriticalRad()`
  double get_aprilTagCriticalRad() {
    return _get_aprilTagCriticalRad(
      reference.pointer,
      _id_get_aprilTagCriticalRad as jni$_.JMethodIDPtr,
    ).float;
  }

  static final _id_set_aprilTagCriticalRad = _class.instanceMethodId(
    r'set_aprilTagCriticalRad',
    r'(F)V',
  );

  static final _set_aprilTagCriticalRad =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void set_aprilTagCriticalRad(float f)`
  void set_aprilTagCriticalRad(double f) {
    _set_aprilTagCriticalRad(
      reference.pointer,
      _id_set_aprilTagCriticalRad as jni$_.JMethodIDPtr,
      f,
    ).check();
  }

  static final _id_get_aprilTagMaxLineFitMse = _class.instanceMethodId(
    r'get_aprilTagMaxLineFitMse',
    r'()F',
  );

  static final _get_aprilTagMaxLineFitMse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public float get_aprilTagMaxLineFitMse()`
  double get_aprilTagMaxLineFitMse() {
    return _get_aprilTagMaxLineFitMse(
      reference.pointer,
      _id_get_aprilTagMaxLineFitMse as jni$_.JMethodIDPtr,
    ).float;
  }

  static final _id_set_aprilTagMaxLineFitMse = _class.instanceMethodId(
    r'set_aprilTagMaxLineFitMse',
    r'(F)V',
  );

  static final _set_aprilTagMaxLineFitMse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void set_aprilTagMaxLineFitMse(float f)`
  void set_aprilTagMaxLineFitMse(double f) {
    _set_aprilTagMaxLineFitMse(
      reference.pointer,
      _id_set_aprilTagMaxLineFitMse as jni$_.JMethodIDPtr,
      f,
    ).check();
  }

  static final _id_get_aprilTagMinWhiteBlackDiff = _class.instanceMethodId(
    r'get_aprilTagMinWhiteBlackDiff',
    r'()I',
  );

  static final _get_aprilTagMinWhiteBlackDiff =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int get_aprilTagMinWhiteBlackDiff()`
  int get_aprilTagMinWhiteBlackDiff() {
    return _get_aprilTagMinWhiteBlackDiff(
      reference.pointer,
      _id_get_aprilTagMinWhiteBlackDiff as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_set_aprilTagMinWhiteBlackDiff = _class.instanceMethodId(
    r'set_aprilTagMinWhiteBlackDiff',
    r'(I)V',
  );

  static final _set_aprilTagMinWhiteBlackDiff =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void set_aprilTagMinWhiteBlackDiff(int i)`
  void set_aprilTagMinWhiteBlackDiff(int i) {
    _set_aprilTagMinWhiteBlackDiff(
      reference.pointer,
      _id_set_aprilTagMinWhiteBlackDiff as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_get_aprilTagDeglitch = _class.instanceMethodId(
    r'get_aprilTagDeglitch',
    r'()I',
  );

  static final _get_aprilTagDeglitch =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int get_aprilTagDeglitch()`
  int get_aprilTagDeglitch() {
    return _get_aprilTagDeglitch(
      reference.pointer,
      _id_get_aprilTagDeglitch as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_set_aprilTagDeglitch = _class.instanceMethodId(
    r'set_aprilTagDeglitch',
    r'(I)V',
  );

  static final _set_aprilTagDeglitch =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void set_aprilTagDeglitch(int i)`
  void set_aprilTagDeglitch(int i) {
    _set_aprilTagDeglitch(
      reference.pointer,
      _id_set_aprilTagDeglitch as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_get_detectInvertedMarker = _class.instanceMethodId(
    r'get_detectInvertedMarker',
    r'()Z',
  );

  static final _get_detectInvertedMarker =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean get_detectInvertedMarker()`
  bool get_detectInvertedMarker() {
    return _get_detectInvertedMarker(
      reference.pointer,
      _id_get_detectInvertedMarker as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_set_detectInvertedMarker = _class.instanceMethodId(
    r'set_detectInvertedMarker',
    r'(Z)V',
  );

  static final _set_detectInvertedMarker =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void set_detectInvertedMarker(boolean z)`
  void set_detectInvertedMarker(bool z) {
    _set_detectInvertedMarker(
      reference.pointer,
      _id_set_detectInvertedMarker as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_get_useAruco3Detection = _class.instanceMethodId(
    r'get_useAruco3Detection',
    r'()Z',
  );

  static final _get_useAruco3Detection =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean get_useAruco3Detection()`
  bool get_useAruco3Detection() {
    return _get_useAruco3Detection(
      reference.pointer,
      _id_get_useAruco3Detection as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_set_useAruco3Detection = _class.instanceMethodId(
    r'set_useAruco3Detection',
    r'(Z)V',
  );

  static final _set_useAruco3Detection =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void set_useAruco3Detection(boolean z)`
  void set_useAruco3Detection(bool z) {
    _set_useAruco3Detection(
      reference.pointer,
      _id_set_useAruco3Detection as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_get_minSideLengthCanonicalImg = _class.instanceMethodId(
    r'get_minSideLengthCanonicalImg',
    r'()I',
  );

  static final _get_minSideLengthCanonicalImg =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int get_minSideLengthCanonicalImg()`
  int get_minSideLengthCanonicalImg() {
    return _get_minSideLengthCanonicalImg(
      reference.pointer,
      _id_get_minSideLengthCanonicalImg as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_set_minSideLengthCanonicalImg = _class.instanceMethodId(
    r'set_minSideLengthCanonicalImg',
    r'(I)V',
  );

  static final _set_minSideLengthCanonicalImg =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void set_minSideLengthCanonicalImg(int i)`
  void set_minSideLengthCanonicalImg(int i) {
    _set_minSideLengthCanonicalImg(
      reference.pointer,
      _id_set_minSideLengthCanonicalImg as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_get_minMarkerLengthRatioOriginalImg = _class
      .instanceMethodId(r'get_minMarkerLengthRatioOriginalImg', r'()F');

  static final _get_minMarkerLengthRatioOriginalImg =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public float get_minMarkerLengthRatioOriginalImg()`
  double get_minMarkerLengthRatioOriginalImg() {
    return _get_minMarkerLengthRatioOriginalImg(
      reference.pointer,
      _id_get_minMarkerLengthRatioOriginalImg as jni$_.JMethodIDPtr,
    ).float;
  }

  static final _id_set_minMarkerLengthRatioOriginalImg = _class
      .instanceMethodId(r'set_minMarkerLengthRatioOriginalImg', r'(F)V');

  static final _set_minMarkerLengthRatioOriginalImg =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void set_minMarkerLengthRatioOriginalImg(float f)`
  void set_minMarkerLengthRatioOriginalImg(double f) {
    _set_minMarkerLengthRatioOriginalImg(
      reference.pointer,
      _id_set_minMarkerLengthRatioOriginalImg as jni$_.JMethodIDPtr,
      f,
    ).check();
  }
}

final class $DetectorParameters$NullableType
    extends jni$_.JObjType<DetectorParameters?> {
  @jni$_.internal
  const $DetectorParameters$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/opencv/objdetect/DetectorParameters;';

  @jni$_.internal
  @core$_.override
  DetectorParameters? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : DetectorParameters.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DetectorParameters?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DetectorParameters$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DetectorParameters$NullableType) &&
        other is $DetectorParameters$NullableType;
  }
}

final class $DetectorParameters$Type
    extends jni$_.JObjType<DetectorParameters> {
  @jni$_.internal
  const $DetectorParameters$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/opencv/objdetect/DetectorParameters;';

  @jni$_.internal
  @core$_.override
  DetectorParameters fromReference(jni$_.JReference reference) =>
      DetectorParameters.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DetectorParameters?> get nullableType =>
      const $DetectorParameters$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DetectorParameters$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DetectorParameters$Type) &&
        other is $DetectorParameters$Type;
  }
}

/// from: `org.opencv.objdetect.Objdetect`
class Objdetect extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Objdetect> $type;

  @jni$_.internal
  Objdetect.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'org/opencv/objdetect/Objdetect');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Objdetect$NullableType();
  static const type = $Objdetect$Type();

  /// from: `static public final int CASCADE_DO_CANNY_PRUNING`
  static const CASCADE_DO_CANNY_PRUNING = 1;

  /// from: `static public final int CASCADE_SCALE_IMAGE`
  static const CASCADE_SCALE_IMAGE = 2;

  /// from: `static public final int CASCADE_FIND_BIGGEST_OBJECT`
  static const CASCADE_FIND_BIGGEST_OBJECT = 4;

  /// from: `static public final int CASCADE_DO_ROUGH_SEARCH`
  static const CASCADE_DO_ROUGH_SEARCH = 8;

  /// from: `static public final int DetectionBasedTracker_DETECTED_NOT_SHOWN_YET`
  static const DetectionBasedTracker_DETECTED_NOT_SHOWN_YET = 0;

  /// from: `static public final int DetectionBasedTracker_DETECTED`
  static const DetectionBasedTracker_DETECTED = 1;

  /// from: `static public final int DetectionBasedTracker_DETECTED_TEMPORARY_LOST`
  static const DetectionBasedTracker_DETECTED_TEMPORARY_LOST = 2;

  /// from: `static public final int DetectionBasedTracker_WRONG_OBJECT`
  static const DetectionBasedTracker_WRONG_OBJECT = 3;

  /// from: `static public final int CORNER_REFINE_NONE`
  static const CORNER_REFINE_NONE = 0;

  /// from: `static public final int CORNER_REFINE_SUBPIX`
  static const CORNER_REFINE_SUBPIX = 1;

  /// from: `static public final int CORNER_REFINE_CONTOUR`
  static const CORNER_REFINE_CONTOUR = 2;

  /// from: `static public final int CORNER_REFINE_APRILTAG`
  static const CORNER_REFINE_APRILTAG = 3;

  /// from: `static public final int DICT_4X4_50`
  static const DICT_4X4_50 = 0;

  /// from: `static public final int DICT_4X4_100`
  static const DICT_4X4_100 = 1;

  /// from: `static public final int DICT_4X4_250`
  static const DICT_4X4_250 = 2;

  /// from: `static public final int DICT_4X4_1000`
  static const DICT_4X4_1000 = 3;

  /// from: `static public final int DICT_5X5_50`
  static const DICT_5X5_50 = 4;

  /// from: `static public final int DICT_5X5_100`
  static const DICT_5X5_100 = 5;

  /// from: `static public final int DICT_5X5_250`
  static const DICT_5X5_250 = 6;

  /// from: `static public final int DICT_5X5_1000`
  static const DICT_5X5_1000 = 7;

  /// from: `static public final int DICT_6X6_50`
  static const DICT_6X6_50 = 8;

  /// from: `static public final int DICT_6X6_100`
  static const DICT_6X6_100 = 9;

  /// from: `static public final int DICT_6X6_250`
  static const DICT_6X6_250 = 10;

  /// from: `static public final int DICT_6X6_1000`
  static const DICT_6X6_1000 = 11;

  /// from: `static public final int DICT_7X7_50`
  static const DICT_7X7_50 = 12;

  /// from: `static public final int DICT_7X7_100`
  static const DICT_7X7_100 = 13;

  /// from: `static public final int DICT_7X7_250`
  static const DICT_7X7_250 = 14;

  /// from: `static public final int DICT_7X7_1000`
  static const DICT_7X7_1000 = 15;

  /// from: `static public final int DICT_ARUCO_ORIGINAL`
  static const DICT_ARUCO_ORIGINAL = 16;

  /// from: `static public final int DICT_APRILTAG_16h5`
  static const DICT_APRILTAG_16h5 = 17;

  /// from: `static public final int DICT_APRILTAG_25h9`
  static const DICT_APRILTAG_25h9 = 18;

  /// from: `static public final int DICT_APRILTAG_36h10`
  static const DICT_APRILTAG_36h10 = 19;

  /// from: `static public final int DICT_APRILTAG_36h11`
  static const DICT_APRILTAG_36h11 = 20;

  /// from: `static public final int DICT_ARUCO_MIP_36h12`
  static const DICT_ARUCO_MIP_36h12 = 21;
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Objdetect() {
    return Objdetect.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_groupRectangles = _class.staticMethodId(
    r'groupRectangles',
    r'(Lorg/opencv/core/MatOfRect;Lorg/opencv/core/MatOfInt;ID)V',
  );

  static final _groupRectangles =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Double,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              double,
            )
          >();

  /// from: `static public void groupRectangles(org.opencv.core.MatOfRect matOfRect, org.opencv.core.MatOfInt matOfInt, int i, double d)`
  static void groupRectangles(
    jni$_.JObject? matOfRect,
    jni$_.JObject? matOfInt,
    int i,
    double d,
  ) {
    final _$matOfRect = matOfRect?.reference ?? jni$_.jNullReference;
    final _$matOfInt = matOfInt?.reference ?? jni$_.jNullReference;
    _groupRectangles(
      _class.reference.pointer,
      _id_groupRectangles as jni$_.JMethodIDPtr,
      _$matOfRect.pointer,
      _$matOfInt.pointer,
      i,
      d,
    ).check();
  }

  static final _id_groupRectangles$1 = _class.staticMethodId(
    r'groupRectangles',
    r'(Lorg/opencv/core/MatOfRect;Lorg/opencv/core/MatOfInt;I)V',
  );

  static final _groupRectangles$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public void groupRectangles(org.opencv.core.MatOfRect matOfRect, org.opencv.core.MatOfInt matOfInt, int i)`
  static void groupRectangles$1(
    jni$_.JObject? matOfRect,
    jni$_.JObject? matOfInt,
    int i,
  ) {
    final _$matOfRect = matOfRect?.reference ?? jni$_.jNullReference;
    final _$matOfInt = matOfInt?.reference ?? jni$_.jNullReference;
    _groupRectangles$1(
      _class.reference.pointer,
      _id_groupRectangles$1 as jni$_.JMethodIDPtr,
      _$matOfRect.pointer,
      _$matOfInt.pointer,
      i,
    ).check();
  }

  static final _id_drawDetectedMarkers = _class.staticMethodId(
    r'drawDetectedMarkers',
    r'(Lorg/opencv/core/Mat;Ljava/util/List;Lorg/opencv/core/Mat;Lorg/opencv/core/Scalar;)V',
  );

  static final _drawDetectedMarkers =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void drawDetectedMarkers(org.opencv.core.Mat mat, java.util.List<org.opencv.core.Mat> list, org.opencv.core.Mat mat1, org.opencv.core.Scalar scalar)`
  static void drawDetectedMarkers(
    Mat? mat,
    jni$_.JList<Mat?>? list,
    Mat? mat1,
    jni$_.JObject? scalar,
  ) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$mat1 = mat1?.reference ?? jni$_.jNullReference;
    final _$scalar = scalar?.reference ?? jni$_.jNullReference;
    _drawDetectedMarkers(
      _class.reference.pointer,
      _id_drawDetectedMarkers as jni$_.JMethodIDPtr,
      _$mat.pointer,
      _$list.pointer,
      _$mat1.pointer,
      _$scalar.pointer,
    ).check();
  }

  static final _id_drawDetectedMarkers$1 = _class.staticMethodId(
    r'drawDetectedMarkers',
    r'(Lorg/opencv/core/Mat;Ljava/util/List;Lorg/opencv/core/Mat;)V',
  );

  static final _drawDetectedMarkers$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void drawDetectedMarkers(org.opencv.core.Mat mat, java.util.List<org.opencv.core.Mat> list, org.opencv.core.Mat mat1)`
  static void drawDetectedMarkers$1(
    Mat? mat,
    jni$_.JList<Mat?>? list,
    Mat? mat1,
  ) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$mat1 = mat1?.reference ?? jni$_.jNullReference;
    _drawDetectedMarkers$1(
      _class.reference.pointer,
      _id_drawDetectedMarkers$1 as jni$_.JMethodIDPtr,
      _$mat.pointer,
      _$list.pointer,
      _$mat1.pointer,
    ).check();
  }

  static final _id_drawDetectedMarkers$2 = _class.staticMethodId(
    r'drawDetectedMarkers',
    r'(Lorg/opencv/core/Mat;Ljava/util/List;)V',
  );

  static final _drawDetectedMarkers$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void drawDetectedMarkers(org.opencv.core.Mat mat, java.util.List<org.opencv.core.Mat> list)`
  static void drawDetectedMarkers$2(Mat? mat, jni$_.JList<Mat?>? list) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    _drawDetectedMarkers$2(
      _class.reference.pointer,
      _id_drawDetectedMarkers$2 as jni$_.JMethodIDPtr,
      _$mat.pointer,
      _$list.pointer,
    ).check();
  }

  static final _id_generateImageMarker = _class.staticMethodId(
    r'generateImageMarker',
    r'(Lorg/opencv/objdetect/Dictionary;IILorg/opencv/core/Mat;I)V',
  );

  static final _generateImageMarker =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public void generateImageMarker(org.opencv.objdetect.Dictionary dictionary, int i, int i1, org.opencv.core.Mat mat, int i2)`
  static void generateImageMarker(
    Dictionary? dictionary,
    int i,
    int i1,
    Mat? mat,
    int i2,
  ) {
    final _$dictionary = dictionary?.reference ?? jni$_.jNullReference;
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    _generateImageMarker(
      _class.reference.pointer,
      _id_generateImageMarker as jni$_.JMethodIDPtr,
      _$dictionary.pointer,
      i,
      i1,
      _$mat.pointer,
      i2,
    ).check();
  }

  static final _id_generateImageMarker$1 = _class.staticMethodId(
    r'generateImageMarker',
    r'(Lorg/opencv/objdetect/Dictionary;IILorg/opencv/core/Mat;)V',
  );

  static final _generateImageMarker$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void generateImageMarker(org.opencv.objdetect.Dictionary dictionary, int i, int i1, org.opencv.core.Mat mat)`
  static void generateImageMarker$1(
    Dictionary? dictionary,
    int i,
    int i1,
    Mat? mat,
  ) {
    final _$dictionary = dictionary?.reference ?? jni$_.jNullReference;
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    _generateImageMarker$1(
      _class.reference.pointer,
      _id_generateImageMarker$1 as jni$_.JMethodIDPtr,
      _$dictionary.pointer,
      i,
      i1,
      _$mat.pointer,
    ).check();
  }

  static final _id_drawDetectedCornersCharuco = _class.staticMethodId(
    r'drawDetectedCornersCharuco',
    r'(Lorg/opencv/core/Mat;Lorg/opencv/core/Mat;Lorg/opencv/core/Mat;Lorg/opencv/core/Scalar;)V',
  );

  static final _drawDetectedCornersCharuco =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void drawDetectedCornersCharuco(org.opencv.core.Mat mat, org.opencv.core.Mat mat1, org.opencv.core.Mat mat2, org.opencv.core.Scalar scalar)`
  static void drawDetectedCornersCharuco(
    Mat? mat,
    Mat? mat1,
    Mat? mat2,
    jni$_.JObject? scalar,
  ) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    final _$mat1 = mat1?.reference ?? jni$_.jNullReference;
    final _$mat2 = mat2?.reference ?? jni$_.jNullReference;
    final _$scalar = scalar?.reference ?? jni$_.jNullReference;
    _drawDetectedCornersCharuco(
      _class.reference.pointer,
      _id_drawDetectedCornersCharuco as jni$_.JMethodIDPtr,
      _$mat.pointer,
      _$mat1.pointer,
      _$mat2.pointer,
      _$scalar.pointer,
    ).check();
  }

  static final _id_drawDetectedCornersCharuco$1 = _class.staticMethodId(
    r'drawDetectedCornersCharuco',
    r'(Lorg/opencv/core/Mat;Lorg/opencv/core/Mat;Lorg/opencv/core/Mat;)V',
  );

  static final _drawDetectedCornersCharuco$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void drawDetectedCornersCharuco(org.opencv.core.Mat mat, org.opencv.core.Mat mat1, org.opencv.core.Mat mat2)`
  static void drawDetectedCornersCharuco$1(Mat? mat, Mat? mat1, Mat? mat2) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    final _$mat1 = mat1?.reference ?? jni$_.jNullReference;
    final _$mat2 = mat2?.reference ?? jni$_.jNullReference;
    _drawDetectedCornersCharuco$1(
      _class.reference.pointer,
      _id_drawDetectedCornersCharuco$1 as jni$_.JMethodIDPtr,
      _$mat.pointer,
      _$mat1.pointer,
      _$mat2.pointer,
    ).check();
  }

  static final _id_drawDetectedCornersCharuco$2 = _class.staticMethodId(
    r'drawDetectedCornersCharuco',
    r'(Lorg/opencv/core/Mat;Lorg/opencv/core/Mat;)V',
  );

  static final _drawDetectedCornersCharuco$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void drawDetectedCornersCharuco(org.opencv.core.Mat mat, org.opencv.core.Mat mat1)`
  static void drawDetectedCornersCharuco$2(Mat? mat, Mat? mat1) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    final _$mat1 = mat1?.reference ?? jni$_.jNullReference;
    _drawDetectedCornersCharuco$2(
      _class.reference.pointer,
      _id_drawDetectedCornersCharuco$2 as jni$_.JMethodIDPtr,
      _$mat.pointer,
      _$mat1.pointer,
    ).check();
  }

  static final _id_drawDetectedDiamonds = _class.staticMethodId(
    r'drawDetectedDiamonds',
    r'(Lorg/opencv/core/Mat;Ljava/util/List;Lorg/opencv/core/Mat;Lorg/opencv/core/Scalar;)V',
  );

  static final _drawDetectedDiamonds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void drawDetectedDiamonds(org.opencv.core.Mat mat, java.util.List<org.opencv.core.Mat> list, org.opencv.core.Mat mat1, org.opencv.core.Scalar scalar)`
  static void drawDetectedDiamonds(
    Mat? mat,
    jni$_.JList<Mat?>? list,
    Mat? mat1,
    jni$_.JObject? scalar,
  ) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$mat1 = mat1?.reference ?? jni$_.jNullReference;
    final _$scalar = scalar?.reference ?? jni$_.jNullReference;
    _drawDetectedDiamonds(
      _class.reference.pointer,
      _id_drawDetectedDiamonds as jni$_.JMethodIDPtr,
      _$mat.pointer,
      _$list.pointer,
      _$mat1.pointer,
      _$scalar.pointer,
    ).check();
  }

  static final _id_drawDetectedDiamonds$1 = _class.staticMethodId(
    r'drawDetectedDiamonds',
    r'(Lorg/opencv/core/Mat;Ljava/util/List;Lorg/opencv/core/Mat;)V',
  );

  static final _drawDetectedDiamonds$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void drawDetectedDiamonds(org.opencv.core.Mat mat, java.util.List<org.opencv.core.Mat> list, org.opencv.core.Mat mat1)`
  static void drawDetectedDiamonds$1(
    Mat? mat,
    jni$_.JList<Mat?>? list,
    Mat? mat1,
  ) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$mat1 = mat1?.reference ?? jni$_.jNullReference;
    _drawDetectedDiamonds$1(
      _class.reference.pointer,
      _id_drawDetectedDiamonds$1 as jni$_.JMethodIDPtr,
      _$mat.pointer,
      _$list.pointer,
      _$mat1.pointer,
    ).check();
  }

  static final _id_drawDetectedDiamonds$2 = _class.staticMethodId(
    r'drawDetectedDiamonds',
    r'(Lorg/opencv/core/Mat;Ljava/util/List;)V',
  );

  static final _drawDetectedDiamonds$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void drawDetectedDiamonds(org.opencv.core.Mat mat, java.util.List<org.opencv.core.Mat> list)`
  static void drawDetectedDiamonds$2(Mat? mat, jni$_.JList<Mat?>? list) {
    final _$mat = mat?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    _drawDetectedDiamonds$2(
      _class.reference.pointer,
      _id_drawDetectedDiamonds$2 as jni$_.JMethodIDPtr,
      _$mat.pointer,
      _$list.pointer,
    ).check();
  }

  static final _id_getPredefinedDictionary = _class.staticMethodId(
    r'getPredefinedDictionary',
    r'(I)Lorg/opencv/objdetect/Dictionary;',
  );

  static final _getPredefinedDictionary =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public org.opencv.objdetect.Dictionary getPredefinedDictionary(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static Dictionary? getPredefinedDictionary(int i) {
    return _getPredefinedDictionary(
      _class.reference.pointer,
      _id_getPredefinedDictionary as jni$_.JMethodIDPtr,
      i,
    ).object<Dictionary?>(const $Dictionary$NullableType());
  }

  static final _id_extendDictionary = _class.staticMethodId(
    r'extendDictionary',
    r'(IILorg/opencv/objdetect/Dictionary;I)Lorg/opencv/objdetect/Dictionary;',
  );

  static final _extendDictionary =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public org.opencv.objdetect.Dictionary extendDictionary(int i, int i1, org.opencv.objdetect.Dictionary dictionary, int i2)`
  /// The returned object must be released after use, by calling the [release] method.
  static Dictionary? extendDictionary(
    int i,
    int i1,
    Dictionary? dictionary,
    int i2,
  ) {
    final _$dictionary = dictionary?.reference ?? jni$_.jNullReference;
    return _extendDictionary(
      _class.reference.pointer,
      _id_extendDictionary as jni$_.JMethodIDPtr,
      i,
      i1,
      _$dictionary.pointer,
      i2,
    ).object<Dictionary?>(const $Dictionary$NullableType());
  }

  static final _id_extendDictionary$1 = _class.staticMethodId(
    r'extendDictionary',
    r'(IILorg/opencv/objdetect/Dictionary;)Lorg/opencv/objdetect/Dictionary;',
  );

  static final _extendDictionary$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Int32, jni$_.Int32, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public org.opencv.objdetect.Dictionary extendDictionary(int i, int i1, org.opencv.objdetect.Dictionary dictionary)`
  /// The returned object must be released after use, by calling the [release] method.
  static Dictionary? extendDictionary$1(int i, int i1, Dictionary? dictionary) {
    final _$dictionary = dictionary?.reference ?? jni$_.jNullReference;
    return _extendDictionary$1(
      _class.reference.pointer,
      _id_extendDictionary$1 as jni$_.JMethodIDPtr,
      i,
      i1,
      _$dictionary.pointer,
    ).object<Dictionary?>(const $Dictionary$NullableType());
  }

  static final _id_extendDictionary$2 = _class.staticMethodId(
    r'extendDictionary',
    r'(II)Lorg/opencv/objdetect/Dictionary;',
  );

  static final _extendDictionary$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `static public org.opencv.objdetect.Dictionary extendDictionary(int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  static Dictionary? extendDictionary$2(int i, int i1) {
    return _extendDictionary$2(
      _class.reference.pointer,
      _id_extendDictionary$2 as jni$_.JMethodIDPtr,
      i,
      i1,
    ).object<Dictionary?>(const $Dictionary$NullableType());
  }
}

final class $Objdetect$NullableType extends jni$_.JObjType<Objdetect?> {
  @jni$_.internal
  const $Objdetect$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/opencv/objdetect/Objdetect;';

  @jni$_.internal
  @core$_.override
  Objdetect? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Objdetect.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Objdetect?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Objdetect$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Objdetect$NullableType) &&
        other is $Objdetect$NullableType;
  }
}

final class $Objdetect$Type extends jni$_.JObjType<Objdetect> {
  @jni$_.internal
  const $Objdetect$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/opencv/objdetect/Objdetect;';

  @jni$_.internal
  @core$_.override
  Objdetect fromReference(jni$_.JReference reference) =>
      Objdetect.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Objdetect?> get nullableType =>
      const $Objdetect$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Objdetect$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Objdetect$Type) && other is $Objdetect$Type;
  }
}
