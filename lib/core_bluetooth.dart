// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;
import 'package:objective_c/objective_c.dart' as objc;

@ffi.Native<
    ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external ffi.Pointer<objc.ObjCObject> _CoreBluetooth_protocolTrampoline_1mbt9g9(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _CoreBluetooth_wrapListenerBlock_18v1jvf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _CoreBluetooth_wrapBlockingBlock_18v1jvf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>)>()
external void _CoreBluetooth_protocolTrampoline_18v1jvf(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _CoreBluetooth_wrapListenerBlock_fjrv01(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _CoreBluetooth_wrapBlockingBlock_fjrv01(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>()
external void _CoreBluetooth_protocolTrampoline_fjrv01(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _CoreBluetooth_wrapListenerBlock_1tz5yf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _CoreBluetooth_wrapBlockingBlock_1tz5yf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>)>()
external void _CoreBluetooth_protocolTrampoline_1tz5yf(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
  ffi.Pointer<objc.ObjCObject> arg3,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _CoreBluetooth_wrapListenerBlock_8jfq1p(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _CoreBluetooth_wrapBlockingBlock_8jfq1p(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>)>()
external void _CoreBluetooth_protocolTrampoline_8jfq1p(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
  ffi.Pointer<objc.ObjCObject> arg3,
  ffi.Pointer<objc.ObjCObject> arg4,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _CoreBluetooth_wrapListenerBlock_o4q9mk(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _CoreBluetooth_wrapBlockingBlock_o4q9mk(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Double,
        ffi.Bool,
        ffi.Pointer<objc.ObjCObject>)>()
external void _CoreBluetooth_protocolTrampoline_o4q9mk(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
  double arg3,
  bool arg4,
  ffi.Pointer<objc.ObjCObject> arg5,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _CoreBluetooth_wrapListenerBlock_5ut4yu(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _CoreBluetooth_wrapBlockingBlock_5ut4yu(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>, ffi.Long, ffi.Pointer<objc.ObjCObject>)>()
external void _CoreBluetooth_protocolTrampoline_5ut4yu(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  int arg2,
  ffi.Pointer<objc.ObjCObject> arg3,
);

final class __CFUUID extends ffi.Opaque {}

enum NSXMLParserExternalEntityResolvingPolicy {
  NSXMLParserResolveExternalEntitiesNever(0),
  NSXMLParserResolveExternalEntitiesNoNetwork(1),
  NSXMLParserResolveExternalEntitiesSameOriginOnly(2),
  NSXMLParserResolveExternalEntitiesAlways(3);

  final int value;
  const NSXMLParserExternalEntityResolvingPolicy(this.value);

  static NSXMLParserExternalEntityResolvingPolicy fromValue(int value) =>
      switch (value) {
        0 => NSXMLParserResolveExternalEntitiesNever,
        1 => NSXMLParserResolveExternalEntitiesNoNetwork,
        2 => NSXMLParserResolveExternalEntitiesSameOriginOnly,
        3 => NSXMLParserResolveExternalEntitiesAlways,
        _ => throw ArgumentError(
            'Unknown value for NSXMLParserExternalEntityResolvingPolicy: $value'),
      };
}

/// WARNING: NSUUID is a stub. To generate bindings for this class, include
/// NSUUID in your config's objc-interfaces list.
///
/// NSUUID
class NSUUID extends objc.NSObject
    implements objc.NSCopying, objc.NSSecureCoding {
  NSUUID._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSUUID',
        iOS: (false, (6, 0, 0)), macOS: (false, (10, 8, 0)));
  }

  /// Constructs a [NSUUID] that points to the same underlying object as [other].
  NSUUID.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSUUID] that wraps the given raw object pointer.
  NSUUID.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _class_CBManager = objc.getClass("CBManager");
late final _sel_isKindOfClass_ = objc.registerName("isKindOfClass:");
final _objc_msgSend_19nvye5 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
typedef instancetype = ffi.Pointer<objc.ObjCObject>;
typedef Dartinstancetype = objc.ObjCObjectBase;
late final _sel_init = objc.registerName("init");
final _objc_msgSend_151sglz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

enum CBManagerState {
  CBManagerStateUnknown(0),
  CBManagerStateResetting(1),
  CBManagerStateUnsupported(2),
  CBManagerStateUnauthorized(3),
  CBManagerStatePoweredOff(4),
  CBManagerStatePoweredOn(5);

  final int value;
  const CBManagerState(this.value);

  static CBManagerState fromValue(int value) => switch (value) {
        0 => CBManagerStateUnknown,
        1 => CBManagerStateResetting,
        2 => CBManagerStateUnsupported,
        3 => CBManagerStateUnauthorized,
        4 => CBManagerStatePoweredOff,
        5 => CBManagerStatePoweredOn,
        _ => throw ArgumentError('Unknown value for CBManagerState: $value'),
      };
}

late final _sel_state = objc.registerName("state");
final _objc_msgSend_adxz8 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

enum CBManagerAuthorization {
  CBManagerAuthorizationNotDetermined(0),
  CBManagerAuthorizationRestricted(1),
  CBManagerAuthorizationDenied(2),
  CBManagerAuthorizationAllowedAlways(3);

  final int value;
  const CBManagerAuthorization(this.value);

  static CBManagerAuthorization fromValue(int value) => switch (value) {
        0 => CBManagerAuthorizationNotDetermined,
        1 => CBManagerAuthorizationRestricted,
        2 => CBManagerAuthorizationDenied,
        3 => CBManagerAuthorizationAllowedAlways,
        _ => throw ArgumentError(
            'Unknown value for CBManagerAuthorization: $value'),
      };
}

late final _sel_authorization = objc.registerName("authorization");
final _objc_msgSend_1pjspfw = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_new = objc.registerName("new");
late final _sel_allocWithZone_ = objc.registerName("allocWithZone:");
final _objc_msgSend_1cwp428 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.NSZone>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.NSZone>)>();
late final _sel_alloc = objc.registerName("alloc");
late final _sel_self = objc.registerName("self");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_objcObjCObject_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_objcObjCObject_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_objcObjCObject_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_objcObjCObject_ffiVoid_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_objcObjCObject_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_objcObjCObject_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_objcObjCObject_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_objcObjCObject_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      fromFunction(objc.ObjCObjectBase Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_objcObjCObject_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0).ref.retainAndAutorelease(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_objcObjCObject_ffiVoid_CallExtension on objc
    .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)> {
  objc.ObjCObjectBase call(ffi.Pointer<ffi.Void> arg0) => objc.ObjCObjectBase(
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0)>>()
          .asFunction<
              ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
      retain: true,
      release: true);
}

late final _sel_retain = objc.registerName("retain");
late final _sel_autorelease = objc.registerName("autorelease");

/// CBManager
class CBManager extends objc.NSObject {
  CBManager._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('CBManager', macOS: (false, (10, 13, 0)));
  }

  /// Constructs a [CBManager] that points to the same underlying object as [other].
  CBManager.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CBManager] that wraps the given raw object pointer.
  CBManager.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CBManager].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_CBManager);
  }

  /// init
  CBManager init() {
    objc.checkOsVersionInternal('CBManager.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return CBManager.castFromPointer(_ret, retain: false, release: true);
  }

  /// state
  CBManagerState get state {
    objc.checkOsVersionInternal('CBManager.state', macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_adxz8(this.ref.pointer, _sel_state);
    return CBManagerState.fromValue(_ret);
  }

  /// authorization
  CBManagerAuthorization get authorization {
    objc.checkOsVersionInternal('CBManager.authorization',
        iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_1pjspfw(this.ref.pointer, _sel_authorization);
    return CBManagerAuthorization.fromValue(_ret);
  }

  /// authorization
  static CBManagerAuthorization getAuthorization$1() {
    objc.checkOsVersionInternal('CBManager.authorization',
        iOS: (false, (13, 1, 0)), macOS: (false, (10, 15, 0)));
    final _ret = _objc_msgSend_1pjspfw(_class_CBManager, _sel_authorization);
    return CBManagerAuthorization.fromValue(_ret);
  }

  /// new
  static CBManager new$() {
    final _ret = _objc_msgSend_151sglz(_class_CBManager, _sel_new);
    return CBManager.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static CBManager allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_CBManager, _sel_allocWithZone_, zone);
    return CBManager.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static CBManager alloc() {
    final _ret = _objc_msgSend_151sglz(_class_CBManager, _sel_alloc);
    return CBManager.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  CBManager self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return CBManager.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  CBManager retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return CBManager.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  CBManager autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return CBManager.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of CBManager constructed with the default `new` method.
  factory CBManager() => new$();
}

enum CBConnectionEvent {
  CBConnectionEventPeerDisconnected(0),
  CBConnectionEventPeerConnected(1);

  final int value;
  const CBConnectionEvent(this.value);

  static CBConnectionEvent fromValue(int value) => switch (value) {
        0 => CBConnectionEventPeerDisconnected,
        1 => CBConnectionEventPeerConnected,
        _ => throw ArgumentError('Unknown value for CBConnectionEvent: $value'),
      };
}

enum CBCentralManagerFeature {
  CBCentralManagerFeatureExtendedScanAndConnect(1);

  final int value;
  const CBCentralManagerFeature(this.value);

  static CBCentralManagerFeature fromValue(int value) => switch (value) {
        1 => CBCentralManagerFeatureExtendedScanAndConnect,
        _ => throw ArgumentError(
            'Unknown value for CBCentralManagerFeature: $value'),
      };
}

late final _class_CBCentralManager = objc.getClass("CBCentralManager");
late final _protocol_CBCentralManagerDelegate =
    objc.getProtocol("CBCentralManagerDelegate");
late final _sel_conformsToProtocol_ = objc.registerName("conformsToProtocol:");
final _objc_msgSend_e3qsqz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCProtocol>)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCProtocol>)>();
late final _sel_centralManagerDidUpdateState_ =
    objc.registerName("centralManagerDidUpdateState:");
void _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CBCentralManager {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  CBCentralManager)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, CBCentralManager) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, CBCentralManager.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager)>
      listener(void Function(ffi.Pointer<ffi.Void>, CBCentralManager) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            CBCentralManager.castFromPointer(arg1,
                retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _CoreBluetooth_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager)>
      blocking(void Function(ffi.Pointer<ffi.Void>, CBCentralManager) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            CBCentralManager.castFromPointer(arg1,
                retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            CBCentralManager.castFromPointer(arg1,
                retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _CoreBluetooth_wrapBlockingBlock_18v1jvf(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CallExtension on objc
    .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager)> {
  void call(ffi.Pointer<ffi.Void> arg0, CBCentralManager arg1) => ref
          .pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>()
          .asFunction<
              void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
      ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_centralManager_willRestoreState_ =
    objc.registerName("centralManager:willRestoreState:");
void _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_NSDictionary_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_NSDictionary_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_NSDictionary_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_NSDictionary_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_NSDictionary_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_NSDictionary_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_NSDictionary_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_NSDictionary_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_NSDictionary_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_NSDictionary_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_NSDictionary_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_NSDictionary_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_NSDictionary_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_NSDictionary_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, objc.NSDictionary)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_NSDictionary {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, CBCentralManager, objc.NSDictionary)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager,
                      objc.NSDictionary)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, objc.NSDictionary)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager,
                      objc.NSDictionary)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_NSDictionary_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, objc.NSDictionary)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, CBCentralManager, objc.NSDictionary) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, objc.NSDictionary)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_NSDictionary_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                      arg0,
                      CBCentralManager.castFromPointer(arg1, retain: true, release: true),
                      objc.NSDictionary.castFromPointer(arg2, retain: true, release: true)),
                  keepIsolateAlive),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>, CBCentralManager, objc.NSDictionary)> listener(
      void Function(ffi.Pointer<ffi.Void>, CBCentralManager, objc.NSDictionary)
          fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_NSDictionary_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                CBCentralManager.castFromPointer(arg1,
                    retain: false, release: true),
                objc.NSDictionary.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _CoreBluetooth_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager,
            objc.NSDictionary)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>, CBCentralManager, objc.NSDictionary)> blocking(
      void Function(ffi.Pointer<ffi.Void>, CBCentralManager, objc.NSDictionary)
          fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_NSDictionary_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                CBCentralManager.castFromPointer(arg1,
                    retain: false, release: true),
                objc.NSDictionary.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_NSDictionary_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                CBCentralManager.castFromPointer(arg1,
                    retain: false, release: true),
                objc.NSDictionary.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _CoreBluetooth_wrapBlockingBlock_fjrv01(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager,
            objc.NSDictionary)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, objc.NSDictionary)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_NSDictionary_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>, CBCentralManager, objc.NSDictionary)> {
  void call(ffi.Pointer<ffi.Void> arg0, CBCentralManager arg1,
          objc.NSDictionary arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _class_CBPeer = objc.getClass("CBPeer");
late final _sel_identifier = objc.registerName("identifier");

/// CBPeer
class CBPeer extends objc.NSObject implements objc.NSCopying {
  CBPeer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('CBPeer', macOS: (false, (10, 13, 0)));
  }

  /// Constructs a [CBPeer] that points to the same underlying object as [other].
  CBPeer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CBPeer] that wraps the given raw object pointer.
  CBPeer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CBPeer].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_CBPeer);
  }

  /// init
  CBPeer init() {
    objc.checkOsVersionInternal('CBPeer.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return CBPeer.castFromPointer(_ret, retain: false, release: true);
  }

  /// identifier
  NSUUID get identifier {
    objc.checkOsVersionInternal('CBPeer.identifier',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_identifier);
    return NSUUID.castFromPointer(_ret, retain: true, release: true);
  }

  /// new
  static CBPeer new$() {
    final _ret = _objc_msgSend_151sglz(_class_CBPeer, _sel_new);
    return CBPeer.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static CBPeer allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_CBPeer, _sel_allocWithZone_, zone);
    return CBPeer.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static CBPeer alloc() {
    final _ret = _objc_msgSend_151sglz(_class_CBPeer, _sel_alloc);
    return CBPeer.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  CBPeer self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return CBPeer.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  CBPeer retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return CBPeer.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  CBPeer autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return CBPeer.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of CBPeer constructed with the default `new` method.
  factory CBPeer() => new$();
}

late final _class_CBPeripheral = objc.getClass("CBPeripheral");
late final _protocol_CBPeripheralDelegate =
    objc.getProtocol("CBPeripheralDelegate");
late final _sel_peripheralDidUpdateName_ =
    objc.registerName("peripheralDidUpdateName:");
void _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CBPeripheral {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  CBPeripheral)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral)>(
              objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, CBPeripheral) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, CBPeripheral.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral)>
      listener(void Function(ffi.Pointer<ffi.Void>, CBPeripheral) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_listenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            CBPeripheral.castFromPointer(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _CoreBluetooth_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral)>
      blocking(void Function(ffi.Pointer<ffi.Void>, CBPeripheral) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_blockingCallable.nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            CBPeripheral.castFromPointer(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            CBPeripheral.castFromPointer(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _CoreBluetooth_wrapBlockingBlock_18v1jvf(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral)> {
  void call(ffi.Pointer<ffi.Void> arg0, CBPeripheral arg1) => ref
          .pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>()
          .asFunction<
              void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
      ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_peripheral_didModifyServices_ =
    objc.registerName("peripheral:didModifyServices:");
void _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSArray_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSArray_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSArray_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSArray_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSArray_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSArray_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSArray_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSArray_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSArray_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSArray_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSArray_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSArray_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSArray_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSArray_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSArray)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSArray)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral,
                  objc.NSArray)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSArray)>
      fromFunctionPointer(
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSArray)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSArray_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSArray)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSArray) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSArray)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSArray_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                  arg0,
                  CBPeripheral.castFromPointer(arg1, retain: true, release: true),
                  objc.NSArray.castFromPointer(arg2, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSArray)>
      listener(
          void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSArray) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSArray_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                CBPeripheral.castFromPointer(arg1,
                    retain: false, release: true),
                objc.NSArray.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _CoreBluetooth_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral,
            objc.NSArray)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSArray)>
      blocking(
          void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSArray) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSArray_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                CBPeripheral.castFromPointer(arg1,
                    retain: false, release: true),
                objc.NSArray.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSArray_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                CBPeripheral.castFromPointer(arg1,
                    retain: false, release: true),
                objc.NSArray.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _CoreBluetooth_wrapBlockingBlock_fjrv01(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral,
            objc.NSArray)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSArray)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSArray_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSArray)> {
  void call(ffi.Pointer<ffi.Void> arg0, CBPeripheral arg1, objc.NSArray arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_peripheralDidUpdateRSSI_error_ =
    objc.registerName("peripheralDidUpdateRSSI:error:");
void _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSError?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral,
                  objc.NSError?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSError?)>
      fromFunctionPointer(
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSError?)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSError?)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSError?) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSError?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                  arg0,
                  CBPeripheral.castFromPointer(arg1, retain: true, release: true),
                  arg2.address == 0 ? null : objc.NSError.castFromPointer(arg2, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSError?)>
      listener(
          void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSError?) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                CBPeripheral.castFromPointer(arg1,
                    retain: false, release: true),
                arg2.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg2,
                        retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _CoreBluetooth_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral,
            objc.NSError?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSError?)>
      blocking(
          void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSError?) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                CBPeripheral.castFromPointer(arg1,
                    retain: false, release: true),
                arg2.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg2,
                        retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                CBPeripheral.castFromPointer(arg1,
                    retain: false, release: true),
                arg2.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg2,
                        retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _CoreBluetooth_wrapBlockingBlock_fjrv01(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral,
            objc.NSError?)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSError?)> {
  void call(
          ffi.Pointer<ffi.Void> arg0, CBPeripheral arg1, objc.NSError? arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0,
          arg1.ref.pointer, arg2?.ref.pointer ?? ffi.nullptr);
}

late final _sel_peripheral_didReadRSSI_error_ =
    objc.registerName("peripheral:didReadRSSI:error:");
void _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSNumber_NSError_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2,
                    ffi.Pointer<objc.ObjCObject> arg3)>>()
        .asFunction<
            void Function(
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSNumber_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSNumber_NSError_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSNumber_NSError_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSNumber_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSNumber_NSError_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSNumber_NSError_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSNumber_NSError_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSNumber_NSError_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSNumber_NSError_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSNumber_NSError_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSNumber_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSNumber_NSError_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSNumber_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSNumber, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSNumber_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSNumber,
              objc.NSError?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  CBPeripheral,
                  objc.NSNumber,
                  objc.NSError?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSNumber, objc.NSError?)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral,
                      objc.NSNumber, objc.NSError?)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSNumber_NSError_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSNumber, objc.NSError?)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSNumber, objc.NSError?) fn, {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSNumber, objc.NSError?)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSNumber_NSError_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3) => fn(
                      arg0,
                      CBPeripheral.castFromPointer(arg1, retain: true, release: true),
                      objc.NSNumber.castFromPointer(arg2, retain: true, release: true),
                      arg3.address == 0 ? null : objc.NSError.castFromPointer(arg3, retain: true, release: true)),
                  keepIsolateAlive),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSNumber,
          objc.NSError?)> listener(
      void Function(
              ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSNumber, objc.NSError?)
          fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSNumber_NSError_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                CBPeripheral.castFromPointer(arg1,
                    retain: false, release: true),
                objc.NSNumber.castFromPointer(arg2,
                    retain: false, release: true),
                arg3.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg3,
                        retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _CoreBluetooth_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSNumber,
            objc.NSError?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSNumber,
          objc.NSError?)> blocking(
      void Function(
              ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSNumber, objc.NSError?)
          fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSNumber_NSError_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                CBPeripheral.castFromPointer(arg1,
                    retain: false, release: true),
                objc.NSNumber.castFromPointer(arg2,
                    retain: false, release: true),
                arg3.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg3,
                        retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSNumber_NSError_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                CBPeripheral.castFromPointer(arg1,
                    retain: false, release: true),
                objc.NSNumber.castFromPointer(arg2,
                    retain: false, release: true),
                arg3.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg3,
                        retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _CoreBluetooth_wrapBlockingBlock_1tz5yf(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSNumber,
            objc.NSError?)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSNumber, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSNumber_NSError_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSNumber,
            objc.NSError?)> {
  void call(ffi.Pointer<ffi.Void> arg0, CBPeripheral arg1, objc.NSNumber arg2,
          objc.NSError? arg3) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<objc.ObjCObject> arg3)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0,
          arg1.ref.pointer, arg2.ref.pointer, arg3?.ref.pointer ?? ffi.nullptr);
}

late final _sel_peripheral_didDiscoverServices_ =
    objc.registerName("peripheral:didDiscoverServices:");
late final _class_CBAttribute = objc.getClass("CBAttribute");
late final _class_CBUUID = objc.getClass("CBUUID");
late final _sel_data = objc.registerName("data");
late final _sel_UUIDString = objc.registerName("UUIDString");
late final _sel_UUIDWithString_ = objc.registerName("UUIDWithString:");
final _objc_msgSend_1sotr3r = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_UUIDWithData_ = objc.registerName("UUIDWithData:");
late final _sel_UUIDWithCFUUID_ = objc.registerName("UUIDWithCFUUID:");
final _objc_msgSend_13euv58 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<__CFUUID>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<__CFUUID>)>();
late final _sel_UUIDWithNSUUID_ = objc.registerName("UUIDWithNSUUID:");

/// CBUUID
class CBUUID extends objc.NSObject implements objc.NSCopying {
  CBUUID._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('CBUUID', macOS: (false, (10, 7, 0)));
  }

  /// Constructs a [CBUUID] that points to the same underlying object as [other].
  CBUUID.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CBUUID] that wraps the given raw object pointer.
  CBUUID.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CBUUID].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_CBUUID);
  }

  /// data
  objc.NSData get data {
    objc.checkOsVersionInternal('CBUUID.data', macOS: (false, (10, 7, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_data);
    return objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// UUIDString
  objc.NSString get UUIDString {
    objc.checkOsVersionInternal('CBUUID.UUIDString',
        macOS: (false, (10, 10, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_UUIDString);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// UUIDWithString:
  static CBUUID UUIDWithString(objc.NSString theString) {
    objc.checkOsVersionInternal('CBUUID.UUIDWithString:',
        macOS: (false, (10, 7, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_CBUUID, _sel_UUIDWithString_, theString.ref.pointer);
    return CBUUID.castFromPointer(_ret, retain: true, release: true);
  }

  /// UUIDWithData:
  static CBUUID UUIDWithData(objc.NSData theData) {
    objc.checkOsVersionInternal('CBUUID.UUIDWithData:',
        macOS: (false, (10, 7, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_CBUUID, _sel_UUIDWithData_, theData.ref.pointer);
    return CBUUID.castFromPointer(_ret, retain: true, release: true);
  }

  /// UUIDWithCFUUID:
  static CBUUID UUIDWithCFUUID(ffi.Pointer<__CFUUID> theUUID) {
    objc.checkOsVersionInternal('CBUUID.UUIDWithCFUUID:',
        macOS: (false, (10, 7, 0)));
    final _ret =
        _objc_msgSend_13euv58(_class_CBUUID, _sel_UUIDWithCFUUID_, theUUID);
    return CBUUID.castFromPointer(_ret, retain: true, release: true);
  }

  /// UUIDWithNSUUID:
  static CBUUID UUIDWithNSUUID(NSUUID theUUID) {
    objc.checkOsVersionInternal('CBUUID.UUIDWithNSUUID:',
        macOS: (false, (10, 9, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_CBUUID, _sel_UUIDWithNSUUID_, theUUID.ref.pointer);
    return CBUUID.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  CBUUID init() {
    objc.checkOsVersionInternal('CBUUID.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return CBUUID.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static CBUUID new$() {
    final _ret = _objc_msgSend_151sglz(_class_CBUUID, _sel_new);
    return CBUUID.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static CBUUID allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_CBUUID, _sel_allocWithZone_, zone);
    return CBUUID.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static CBUUID alloc() {
    final _ret = _objc_msgSend_151sglz(_class_CBUUID, _sel_alloc);
    return CBUUID.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  CBUUID self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return CBUUID.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  CBUUID retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return CBUUID.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  CBUUID autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return CBUUID.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of CBUUID constructed with the default `new` method.
  factory CBUUID() => new$();
}

late final _sel_UUID = objc.registerName("UUID");

/// CBAttribute
class CBAttribute extends objc.NSObject {
  CBAttribute._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('CBAttribute', macOS: (false, (10, 13, 0)));
  }

  /// Constructs a [CBAttribute] that points to the same underlying object as [other].
  CBAttribute.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CBAttribute] that wraps the given raw object pointer.
  CBAttribute.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CBAttribute].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_CBAttribute);
  }

  /// init
  CBAttribute init() {
    objc.checkOsVersionInternal('CBAttribute.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return CBAttribute.castFromPointer(_ret, retain: false, release: true);
  }

  /// UUID
  CBUUID get UUID {
    objc.checkOsVersionInternal('CBAttribute.UUID',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_UUID);
    return CBUUID.castFromPointer(_ret, retain: true, release: true);
  }

  /// new
  static CBAttribute new$() {
    final _ret = _objc_msgSend_151sglz(_class_CBAttribute, _sel_new);
    return CBAttribute.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static CBAttribute allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_CBAttribute, _sel_allocWithZone_, zone);
    return CBAttribute.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static CBAttribute alloc() {
    final _ret = _objc_msgSend_151sglz(_class_CBAttribute, _sel_alloc);
    return CBAttribute.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  CBAttribute self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return CBAttribute.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  CBAttribute retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return CBAttribute.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  CBAttribute autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return CBAttribute.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of CBAttribute constructed with the default `new` method.
  factory CBAttribute() => new$();
}

late final _class_CBService = objc.getClass("CBService");
late final _sel_peripheral = objc.registerName("peripheral");
late final _sel_isPrimary = objc.registerName("isPrimary");
final _objc_msgSend_91o635 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_includedServices = objc.registerName("includedServices");
late final _sel_characteristics = objc.registerName("characteristics");

/// CBService
class CBService extends CBAttribute {
  CBService._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('CBService', macOS: (false, (10, 7, 0)));
  }

  /// Constructs a [CBService] that points to the same underlying object as [other].
  CBService.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CBService] that wraps the given raw object pointer.
  CBService.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CBService].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_CBService);
  }

  /// peripheral
  CBPeripheral? get peripheral {
    objc.checkOsVersionInternal('CBService.peripheral',
        macOS: (false, (10, 7, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_peripheral);
    return _ret.address == 0
        ? null
        : CBPeripheral.castFromPointer(_ret, retain: true, release: true);
  }

  /// isPrimary
  bool get isPrimary {
    objc.checkOsVersionInternal('CBService.isPrimary',
        macOS: (false, (10, 7, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isPrimary);
  }

  /// includedServices
  objc.NSArray? get includedServices {
    objc.checkOsVersionInternal('CBService.includedServices',
        macOS: (false, (10, 7, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_includedServices);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// characteristics
  objc.NSArray? get characteristics {
    objc.checkOsVersionInternal('CBService.characteristics',
        macOS: (false, (10, 7, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_characteristics);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  CBService init() {
    objc.checkOsVersionInternal('CBService.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return CBService.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static CBService new$() {
    final _ret = _objc_msgSend_151sglz(_class_CBService, _sel_new);
    return CBService.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static CBService allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_CBService, _sel_allocWithZone_, zone);
    return CBService.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static CBService alloc() {
    final _ret = _objc_msgSend_151sglz(_class_CBService, _sel_alloc);
    return CBService.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  CBService self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return CBService.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  CBService retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return CBService.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  CBService autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return CBService.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of CBService constructed with the default `new` method.
  factory CBService() => new$();
}

late final _sel_peripheral_didDiscoverIncludedServicesForService_error_ = objc
    .registerName("peripheral:didDiscoverIncludedServicesForService:error:");
void _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2,
                    ffi.Pointer<objc.ObjCObject> arg3)>>()
        .asFunction<
            void Function(
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBService, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, CBPeripheral, CBService, objc.NSError?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBService,
                  objc.NSError?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBService, objc.NSError?)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, CBPeripheral, CBService, objc.NSError?)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBService, objc.NSError?)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBService, objc.NSError?) fn, {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBService, objc.NSError?)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3) => fn(
                      arg0,
                      CBPeripheral.castFromPointer(arg1, retain: true, release: true),
                      CBService.castFromPointer(arg2, retain: true, release: true),
                      arg3.address == 0 ? null : objc.NSError.castFromPointer(arg3, retain: true, release: true)),
                  keepIsolateAlive),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, CBPeripheral, CBService, objc.NSError?)>
      listener(
          void Function(
                  ffi.Pointer<ffi.Void>, CBPeripheral, CBService, objc.NSError?)
              fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                CBPeripheral.castFromPointer(arg1,
                    retain: false, release: true),
                CBService.castFromPointer(arg2, retain: false, release: true),
                arg3.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg3,
                        retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _CoreBluetooth_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBService,
            objc.NSError?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, CBPeripheral, CBService, objc.NSError?)>
      blocking(
          void Function(
                  ffi.Pointer<ffi.Void>, CBPeripheral, CBService, objc.NSError?)
              fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                CBPeripheral.castFromPointer(arg1,
                    retain: false, release: true),
                CBService.castFromPointer(arg2, retain: false, release: true),
                arg3.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg3,
                        retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                CBPeripheral.castFromPointer(arg1,
                    retain: false, release: true),
                CBService.castFromPointer(arg2, retain: false, release: true),
                arg3.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg3,
                        retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _CoreBluetooth_wrapBlockingBlock_1tz5yf(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBService,
            objc.NSError?)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBService, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>, CBPeripheral, CBService, objc.NSError?)> {
  void call(ffi.Pointer<ffi.Void> arg0, CBPeripheral arg1, CBService arg2,
          objc.NSError? arg3) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<objc.ObjCObject> arg3)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0,
          arg1.ref.pointer, arg2.ref.pointer, arg3?.ref.pointer ?? ffi.nullptr);
}

late final _sel_peripheral_didDiscoverCharacteristicsForService_error_ =
    objc.registerName("peripheral:didDiscoverCharacteristicsForService:error:");
late final _class_CBCharacteristic = objc.getClass("CBCharacteristic");
late final _sel_service = objc.registerName("service");

enum CBCharacteristicProperties {
  CBCharacteristicPropertyBroadcast(1),
  CBCharacteristicPropertyRead(2),
  CBCharacteristicPropertyWriteWithoutResponse(4),
  CBCharacteristicPropertyWrite(8),
  CBCharacteristicPropertyNotify(16),
  CBCharacteristicPropertyIndicate(32),
  CBCharacteristicPropertyAuthenticatedSignedWrites(64),
  CBCharacteristicPropertyExtendedProperties(128),
  CBCharacteristicPropertyNotifyEncryptionRequired(256),
  CBCharacteristicPropertyIndicateEncryptionRequired(512);

  final int value;
  const CBCharacteristicProperties(this.value);

  static CBCharacteristicProperties fromValue(int value) => switch (value) {
        1 => CBCharacteristicPropertyBroadcast,
        2 => CBCharacteristicPropertyRead,
        4 => CBCharacteristicPropertyWriteWithoutResponse,
        8 => CBCharacteristicPropertyWrite,
        16 => CBCharacteristicPropertyNotify,
        32 => CBCharacteristicPropertyIndicate,
        64 => CBCharacteristicPropertyAuthenticatedSignedWrites,
        128 => CBCharacteristicPropertyExtendedProperties,
        256 => CBCharacteristicPropertyNotifyEncryptionRequired,
        512 => CBCharacteristicPropertyIndicateEncryptionRequired,
        _ => throw ArgumentError(
            'Unknown value for CBCharacteristicProperties: $value'),
      };
}

late final _sel_properties = objc.registerName("properties");
final _objc_msgSend_1f77v0o = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_value = objc.registerName("value");
late final _sel_descriptors = objc.registerName("descriptors");
late final _sel_isBroadcasted = objc.registerName("isBroadcasted");
late final _sel_isNotifying = objc.registerName("isNotifying");

/// CBCharacteristic
class CBCharacteristic extends CBAttribute {
  CBCharacteristic._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('CBCharacteristic', macOS: (false, (10, 7, 0)));
  }

  /// Constructs a [CBCharacteristic] that points to the same underlying object as [other].
  CBCharacteristic.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CBCharacteristic] that wraps the given raw object pointer.
  CBCharacteristic.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CBCharacteristic].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_CBCharacteristic);
  }

  /// service
  CBService? get service {
    objc.checkOsVersionInternal('CBCharacteristic.service',
        macOS: (false, (10, 7, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_service);
    return _ret.address == 0
        ? null
        : CBService.castFromPointer(_ret, retain: true, release: true);
  }

  /// properties
  CBCharacteristicProperties get properties {
    objc.checkOsVersionInternal('CBCharacteristic.properties',
        macOS: (false, (10, 7, 0)));
    final _ret = _objc_msgSend_1f77v0o(this.ref.pointer, _sel_properties);
    return CBCharacteristicProperties.fromValue(_ret);
  }

  /// value
  objc.NSData? get value {
    objc.checkOsVersionInternal('CBCharacteristic.value',
        macOS: (false, (10, 7, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_value);
    return _ret.address == 0
        ? null
        : objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// descriptors
  objc.NSArray? get descriptors {
    objc.checkOsVersionInternal('CBCharacteristic.descriptors',
        macOS: (false, (10, 7, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_descriptors);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// isBroadcasted
  bool get isBroadcasted {
    objc.checkOsVersionInternal('CBCharacteristic.isBroadcasted',
        macOS: (false, (10, 9, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isBroadcasted);
  }

  /// isNotifying
  bool get isNotifying {
    objc.checkOsVersionInternal('CBCharacteristic.isNotifying',
        macOS: (false, (10, 7, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isNotifying);
  }

  /// init
  CBCharacteristic init() {
    objc.checkOsVersionInternal('CBCharacteristic.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return CBCharacteristic.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static CBCharacteristic new$() {
    final _ret = _objc_msgSend_151sglz(_class_CBCharacteristic, _sel_new);
    return CBCharacteristic.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static CBCharacteristic allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_CBCharacteristic, _sel_allocWithZone_, zone);
    return CBCharacteristic.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static CBCharacteristic alloc() {
    final _ret = _objc_msgSend_151sglz(_class_CBCharacteristic, _sel_alloc);
    return CBCharacteristic.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  CBCharacteristic self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return CBCharacteristic.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  CBCharacteristic retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return CBCharacteristic.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  CBCharacteristic autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return CBCharacteristic.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of CBCharacteristic constructed with the default `new` method.
  factory CBCharacteristic() => new$();
}

late final _sel_peripheral_didUpdateValueForCharacteristic_error_ =
    objc.registerName("peripheral:didUpdateValueForCharacteristic:error:");
void
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2,
                        ffi.Pointer<objc.ObjCObject> arg3)>>()
            .asFunction<
                void Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBCharacteristic, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral,
              CBCharacteristic, objc.NSError?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  CBPeripheral,
                  CBCharacteristic,
                  objc.NSError?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral,
              CBCharacteristic, objc.NSError?)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral,
                      CBCharacteristic, objc.NSError?)>(
              objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBCharacteristic, objc.NSError?)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBCharacteristic, objc.NSError?) fn, {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBCharacteristic, objc.NSError?)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3) => fn(
                      arg0,
                      CBPeripheral.castFromPointer(arg1, retain: true, release: true),
                      CBCharacteristic.castFromPointer(arg2, retain: true, release: true),
                      arg3.address == 0 ? null : objc.NSError.castFromPointer(arg3, retain: true, release: true)),
                  keepIsolateAlive),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBCharacteristic,
          objc.NSError?)> listener(
      void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBCharacteristic,
              objc.NSError?)
          fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                CBPeripheral.castFromPointer(arg1,
                    retain: false, release: true),
                CBCharacteristic.castFromPointer(arg2,
                    retain: false, release: true),
                arg3.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg3,
                        retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _CoreBluetooth_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBCharacteristic,
            objc.NSError?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBCharacteristic,
          objc.NSError?)> blocking(
      void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBCharacteristic,
              objc.NSError?)
          fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                CBPeripheral.castFromPointer(arg1,
                    retain: false, release: true),
                CBCharacteristic.castFromPointer(arg2,
                    retain: false, release: true),
                arg3.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg3,
                        retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                CBPeripheral.castFromPointer(arg1,
                    retain: false, release: true),
                CBCharacteristic.castFromPointer(arg2,
                    retain: false, release: true),
                arg3.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg3,
                        retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _CoreBluetooth_wrapBlockingBlock_1tz5yf(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBCharacteristic,
            objc.NSError?)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBCharacteristic, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBCharacteristic,
            objc.NSError?)> {
  void call(ffi.Pointer<ffi.Void> arg0, CBPeripheral arg1,
          CBCharacteristic arg2, objc.NSError? arg3) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<objc.ObjCObject> arg3)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0,
          arg1.ref.pointer, arg2.ref.pointer, arg3?.ref.pointer ?? ffi.nullptr);
}

late final _sel_peripheral_didWriteValueForCharacteristic_error_ =
    objc.registerName("peripheral:didWriteValueForCharacteristic:error:");
late final _sel_peripheral_didUpdateNotificationStateForCharacteristic_error_ =
    objc.registerName(
        "peripheral:didUpdateNotificationStateForCharacteristic:error:");
late final _sel_peripheral_didDiscoverDescriptorsForCharacteristic_error_ = objc
    .registerName("peripheral:didDiscoverDescriptorsForCharacteristic:error:");
late final _class_CBDescriptor = objc.getClass("CBDescriptor");
late final _sel_characteristic = objc.registerName("characteristic");

/// CBDescriptor
class CBDescriptor extends CBAttribute {
  CBDescriptor._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('CBDescriptor', macOS: (false, (10, 7, 0)));
  }

  /// Constructs a [CBDescriptor] that points to the same underlying object as [other].
  CBDescriptor.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CBDescriptor] that wraps the given raw object pointer.
  CBDescriptor.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CBDescriptor].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_CBDescriptor);
  }

  /// characteristic
  CBCharacteristic? get characteristic {
    objc.checkOsVersionInternal('CBDescriptor.characteristic',
        macOS: (false, (10, 7, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_characteristic);
    return _ret.address == 0
        ? null
        : CBCharacteristic.castFromPointer(_ret, retain: true, release: true);
  }

  /// value
  objc.ObjCObjectBase? get value {
    objc.checkOsVersionInternal('CBDescriptor.value',
        macOS: (false, (10, 7, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_value);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// init
  CBDescriptor init() {
    objc.checkOsVersionInternal('CBDescriptor.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return CBDescriptor.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static CBDescriptor new$() {
    final _ret = _objc_msgSend_151sglz(_class_CBDescriptor, _sel_new);
    return CBDescriptor.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static CBDescriptor allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_CBDescriptor, _sel_allocWithZone_, zone);
    return CBDescriptor.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static CBDescriptor alloc() {
    final _ret = _objc_msgSend_151sglz(_class_CBDescriptor, _sel_alloc);
    return CBDescriptor.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  CBDescriptor self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return CBDescriptor.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  CBDescriptor retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return CBDescriptor.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  CBDescriptor autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return CBDescriptor.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of CBDescriptor constructed with the default `new` method.
  factory CBDescriptor() => new$();
}

late final _sel_peripheral_didUpdateValueForDescriptor_error_ =
    objc.registerName("peripheral:didUpdateValueForDescriptor:error:");
void
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2,
                        ffi.Pointer<objc.ObjCObject> arg3)>>()
            .asFunction<
                void Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBDescriptor, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, CBPeripheral, CBDescriptor, objc.NSError?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  CBPeripheral,
                  CBDescriptor,
                  objc.NSError?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBDescriptor, objc.NSError?)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral,
                      CBDescriptor, objc.NSError?)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBDescriptor, objc.NSError?)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBDescriptor, objc.NSError?) fn, {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBDescriptor, objc.NSError?)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3) => fn(
                      arg0,
                      CBPeripheral.castFromPointer(arg1, retain: true, release: true),
                      CBDescriptor.castFromPointer(arg2, retain: true, release: true),
                      arg3.address == 0 ? null : objc.NSError.castFromPointer(arg3, retain: true, release: true)),
                  keepIsolateAlive),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBDescriptor,
          objc.NSError?)> listener(
      void Function(
              ffi.Pointer<ffi.Void>, CBPeripheral, CBDescriptor, objc.NSError?)
          fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                CBPeripheral.castFromPointer(arg1,
                    retain: false, release: true),
                CBDescriptor.castFromPointer(arg2,
                    retain: false, release: true),
                arg3.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg3,
                        retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _CoreBluetooth_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBDescriptor,
            objc.NSError?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBDescriptor,
          objc.NSError?)> blocking(
      void Function(
              ffi.Pointer<ffi.Void>, CBPeripheral, CBDescriptor, objc.NSError?)
          fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                CBPeripheral.castFromPointer(arg1,
                    retain: false, release: true),
                CBDescriptor.castFromPointer(arg2,
                    retain: false, release: true),
                arg3.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg3,
                        retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                CBPeripheral.castFromPointer(arg1,
                    retain: false, release: true),
                CBDescriptor.castFromPointer(arg2,
                    retain: false, release: true),
                arg3.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg3,
                        retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _CoreBluetooth_wrapBlockingBlock_1tz5yf(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBDescriptor,
            objc.NSError?)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBDescriptor, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>, CBPeripheral, CBDescriptor, objc.NSError?)> {
  void call(ffi.Pointer<ffi.Void> arg0, CBPeripheral arg1, CBDescriptor arg2,
          objc.NSError? arg3) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<objc.ObjCObject> arg3)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0,
          arg1.ref.pointer, arg2.ref.pointer, arg3?.ref.pointer ?? ffi.nullptr);
}

late final _sel_peripheral_didWriteValueForDescriptor_error_ =
    objc.registerName("peripheral:didWriteValueForDescriptor:error:");
late final _sel_peripheralIsReadyToSendWriteWithoutResponse_ =
    objc.registerName("peripheralIsReadyToSendWriteWithoutResponse:");

/// WARNING: CBL2CAPChannel is a stub. To generate bindings for this class, include
/// CBL2CAPChannel in your config's objc-interfaces list.
///
/// CBL2CAPChannel
class CBL2CAPChannel extends objc.NSObject {
  CBL2CAPChannel._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('CBL2CAPChannel', macOS: (false, (10, 13, 0)));
  }

  /// Constructs a [CBL2CAPChannel] that points to the same underlying object as [other].
  CBL2CAPChannel.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CBL2CAPChannel] that wraps the given raw object pointer.
  CBL2CAPChannel.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_peripheral_didOpenL2CAPChannel_error_ =
    objc.registerName("peripheral:didOpenL2CAPChannel:error:");
void
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBL2CAPChannel_NSError_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2,
                        ffi.Pointer<objc.ObjCObject> arg3)>>()
            .asFunction<
                void Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBL2CAPChannel_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBL2CAPChannel_NSError_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBL2CAPChannel_NSError_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBL2CAPChannel_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBL2CAPChannel_NSError_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBL2CAPChannel_NSError_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBL2CAPChannel_NSError_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBL2CAPChannel_NSError_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBL2CAPChannel_NSError_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBL2CAPChannel_NSError_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBL2CAPChannel_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBL2CAPChannel_NSError_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBL2CAPChannel_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBL2CAPChannel?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBL2CAPChannel_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral,
              CBL2CAPChannel?, objc.NSError?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  CBPeripheral,
                  CBL2CAPChannel?,
                  objc.NSError?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral,
              CBL2CAPChannel?, objc.NSError?)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral,
                      CBL2CAPChannel?, objc.NSError?)>(
              objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBL2CAPChannel_NSError_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBL2CAPChannel?, objc.NSError?)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBL2CAPChannel?, objc.NSError?) fn, {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBL2CAPChannel?, objc.NSError?)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBL2CAPChannel_NSError_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3) => fn(
                      arg0,
                      CBPeripheral.castFromPointer(arg1, retain: true, release: true),
                      arg2.address == 0 ? null : CBL2CAPChannel.castFromPointer(arg2, retain: true, release: true),
                      arg3.address == 0 ? null : objc.NSError.castFromPointer(arg3, retain: true, release: true)),
                  keepIsolateAlive),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBL2CAPChannel?,
          objc.NSError?)> listener(
      void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBL2CAPChannel?,
              objc.NSError?)
          fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBL2CAPChannel_NSError_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                CBPeripheral.castFromPointer(arg1,
                    retain: false, release: true),
                arg2.address == 0
                    ? null
                    : CBL2CAPChannel.castFromPointer(arg2,
                        retain: false, release: true),
                arg3.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg3,
                        retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _CoreBluetooth_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBL2CAPChannel?,
            objc.NSError?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBL2CAPChannel?,
          objc.NSError?)> blocking(
      void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBL2CAPChannel?,
              objc.NSError?)
          fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBL2CAPChannel_NSError_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                CBPeripheral.castFromPointer(arg1,
                    retain: false, release: true),
                arg2.address == 0
                    ? null
                    : CBL2CAPChannel.castFromPointer(arg2,
                        retain: false, release: true),
                arg3.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg3,
                        retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBL2CAPChannel_NSError_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                CBPeripheral.castFromPointer(arg1,
                    retain: false, release: true),
                arg2.address == 0
                    ? null
                    : CBL2CAPChannel.castFromPointer(arg2,
                        retain: false, release: true),
                arg3.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg3,
                        retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _CoreBluetooth_wrapBlockingBlock_1tz5yf(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBL2CAPChannel?,
            objc.NSError?)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBL2CAPChannel?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBL2CAPChannel_NSError_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBL2CAPChannel?,
            objc.NSError?)> {
  void call(ffi.Pointer<ffi.Void> arg0, CBPeripheral arg1, CBL2CAPChannel? arg2,
          objc.NSError? arg3) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<objc.ObjCObject> arg3)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer,
          arg0,
          arg1.ref.pointer,
          arg2?.ref.pointer ?? ffi.nullptr,
          arg3?.ref.pointer ?? ffi.nullptr);
}

/// CBPeripheralDelegate
interface class CBPeripheralDelegate extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  CBPeripheralDelegate._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [CBPeripheralDelegate] that points to the same underlying object as [other].
  CBPeripheralDelegate.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CBPeripheralDelegate] that wraps the given raw object pointer.
  CBPeripheralDelegate.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CBPeripheralDelegate].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(obj.ref.pointer, _sel_conformsToProtocol_,
        _protocol_CBPeripheralDelegate);
  }

  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_CBPeripheralDelegate.cast());

  /// Builds an object that implements the CBPeripheralDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static CBPeripheralDelegate implement(
      {void Function(CBPeripheral)? peripheralDidUpdateName_,
      void Function(CBPeripheral, objc.NSArray)? peripheral_didModifyServices_,
      void Function(CBPeripheral, objc.NSError?)?
          peripheralDidUpdateRSSI_error_,
      void Function(CBPeripheral, objc.NSNumber, objc.NSError?)?
          peripheral_didReadRSSI_error_,
      void Function(CBPeripheral, objc.NSError?)?
          peripheral_didDiscoverServices_,
      void Function(CBPeripheral, CBService, objc.NSError?)?
          peripheral_didDiscoverIncludedServicesForService_error_,
      void Function(CBPeripheral, CBService, objc.NSError?)?
          peripheral_didDiscoverCharacteristicsForService_error_,
      void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
          peripheral_didUpdateValueForCharacteristic_error_,
      void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
          peripheral_didWriteValueForCharacteristic_error_,
      void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
          peripheral_didUpdateNotificationStateForCharacteristic_error_,
      void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
          peripheral_didDiscoverDescriptorsForCharacteristic_error_,
      void Function(CBPeripheral, CBDescriptor, objc.NSError?)?
          peripheral_didUpdateValueForDescriptor_error_,
      void Function(CBPeripheral, CBDescriptor, objc.NSError?)?
          peripheral_didWriteValueForDescriptor_error_,
      void Function(CBPeripheral)? peripheralIsReadyToSendWriteWithoutResponse_,
      void Function(CBPeripheral, CBL2CAPChannel?, objc.NSError?)?
          peripheral_didOpenL2CAPChannel_error_,
      bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'CBPeripheralDelegate');
    CBPeripheralDelegate.peripheralDidUpdateName_
        .implement(builder, peripheralDidUpdateName_);
    CBPeripheralDelegate.peripheral_didModifyServices_
        .implement(builder, peripheral_didModifyServices_);
    CBPeripheralDelegate.peripheralDidUpdateRSSI_error_
        .implement(builder, peripheralDidUpdateRSSI_error_);
    CBPeripheralDelegate.peripheral_didReadRSSI_error_
        .implement(builder, peripheral_didReadRSSI_error_);
    CBPeripheralDelegate.peripheral_didDiscoverServices_
        .implement(builder, peripheral_didDiscoverServices_);
    CBPeripheralDelegate.peripheral_didDiscoverIncludedServicesForService_error_
        .implement(
            builder, peripheral_didDiscoverIncludedServicesForService_error_);
    CBPeripheralDelegate.peripheral_didDiscoverCharacteristicsForService_error_
        .implement(
            builder, peripheral_didDiscoverCharacteristicsForService_error_);
    CBPeripheralDelegate.peripheral_didUpdateValueForCharacteristic_error_
        .implement(builder, peripheral_didUpdateValueForCharacteristic_error_);
    CBPeripheralDelegate.peripheral_didWriteValueForCharacteristic_error_
        .implement(builder, peripheral_didWriteValueForCharacteristic_error_);
    CBPeripheralDelegate
        .peripheral_didUpdateNotificationStateForCharacteristic_error_
        .implement(builder,
            peripheral_didUpdateNotificationStateForCharacteristic_error_);
    CBPeripheralDelegate
        .peripheral_didDiscoverDescriptorsForCharacteristic_error_
        .implement(
            builder, peripheral_didDiscoverDescriptorsForCharacteristic_error_);
    CBPeripheralDelegate.peripheral_didUpdateValueForDescriptor_error_
        .implement(builder, peripheral_didUpdateValueForDescriptor_error_);
    CBPeripheralDelegate.peripheral_didWriteValueForDescriptor_error_
        .implement(builder, peripheral_didWriteValueForDescriptor_error_);
    CBPeripheralDelegate.peripheralIsReadyToSendWriteWithoutResponse_
        .implement(builder, peripheralIsReadyToSendWriteWithoutResponse_);
    CBPeripheralDelegate.peripheral_didOpenL2CAPChannel_error_
        .implement(builder, peripheral_didOpenL2CAPChannel_error_);
    builder.addProtocol($protocol);
    return CBPeripheralDelegate.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the CBPeripheralDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(objc.ObjCProtocolBuilder builder,
      {void Function(CBPeripheral)? peripheralDidUpdateName_,
      void Function(CBPeripheral, objc.NSArray)? peripheral_didModifyServices_,
      void Function(CBPeripheral, objc.NSError?)?
          peripheralDidUpdateRSSI_error_,
      void Function(CBPeripheral, objc.NSNumber, objc.NSError?)?
          peripheral_didReadRSSI_error_,
      void Function(CBPeripheral, objc.NSError?)?
          peripheral_didDiscoverServices_,
      void Function(CBPeripheral, CBService, objc.NSError?)?
          peripheral_didDiscoverIncludedServicesForService_error_,
      void Function(CBPeripheral, CBService, objc.NSError?)?
          peripheral_didDiscoverCharacteristicsForService_error_,
      void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
          peripheral_didUpdateValueForCharacteristic_error_,
      void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
          peripheral_didWriteValueForCharacteristic_error_,
      void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
          peripheral_didUpdateNotificationStateForCharacteristic_error_,
      void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
          peripheral_didDiscoverDescriptorsForCharacteristic_error_,
      void Function(CBPeripheral, CBDescriptor, objc.NSError?)?
          peripheral_didUpdateValueForDescriptor_error_,
      void Function(CBPeripheral, CBDescriptor, objc.NSError?)?
          peripheral_didWriteValueForDescriptor_error_,
      void Function(CBPeripheral)? peripheralIsReadyToSendWriteWithoutResponse_,
      void Function(CBPeripheral, CBL2CAPChannel?, objc.NSError?)?
          peripheral_didOpenL2CAPChannel_error_,
      bool $keepIsolateAlive = true}) {
    CBPeripheralDelegate.peripheralDidUpdateName_
        .implement(builder, peripheralDidUpdateName_);
    CBPeripheralDelegate.peripheral_didModifyServices_
        .implement(builder, peripheral_didModifyServices_);
    CBPeripheralDelegate.peripheralDidUpdateRSSI_error_
        .implement(builder, peripheralDidUpdateRSSI_error_);
    CBPeripheralDelegate.peripheral_didReadRSSI_error_
        .implement(builder, peripheral_didReadRSSI_error_);
    CBPeripheralDelegate.peripheral_didDiscoverServices_
        .implement(builder, peripheral_didDiscoverServices_);
    CBPeripheralDelegate.peripheral_didDiscoverIncludedServicesForService_error_
        .implement(
            builder, peripheral_didDiscoverIncludedServicesForService_error_);
    CBPeripheralDelegate.peripheral_didDiscoverCharacteristicsForService_error_
        .implement(
            builder, peripheral_didDiscoverCharacteristicsForService_error_);
    CBPeripheralDelegate.peripheral_didUpdateValueForCharacteristic_error_
        .implement(builder, peripheral_didUpdateValueForCharacteristic_error_);
    CBPeripheralDelegate.peripheral_didWriteValueForCharacteristic_error_
        .implement(builder, peripheral_didWriteValueForCharacteristic_error_);
    CBPeripheralDelegate
        .peripheral_didUpdateNotificationStateForCharacteristic_error_
        .implement(builder,
            peripheral_didUpdateNotificationStateForCharacteristic_error_);
    CBPeripheralDelegate
        .peripheral_didDiscoverDescriptorsForCharacteristic_error_
        .implement(
            builder, peripheral_didDiscoverDescriptorsForCharacteristic_error_);
    CBPeripheralDelegate.peripheral_didUpdateValueForDescriptor_error_
        .implement(builder, peripheral_didUpdateValueForDescriptor_error_);
    CBPeripheralDelegate.peripheral_didWriteValueForDescriptor_error_
        .implement(builder, peripheral_didWriteValueForDescriptor_error_);
    CBPeripheralDelegate.peripheralIsReadyToSendWriteWithoutResponse_
        .implement(builder, peripheralIsReadyToSendWriteWithoutResponse_);
    CBPeripheralDelegate.peripheral_didOpenL2CAPChannel_error_
        .implement(builder, peripheral_didOpenL2CAPChannel_error_);
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the CBPeripheralDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static CBPeripheralDelegate implementAsListener(
      {void Function(CBPeripheral)? peripheralDidUpdateName_,
      void Function(CBPeripheral, objc.NSArray)? peripheral_didModifyServices_,
      void Function(CBPeripheral, objc.NSError?)?
          peripheralDidUpdateRSSI_error_,
      void Function(CBPeripheral, objc.NSNumber, objc.NSError?)?
          peripheral_didReadRSSI_error_,
      void Function(CBPeripheral, objc.NSError?)?
          peripheral_didDiscoverServices_,
      void Function(CBPeripheral, CBService, objc.NSError?)?
          peripheral_didDiscoverIncludedServicesForService_error_,
      void Function(CBPeripheral, CBService, objc.NSError?)?
          peripheral_didDiscoverCharacteristicsForService_error_,
      void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
          peripheral_didUpdateValueForCharacteristic_error_,
      void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
          peripheral_didWriteValueForCharacteristic_error_,
      void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
          peripheral_didUpdateNotificationStateForCharacteristic_error_,
      void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
          peripheral_didDiscoverDescriptorsForCharacteristic_error_,
      void Function(CBPeripheral, CBDescriptor, objc.NSError?)?
          peripheral_didUpdateValueForDescriptor_error_,
      void Function(CBPeripheral, CBDescriptor, objc.NSError?)?
          peripheral_didWriteValueForDescriptor_error_,
      void Function(CBPeripheral)? peripheralIsReadyToSendWriteWithoutResponse_,
      void Function(CBPeripheral, CBL2CAPChannel?, objc.NSError?)?
          peripheral_didOpenL2CAPChannel_error_,
      bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'CBPeripheralDelegate');
    CBPeripheralDelegate.peripheralDidUpdateName_
        .implementAsListener(builder, peripheralDidUpdateName_);
    CBPeripheralDelegate.peripheral_didModifyServices_
        .implementAsListener(builder, peripheral_didModifyServices_);
    CBPeripheralDelegate.peripheralDidUpdateRSSI_error_
        .implementAsListener(builder, peripheralDidUpdateRSSI_error_);
    CBPeripheralDelegate.peripheral_didReadRSSI_error_
        .implementAsListener(builder, peripheral_didReadRSSI_error_);
    CBPeripheralDelegate.peripheral_didDiscoverServices_
        .implementAsListener(builder, peripheral_didDiscoverServices_);
    CBPeripheralDelegate.peripheral_didDiscoverIncludedServicesForService_error_
        .implementAsListener(
            builder, peripheral_didDiscoverIncludedServicesForService_error_);
    CBPeripheralDelegate.peripheral_didDiscoverCharacteristicsForService_error_
        .implementAsListener(
            builder, peripheral_didDiscoverCharacteristicsForService_error_);
    CBPeripheralDelegate.peripheral_didUpdateValueForCharacteristic_error_
        .implementAsListener(
            builder, peripheral_didUpdateValueForCharacteristic_error_);
    CBPeripheralDelegate.peripheral_didWriteValueForCharacteristic_error_
        .implementAsListener(
            builder, peripheral_didWriteValueForCharacteristic_error_);
    CBPeripheralDelegate
        .peripheral_didUpdateNotificationStateForCharacteristic_error_
        .implementAsListener(builder,
            peripheral_didUpdateNotificationStateForCharacteristic_error_);
    CBPeripheralDelegate
        .peripheral_didDiscoverDescriptorsForCharacteristic_error_
        .implementAsListener(
            builder, peripheral_didDiscoverDescriptorsForCharacteristic_error_);
    CBPeripheralDelegate.peripheral_didUpdateValueForDescriptor_error_
        .implementAsListener(
            builder, peripheral_didUpdateValueForDescriptor_error_);
    CBPeripheralDelegate.peripheral_didWriteValueForDescriptor_error_
        .implementAsListener(
            builder, peripheral_didWriteValueForDescriptor_error_);
    CBPeripheralDelegate.peripheralIsReadyToSendWriteWithoutResponse_
        .implementAsListener(
            builder, peripheralIsReadyToSendWriteWithoutResponse_);
    CBPeripheralDelegate.peripheral_didOpenL2CAPChannel_error_
        .implementAsListener(builder, peripheral_didOpenL2CAPChannel_error_);
    builder.addProtocol($protocol);
    return CBPeripheralDelegate.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the CBPeripheralDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as listeners will
  /// be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsListener(objc.ObjCProtocolBuilder builder,
      {void Function(CBPeripheral)? peripheralDidUpdateName_,
      void Function(CBPeripheral, objc.NSArray)? peripheral_didModifyServices_,
      void Function(CBPeripheral, objc.NSError?)?
          peripheralDidUpdateRSSI_error_,
      void Function(CBPeripheral, objc.NSNumber, objc.NSError?)?
          peripheral_didReadRSSI_error_,
      void Function(CBPeripheral, objc.NSError?)?
          peripheral_didDiscoverServices_,
      void Function(CBPeripheral, CBService, objc.NSError?)?
          peripheral_didDiscoverIncludedServicesForService_error_,
      void Function(CBPeripheral, CBService, objc.NSError?)?
          peripheral_didDiscoverCharacteristicsForService_error_,
      void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
          peripheral_didUpdateValueForCharacteristic_error_,
      void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
          peripheral_didWriteValueForCharacteristic_error_,
      void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
          peripheral_didUpdateNotificationStateForCharacteristic_error_,
      void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
          peripheral_didDiscoverDescriptorsForCharacteristic_error_,
      void Function(CBPeripheral, CBDescriptor, objc.NSError?)?
          peripheral_didUpdateValueForDescriptor_error_,
      void Function(CBPeripheral, CBDescriptor, objc.NSError?)?
          peripheral_didWriteValueForDescriptor_error_,
      void Function(CBPeripheral)? peripheralIsReadyToSendWriteWithoutResponse_,
      void Function(CBPeripheral, CBL2CAPChannel?, objc.NSError?)?
          peripheral_didOpenL2CAPChannel_error_,
      bool $keepIsolateAlive = true}) {
    CBPeripheralDelegate.peripheralDidUpdateName_
        .implementAsListener(builder, peripheralDidUpdateName_);
    CBPeripheralDelegate.peripheral_didModifyServices_
        .implementAsListener(builder, peripheral_didModifyServices_);
    CBPeripheralDelegate.peripheralDidUpdateRSSI_error_
        .implementAsListener(builder, peripheralDidUpdateRSSI_error_);
    CBPeripheralDelegate.peripheral_didReadRSSI_error_
        .implementAsListener(builder, peripheral_didReadRSSI_error_);
    CBPeripheralDelegate.peripheral_didDiscoverServices_
        .implementAsListener(builder, peripheral_didDiscoverServices_);
    CBPeripheralDelegate.peripheral_didDiscoverIncludedServicesForService_error_
        .implementAsListener(
            builder, peripheral_didDiscoverIncludedServicesForService_error_);
    CBPeripheralDelegate.peripheral_didDiscoverCharacteristicsForService_error_
        .implementAsListener(
            builder, peripheral_didDiscoverCharacteristicsForService_error_);
    CBPeripheralDelegate.peripheral_didUpdateValueForCharacteristic_error_
        .implementAsListener(
            builder, peripheral_didUpdateValueForCharacteristic_error_);
    CBPeripheralDelegate.peripheral_didWriteValueForCharacteristic_error_
        .implementAsListener(
            builder, peripheral_didWriteValueForCharacteristic_error_);
    CBPeripheralDelegate
        .peripheral_didUpdateNotificationStateForCharacteristic_error_
        .implementAsListener(builder,
            peripheral_didUpdateNotificationStateForCharacteristic_error_);
    CBPeripheralDelegate
        .peripheral_didDiscoverDescriptorsForCharacteristic_error_
        .implementAsListener(
            builder, peripheral_didDiscoverDescriptorsForCharacteristic_error_);
    CBPeripheralDelegate.peripheral_didUpdateValueForDescriptor_error_
        .implementAsListener(
            builder, peripheral_didUpdateValueForDescriptor_error_);
    CBPeripheralDelegate.peripheral_didWriteValueForDescriptor_error_
        .implementAsListener(
            builder, peripheral_didWriteValueForDescriptor_error_);
    CBPeripheralDelegate.peripheralIsReadyToSendWriteWithoutResponse_
        .implementAsListener(
            builder, peripheralIsReadyToSendWriteWithoutResponse_);
    CBPeripheralDelegate.peripheral_didOpenL2CAPChannel_error_
        .implementAsListener(builder, peripheral_didOpenL2CAPChannel_error_);
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the CBPeripheralDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as blocking listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static CBPeripheralDelegate implementAsBlocking(
      {void Function(CBPeripheral)? peripheralDidUpdateName_,
      void Function(CBPeripheral, objc.NSArray)? peripheral_didModifyServices_,
      void Function(CBPeripheral, objc.NSError?)?
          peripheralDidUpdateRSSI_error_,
      void Function(CBPeripheral, objc.NSNumber, objc.NSError?)?
          peripheral_didReadRSSI_error_,
      void Function(CBPeripheral, objc.NSError?)?
          peripheral_didDiscoverServices_,
      void Function(CBPeripheral, CBService, objc.NSError?)?
          peripheral_didDiscoverIncludedServicesForService_error_,
      void Function(CBPeripheral, CBService, objc.NSError?)?
          peripheral_didDiscoverCharacteristicsForService_error_,
      void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
          peripheral_didUpdateValueForCharacteristic_error_,
      void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
          peripheral_didWriteValueForCharacteristic_error_,
      void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
          peripheral_didUpdateNotificationStateForCharacteristic_error_,
      void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
          peripheral_didDiscoverDescriptorsForCharacteristic_error_,
      void Function(CBPeripheral, CBDescriptor, objc.NSError?)?
          peripheral_didUpdateValueForDescriptor_error_,
      void Function(CBPeripheral, CBDescriptor, objc.NSError?)?
          peripheral_didWriteValueForDescriptor_error_,
      void Function(CBPeripheral)? peripheralIsReadyToSendWriteWithoutResponse_,
      void Function(CBPeripheral, CBL2CAPChannel?, objc.NSError?)?
          peripheral_didOpenL2CAPChannel_error_,
      bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'CBPeripheralDelegate');
    CBPeripheralDelegate.peripheralDidUpdateName_
        .implementAsBlocking(builder, peripheralDidUpdateName_);
    CBPeripheralDelegate.peripheral_didModifyServices_
        .implementAsBlocking(builder, peripheral_didModifyServices_);
    CBPeripheralDelegate.peripheralDidUpdateRSSI_error_
        .implementAsBlocking(builder, peripheralDidUpdateRSSI_error_);
    CBPeripheralDelegate.peripheral_didReadRSSI_error_
        .implementAsBlocking(builder, peripheral_didReadRSSI_error_);
    CBPeripheralDelegate.peripheral_didDiscoverServices_
        .implementAsBlocking(builder, peripheral_didDiscoverServices_);
    CBPeripheralDelegate.peripheral_didDiscoverIncludedServicesForService_error_
        .implementAsBlocking(
            builder, peripheral_didDiscoverIncludedServicesForService_error_);
    CBPeripheralDelegate.peripheral_didDiscoverCharacteristicsForService_error_
        .implementAsBlocking(
            builder, peripheral_didDiscoverCharacteristicsForService_error_);
    CBPeripheralDelegate.peripheral_didUpdateValueForCharacteristic_error_
        .implementAsBlocking(
            builder, peripheral_didUpdateValueForCharacteristic_error_);
    CBPeripheralDelegate.peripheral_didWriteValueForCharacteristic_error_
        .implementAsBlocking(
            builder, peripheral_didWriteValueForCharacteristic_error_);
    CBPeripheralDelegate
        .peripheral_didUpdateNotificationStateForCharacteristic_error_
        .implementAsBlocking(builder,
            peripheral_didUpdateNotificationStateForCharacteristic_error_);
    CBPeripheralDelegate
        .peripheral_didDiscoverDescriptorsForCharacteristic_error_
        .implementAsBlocking(
            builder, peripheral_didDiscoverDescriptorsForCharacteristic_error_);
    CBPeripheralDelegate.peripheral_didUpdateValueForDescriptor_error_
        .implementAsBlocking(
            builder, peripheral_didUpdateValueForDescriptor_error_);
    CBPeripheralDelegate.peripheral_didWriteValueForDescriptor_error_
        .implementAsBlocking(
            builder, peripheral_didWriteValueForDescriptor_error_);
    CBPeripheralDelegate.peripheralIsReadyToSendWriteWithoutResponse_
        .implementAsBlocking(
            builder, peripheralIsReadyToSendWriteWithoutResponse_);
    CBPeripheralDelegate.peripheral_didOpenL2CAPChannel_error_
        .implementAsBlocking(builder, peripheral_didOpenL2CAPChannel_error_);
    builder.addProtocol($protocol);
    return CBPeripheralDelegate.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the CBPeripheralDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as blocking
  /// listeners will be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsBlocking(objc.ObjCProtocolBuilder builder,
      {void Function(CBPeripheral)? peripheralDidUpdateName_,
      void Function(CBPeripheral, objc.NSArray)? peripheral_didModifyServices_,
      void Function(CBPeripheral, objc.NSError?)?
          peripheralDidUpdateRSSI_error_,
      void Function(CBPeripheral, objc.NSNumber, objc.NSError?)?
          peripheral_didReadRSSI_error_,
      void Function(CBPeripheral, objc.NSError?)?
          peripheral_didDiscoverServices_,
      void Function(CBPeripheral, CBService, objc.NSError?)?
          peripheral_didDiscoverIncludedServicesForService_error_,
      void Function(CBPeripheral, CBService, objc.NSError?)?
          peripheral_didDiscoverCharacteristicsForService_error_,
      void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
          peripheral_didUpdateValueForCharacteristic_error_,
      void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
          peripheral_didWriteValueForCharacteristic_error_,
      void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
          peripheral_didUpdateNotificationStateForCharacteristic_error_,
      void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
          peripheral_didDiscoverDescriptorsForCharacteristic_error_,
      void Function(CBPeripheral, CBDescriptor, objc.NSError?)?
          peripheral_didUpdateValueForDescriptor_error_,
      void Function(CBPeripheral, CBDescriptor, objc.NSError?)?
          peripheral_didWriteValueForDescriptor_error_,
      void Function(CBPeripheral)? peripheralIsReadyToSendWriteWithoutResponse_,
      void Function(CBPeripheral, CBL2CAPChannel?, objc.NSError?)?
          peripheral_didOpenL2CAPChannel_error_,
      bool $keepIsolateAlive = true}) {
    CBPeripheralDelegate.peripheralDidUpdateName_
        .implementAsBlocking(builder, peripheralDidUpdateName_);
    CBPeripheralDelegate.peripheral_didModifyServices_
        .implementAsBlocking(builder, peripheral_didModifyServices_);
    CBPeripheralDelegate.peripheralDidUpdateRSSI_error_
        .implementAsBlocking(builder, peripheralDidUpdateRSSI_error_);
    CBPeripheralDelegate.peripheral_didReadRSSI_error_
        .implementAsBlocking(builder, peripheral_didReadRSSI_error_);
    CBPeripheralDelegate.peripheral_didDiscoverServices_
        .implementAsBlocking(builder, peripheral_didDiscoverServices_);
    CBPeripheralDelegate.peripheral_didDiscoverIncludedServicesForService_error_
        .implementAsBlocking(
            builder, peripheral_didDiscoverIncludedServicesForService_error_);
    CBPeripheralDelegate.peripheral_didDiscoverCharacteristicsForService_error_
        .implementAsBlocking(
            builder, peripheral_didDiscoverCharacteristicsForService_error_);
    CBPeripheralDelegate.peripheral_didUpdateValueForCharacteristic_error_
        .implementAsBlocking(
            builder, peripheral_didUpdateValueForCharacteristic_error_);
    CBPeripheralDelegate.peripheral_didWriteValueForCharacteristic_error_
        .implementAsBlocking(
            builder, peripheral_didWriteValueForCharacteristic_error_);
    CBPeripheralDelegate
        .peripheral_didUpdateNotificationStateForCharacteristic_error_
        .implementAsBlocking(builder,
            peripheral_didUpdateNotificationStateForCharacteristic_error_);
    CBPeripheralDelegate
        .peripheral_didDiscoverDescriptorsForCharacteristic_error_
        .implementAsBlocking(
            builder, peripheral_didDiscoverDescriptorsForCharacteristic_error_);
    CBPeripheralDelegate.peripheral_didUpdateValueForDescriptor_error_
        .implementAsBlocking(
            builder, peripheral_didUpdateValueForDescriptor_error_);
    CBPeripheralDelegate.peripheral_didWriteValueForDescriptor_error_
        .implementAsBlocking(
            builder, peripheral_didWriteValueForDescriptor_error_);
    CBPeripheralDelegate.peripheralIsReadyToSendWriteWithoutResponse_
        .implementAsBlocking(
            builder, peripheralIsReadyToSendWriteWithoutResponse_);
    CBPeripheralDelegate.peripheral_didOpenL2CAPChannel_error_
        .implementAsBlocking(builder, peripheral_didOpenL2CAPChannel_error_);
    builder.addProtocol($protocol);
  }

  /// peripheralDidUpdateName:
  static final peripheralDidUpdateName_ =
      objc.ObjCProtocolListenableMethod<void Function(CBPeripheral)>(
    _protocol_CBPeripheralDelegate,
    _sel_peripheralDidUpdateName_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _CoreBluetooth_protocolTrampoline_18v1jvf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CBPeripheralDelegate,
      _sel_peripheralDidUpdateName_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(CBPeripheral) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral.fromFunction(
            (ffi.Pointer<ffi.Void> _, CBPeripheral arg1) => func(arg1)),
    (void Function(CBPeripheral) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral.listener(
            (ffi.Pointer<ffi.Void> _, CBPeripheral arg1) => func(arg1)),
    (void Function(CBPeripheral) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral.blocking(
            (ffi.Pointer<ffi.Void> _, CBPeripheral arg1) => func(arg1)),
  );

  /// peripheral:didModifyServices:
  static final peripheral_didModifyServices_ = objc
      .ObjCProtocolListenableMethod<void Function(CBPeripheral, objc.NSArray)>(
    _protocol_CBPeripheralDelegate,
    _sel_peripheral_didModifyServices_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _CoreBluetooth_protocolTrampoline_fjrv01)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CBPeripheralDelegate,
      _sel_peripheral_didModifyServices_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(CBPeripheral, objc.NSArray) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSArray.fromFunction(
            (ffi.Pointer<ffi.Void> _, CBPeripheral arg1, objc.NSArray arg2) =>
                func(arg1, arg2)),
    (void Function(CBPeripheral, objc.NSArray) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSArray.listener(
            (ffi.Pointer<ffi.Void> _, CBPeripheral arg1, objc.NSArray arg2) =>
                func(arg1, arg2)),
    (void Function(CBPeripheral, objc.NSArray) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSArray.blocking(
            (ffi.Pointer<ffi.Void> _, CBPeripheral arg1, objc.NSArray arg2) =>
                func(arg1, arg2)),
  );

  /// peripheralDidUpdateRSSI:error:
  static final peripheralDidUpdateRSSI_error_ = objc
      .ObjCProtocolListenableMethod<void Function(CBPeripheral, objc.NSError?)>(
    _protocol_CBPeripheralDelegate,
    _sel_peripheralDidUpdateRSSI_error_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _CoreBluetooth_protocolTrampoline_fjrv01)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CBPeripheralDelegate,
      _sel_peripheralDidUpdateRSSI_error_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(CBPeripheral, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError.fromFunction(
            (ffi.Pointer<ffi.Void> _, CBPeripheral arg1, objc.NSError? arg2) =>
                func(arg1, arg2)),
    (void Function(CBPeripheral, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError.listener(
            (ffi.Pointer<ffi.Void> _, CBPeripheral arg1, objc.NSError? arg2) =>
                func(arg1, arg2)),
    (void Function(CBPeripheral, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError.blocking(
            (ffi.Pointer<ffi.Void> _, CBPeripheral arg1, objc.NSError? arg2) =>
                func(arg1, arg2)),
  );

  /// peripheral:didReadRSSI:error:
  static final peripheral_didReadRSSI_error_ =
      objc.ObjCProtocolListenableMethod<
          void Function(CBPeripheral, objc.NSNumber, objc.NSError?)>(
    _protocol_CBPeripheralDelegate,
    _sel_peripheral_didReadRSSI_error_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _CoreBluetooth_protocolTrampoline_1tz5yf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CBPeripheralDelegate,
      _sel_peripheral_didReadRSSI_error_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(CBPeripheral, objc.NSNumber, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSNumber_NSError.fromFunction(
            (ffi.Pointer<ffi.Void> _, CBPeripheral arg1, objc.NSNumber arg2,
                    objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(CBPeripheral, objc.NSNumber, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSNumber_NSError.listener(
            (ffi.Pointer<ffi.Void> _, CBPeripheral arg1, objc.NSNumber arg2,
                    objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(CBPeripheral, objc.NSNumber, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSNumber_NSError.blocking(
            (ffi.Pointer<ffi.Void> _, CBPeripheral arg1, objc.NSNumber arg2,
                    objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// peripheral:didDiscoverServices:
  static final peripheral_didDiscoverServices_ = objc
      .ObjCProtocolListenableMethod<void Function(CBPeripheral, objc.NSError?)>(
    _protocol_CBPeripheralDelegate,
    _sel_peripheral_didDiscoverServices_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _CoreBluetooth_protocolTrampoline_fjrv01)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CBPeripheralDelegate,
      _sel_peripheral_didDiscoverServices_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(CBPeripheral, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError.fromFunction(
            (ffi.Pointer<ffi.Void> _, CBPeripheral arg1, objc.NSError? arg2) =>
                func(arg1, arg2)),
    (void Function(CBPeripheral, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError.listener(
            (ffi.Pointer<ffi.Void> _, CBPeripheral arg1, objc.NSError? arg2) =>
                func(arg1, arg2)),
    (void Function(CBPeripheral, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError.blocking(
            (ffi.Pointer<ffi.Void> _, CBPeripheral arg1, objc.NSError? arg2) =>
                func(arg1, arg2)),
  );

  /// peripheral:didDiscoverIncludedServicesForService:error:
  static final peripheral_didDiscoverIncludedServicesForService_error_ =
      objc.ObjCProtocolListenableMethod<
          void Function(CBPeripheral, CBService, objc.NSError?)>(
    _protocol_CBPeripheralDelegate,
    _sel_peripheral_didDiscoverIncludedServicesForService_error_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _CoreBluetooth_protocolTrampoline_1tz5yf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CBPeripheralDelegate,
      _sel_peripheral_didDiscoverIncludedServicesForService_error_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(CBPeripheral, CBService, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError.fromFunction(
            (ffi.Pointer<ffi.Void> _, CBPeripheral arg1, CBService arg2,
                    objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(CBPeripheral, CBService, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError.listener(
            (ffi.Pointer<ffi.Void> _, CBPeripheral arg1, CBService arg2,
                    objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(CBPeripheral, CBService, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError.blocking(
            (ffi.Pointer<ffi.Void> _, CBPeripheral arg1, CBService arg2,
                    objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// peripheral:didDiscoverCharacteristicsForService:error:
  static final peripheral_didDiscoverCharacteristicsForService_error_ =
      objc.ObjCProtocolListenableMethod<
          void Function(CBPeripheral, CBService, objc.NSError?)>(
    _protocol_CBPeripheralDelegate,
    _sel_peripheral_didDiscoverCharacteristicsForService_error_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _CoreBluetooth_protocolTrampoline_1tz5yf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CBPeripheralDelegate,
      _sel_peripheral_didDiscoverCharacteristicsForService_error_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(CBPeripheral, CBService, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError.fromFunction(
            (ffi.Pointer<ffi.Void> _, CBPeripheral arg1, CBService arg2,
                    objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(CBPeripheral, CBService, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError.listener(
            (ffi.Pointer<ffi.Void> _, CBPeripheral arg1, CBService arg2,
                    objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(CBPeripheral, CBService, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError.blocking(
            (ffi.Pointer<ffi.Void> _, CBPeripheral arg1, CBService arg2,
                    objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// peripheral:didUpdateValueForCharacteristic:error:
  static final peripheral_didUpdateValueForCharacteristic_error_ =
      objc.ObjCProtocolListenableMethod<
          void Function(CBPeripheral, CBCharacteristic, objc.NSError?)>(
    _protocol_CBPeripheralDelegate,
    _sel_peripheral_didUpdateValueForCharacteristic_error_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _CoreBluetooth_protocolTrampoline_1tz5yf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CBPeripheralDelegate,
      _sel_peripheral_didUpdateValueForCharacteristic_error_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(CBPeripheral, CBCharacteristic, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError
            .fromFunction((ffi.Pointer<ffi.Void> _, CBPeripheral arg1,
                    CBCharacteristic arg2, objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(CBPeripheral, CBCharacteristic, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError
            .listener((ffi.Pointer<ffi.Void> _, CBPeripheral arg1,
                    CBCharacteristic arg2, objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(CBPeripheral, CBCharacteristic, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError
            .blocking((ffi.Pointer<ffi.Void> _, CBPeripheral arg1,
                    CBCharacteristic arg2, objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// peripheral:didWriteValueForCharacteristic:error:
  static final peripheral_didWriteValueForCharacteristic_error_ =
      objc.ObjCProtocolListenableMethod<
          void Function(CBPeripheral, CBCharacteristic, objc.NSError?)>(
    _protocol_CBPeripheralDelegate,
    _sel_peripheral_didWriteValueForCharacteristic_error_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _CoreBluetooth_protocolTrampoline_1tz5yf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CBPeripheralDelegate,
      _sel_peripheral_didWriteValueForCharacteristic_error_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(CBPeripheral, CBCharacteristic, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError
            .fromFunction((ffi.Pointer<ffi.Void> _, CBPeripheral arg1,
                    CBCharacteristic arg2, objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(CBPeripheral, CBCharacteristic, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError
            .listener((ffi.Pointer<ffi.Void> _, CBPeripheral arg1,
                    CBCharacteristic arg2, objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(CBPeripheral, CBCharacteristic, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError
            .blocking((ffi.Pointer<ffi.Void> _, CBPeripheral arg1,
                    CBCharacteristic arg2, objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// peripheral:didUpdateNotificationStateForCharacteristic:error:
  static final peripheral_didUpdateNotificationStateForCharacteristic_error_ =
      objc.ObjCProtocolListenableMethod<
          void Function(CBPeripheral, CBCharacteristic, objc.NSError?)>(
    _protocol_CBPeripheralDelegate,
    _sel_peripheral_didUpdateNotificationStateForCharacteristic_error_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _CoreBluetooth_protocolTrampoline_1tz5yf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CBPeripheralDelegate,
      _sel_peripheral_didUpdateNotificationStateForCharacteristic_error_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(CBPeripheral, CBCharacteristic, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError
            .fromFunction((ffi.Pointer<ffi.Void> _, CBPeripheral arg1,
                    CBCharacteristic arg2, objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(CBPeripheral, CBCharacteristic, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError
            .listener((ffi.Pointer<ffi.Void> _, CBPeripheral arg1,
                    CBCharacteristic arg2, objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(CBPeripheral, CBCharacteristic, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError
            .blocking((ffi.Pointer<ffi.Void> _, CBPeripheral arg1,
                    CBCharacteristic arg2, objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// peripheral:didDiscoverDescriptorsForCharacteristic:error:
  static final peripheral_didDiscoverDescriptorsForCharacteristic_error_ =
      objc.ObjCProtocolListenableMethod<
          void Function(CBPeripheral, CBCharacteristic, objc.NSError?)>(
    _protocol_CBPeripheralDelegate,
    _sel_peripheral_didDiscoverDescriptorsForCharacteristic_error_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _CoreBluetooth_protocolTrampoline_1tz5yf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CBPeripheralDelegate,
      _sel_peripheral_didDiscoverDescriptorsForCharacteristic_error_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(CBPeripheral, CBCharacteristic, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError
            .fromFunction((ffi.Pointer<ffi.Void> _, CBPeripheral arg1,
                    CBCharacteristic arg2, objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(CBPeripheral, CBCharacteristic, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError
            .listener((ffi.Pointer<ffi.Void> _, CBPeripheral arg1,
                    CBCharacteristic arg2, objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(CBPeripheral, CBCharacteristic, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError
            .blocking((ffi.Pointer<ffi.Void> _, CBPeripheral arg1,
                    CBCharacteristic arg2, objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// peripheral:didUpdateValueForDescriptor:error:
  static final peripheral_didUpdateValueForDescriptor_error_ =
      objc.ObjCProtocolListenableMethod<
          void Function(CBPeripheral, CBDescriptor, objc.NSError?)>(
    _protocol_CBPeripheralDelegate,
    _sel_peripheral_didUpdateValueForDescriptor_error_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _CoreBluetooth_protocolTrampoline_1tz5yf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CBPeripheralDelegate,
      _sel_peripheral_didUpdateValueForDescriptor_error_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(CBPeripheral, CBDescriptor, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError
            .fromFunction((ffi.Pointer<ffi.Void> _, CBPeripheral arg1,
                    CBDescriptor arg2, objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(CBPeripheral, CBDescriptor, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError.listener(
            (ffi.Pointer<ffi.Void> _, CBPeripheral arg1, CBDescriptor arg2,
                    objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(CBPeripheral, CBDescriptor, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError.blocking(
            (ffi.Pointer<ffi.Void> _, CBPeripheral arg1, CBDescriptor arg2,
                    objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// peripheral:didWriteValueForDescriptor:error:
  static final peripheral_didWriteValueForDescriptor_error_ =
      objc.ObjCProtocolListenableMethod<
          void Function(CBPeripheral, CBDescriptor, objc.NSError?)>(
    _protocol_CBPeripheralDelegate,
    _sel_peripheral_didWriteValueForDescriptor_error_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _CoreBluetooth_protocolTrampoline_1tz5yf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CBPeripheralDelegate,
      _sel_peripheral_didWriteValueForDescriptor_error_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(CBPeripheral, CBDescriptor, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError
            .fromFunction((ffi.Pointer<ffi.Void> _, CBPeripheral arg1,
                    CBDescriptor arg2, objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(CBPeripheral, CBDescriptor, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError.listener(
            (ffi.Pointer<ffi.Void> _, CBPeripheral arg1, CBDescriptor arg2,
                    objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(CBPeripheral, CBDescriptor, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError.blocking(
            (ffi.Pointer<ffi.Void> _, CBPeripheral arg1, CBDescriptor arg2,
                    objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// peripheralIsReadyToSendWriteWithoutResponse:
  static final peripheralIsReadyToSendWriteWithoutResponse_ =
      objc.ObjCProtocolListenableMethod<void Function(CBPeripheral)>(
    _protocol_CBPeripheralDelegate,
    _sel_peripheralIsReadyToSendWriteWithoutResponse_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _CoreBluetooth_protocolTrampoline_18v1jvf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CBPeripheralDelegate,
      _sel_peripheralIsReadyToSendWriteWithoutResponse_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(CBPeripheral) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral.fromFunction(
            (ffi.Pointer<ffi.Void> _, CBPeripheral arg1) => func(arg1)),
    (void Function(CBPeripheral) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral.listener(
            (ffi.Pointer<ffi.Void> _, CBPeripheral arg1) => func(arg1)),
    (void Function(CBPeripheral) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral.blocking(
            (ffi.Pointer<ffi.Void> _, CBPeripheral arg1) => func(arg1)),
  );

  /// peripheral:didOpenL2CAPChannel:error:
  static final peripheral_didOpenL2CAPChannel_error_ =
      objc.ObjCProtocolListenableMethod<
          void Function(CBPeripheral, CBL2CAPChannel?, objc.NSError?)>(
    _protocol_CBPeripheralDelegate,
    _sel_peripheral_didOpenL2CAPChannel_error_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _CoreBluetooth_protocolTrampoline_1tz5yf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CBPeripheralDelegate,
      _sel_peripheral_didOpenL2CAPChannel_error_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(CBPeripheral, CBL2CAPChannel?, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBL2CAPChannel_NSError
            .fromFunction((ffi.Pointer<ffi.Void> _, CBPeripheral arg1,
                    CBL2CAPChannel? arg2, objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(CBPeripheral, CBL2CAPChannel?, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBL2CAPChannel_NSError.listener(
            (ffi.Pointer<ffi.Void> _, CBPeripheral arg1, CBL2CAPChannel? arg2,
                    objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(CBPeripheral, CBL2CAPChannel?, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBL2CAPChannel_NSError.blocking(
            (ffi.Pointer<ffi.Void> _, CBPeripheral arg1, CBL2CAPChannel? arg2,
                    objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
  );
}

late final _sel_delegate = objc.registerName("delegate");
late final _sel_setDelegate_ = objc.registerName("setDelegate:");
final _objc_msgSend_xtuoz7 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_name = objc.registerName("name");
late final _sel_RSSI = objc.registerName("RSSI");

enum CBPeripheralState {
  CBPeripheralStateDisconnected(0),
  CBPeripheralStateConnecting(1),
  CBPeripheralStateConnected(2),
  CBPeripheralStateDisconnecting(3);

  final int value;
  const CBPeripheralState(this.value);

  static CBPeripheralState fromValue(int value) => switch (value) {
        0 => CBPeripheralStateDisconnected,
        1 => CBPeripheralStateConnecting,
        2 => CBPeripheralStateConnected,
        3 => CBPeripheralStateDisconnecting,
        _ => throw ArgumentError('Unknown value for CBPeripheralState: $value'),
      };
}

final _objc_msgSend_1vwb6jt = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_services = objc.registerName("services");
late final _sel_canSendWriteWithoutResponse =
    objc.registerName("canSendWriteWithoutResponse");
late final _sel_ancsAuthorized = objc.registerName("ancsAuthorized");
late final _sel_readRSSI = objc.registerName("readRSSI");
final _objc_msgSend_1pl9qdv = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_discoverServices_ = objc.registerName("discoverServices:");
late final _sel_discoverIncludedServices_forService_ =
    objc.registerName("discoverIncludedServices:forService:");
final _objc_msgSend_pfv6jd = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_discoverCharacteristics_forService_ =
    objc.registerName("discoverCharacteristics:forService:");
late final _sel_readValueForCharacteristic_ =
    objc.registerName("readValueForCharacteristic:");

enum CBCharacteristicWriteType {
  CBCharacteristicWriteWithResponse(0),
  CBCharacteristicWriteWithoutResponse(1);

  final int value;
  const CBCharacteristicWriteType(this.value);

  static CBCharacteristicWriteType fromValue(int value) => switch (value) {
        0 => CBCharacteristicWriteWithResponse,
        1 => CBCharacteristicWriteWithoutResponse,
        _ => throw ArgumentError(
            'Unknown value for CBCharacteristicWriteType: $value'),
      };
}

late final _sel_maximumWriteValueLengthForType_ =
    objc.registerName("maximumWriteValueLengthForType:");
final _objc_msgSend_1du2ky5 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        int Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_writeValue_forCharacteristic_type_ =
    objc.registerName("writeValue:forCharacteristic:type:");
final _objc_msgSend_188up4e = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Long)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            int)>();
late final _sel_setNotifyValue_forCharacteristic_ =
    objc.registerName("setNotifyValue:forCharacteristic:");
final _objc_msgSend_hk7n97 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Bool,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            bool,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_discoverDescriptorsForCharacteristic_ =
    objc.registerName("discoverDescriptorsForCharacteristic:");
late final _sel_readValueForDescriptor_ =
    objc.registerName("readValueForDescriptor:");
late final _sel_writeValue_forDescriptor_ =
    objc.registerName("writeValue:forDescriptor:");
late final _sel_openL2CAPChannel_ = objc.registerName("openL2CAPChannel:");
final _objc_msgSend_15f11yh = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Uint16)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();

/// CBPeripheral
class CBPeripheral extends CBPeer {
  CBPeripheral._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('CBPeripheral', macOS: (false, (10, 7, 0)));
  }

  /// Constructs a [CBPeripheral] that points to the same underlying object as [other].
  CBPeripheral.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CBPeripheral] that wraps the given raw object pointer.
  CBPeripheral.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CBPeripheral].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_CBPeripheral);
  }

  /// delegate
  CBPeripheralDelegate? get delegate {
    objc.checkOsVersionInternal('CBPeripheral.delegate',
        macOS: (false, (10, 7, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_delegate);
    return _ret.address == 0
        ? null
        : CBPeripheralDelegate.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// setDelegate:
  set delegate(CBPeripheralDelegate? value) {
    objc.checkOsVersionInternal('CBPeripheral.setDelegate:',
        macOS: (false, (10, 7, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setDelegate_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// name
  objc.NSString? get name {
    objc.checkOsVersionInternal('CBPeripheral.name',
        macOS: (false, (10, 7, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_name);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// RSSI
  objc.NSNumber? get RSSI {
    objc.checkOsVersionInternal('CBPeripheral.RSSI',
        macOS: (false, (10, 7, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_RSSI);
    return _ret.address == 0
        ? null
        : objc.NSNumber.castFromPointer(_ret, retain: true, release: true);
  }

  /// state
  CBPeripheralState get state {
    objc.checkOsVersionInternal('CBPeripheral.state',
        macOS: (false, (10, 7, 0)));
    final _ret = _objc_msgSend_1vwb6jt(this.ref.pointer, _sel_state);
    return CBPeripheralState.fromValue(_ret);
  }

  /// services
  objc.NSArray? get services {
    objc.checkOsVersionInternal('CBPeripheral.services',
        macOS: (false, (10, 7, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_services);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// canSendWriteWithoutResponse
  bool get canSendWriteWithoutResponse {
    objc.checkOsVersionInternal('CBPeripheral.canSendWriteWithoutResponse',
        macOS: (false, (10, 13, 0)));
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_canSendWriteWithoutResponse);
  }

  /// ancsAuthorized
  bool get ancsAuthorized {
    objc.checkOsVersionInternal('CBPeripheral.ancsAuthorized',
        macOS: (true, null));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_ancsAuthorized);
  }

  /// readRSSI
  void readRSSI() {
    objc.checkOsVersionInternal('CBPeripheral.readRSSI',
        macOS: (false, (10, 7, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_readRSSI);
  }

  /// discoverServices:
  void discoverServices(objc.NSArray? serviceUUIDs) {
    objc.checkOsVersionInternal('CBPeripheral.discoverServices:',
        macOS: (false, (10, 7, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_discoverServices_,
        serviceUUIDs?.ref.pointer ?? ffi.nullptr);
  }

  /// discoverIncludedServices:forService:
  void discoverIncludedServices(objc.NSArray? includedServiceUUIDs,
      {required CBService forService}) {
    objc.checkOsVersionInternal(
        'CBPeripheral.discoverIncludedServices:forService:',
        macOS: (false, (10, 7, 0)));
    _objc_msgSend_pfv6jd(
        this.ref.pointer,
        _sel_discoverIncludedServices_forService_,
        includedServiceUUIDs?.ref.pointer ?? ffi.nullptr,
        forService.ref.pointer);
  }

  /// discoverCharacteristics:forService:
  void discoverCharacteristics(objc.NSArray? characteristicUUIDs,
      {required CBService forService}) {
    objc.checkOsVersionInternal(
        'CBPeripheral.discoverCharacteristics:forService:',
        macOS: (false, (10, 7, 0)));
    _objc_msgSend_pfv6jd(
        this.ref.pointer,
        _sel_discoverCharacteristics_forService_,
        characteristicUUIDs?.ref.pointer ?? ffi.nullptr,
        forService.ref.pointer);
  }

  /// readValueForCharacteristic:
  void readValueForCharacteristic(CBCharacteristic characteristic) {
    objc.checkOsVersionInternal('CBPeripheral.readValueForCharacteristic:',
        macOS: (false, (10, 7, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_readValueForCharacteristic_,
        characteristic.ref.pointer);
  }

  /// maximumWriteValueLengthForType:
  int maximumWriteValueLengthForType(CBCharacteristicWriteType type) {
    objc.checkOsVersionInternal('CBPeripheral.maximumWriteValueLengthForType:',
        macOS: (false, (10, 12, 0)));
    return _objc_msgSend_1du2ky5(
        this.ref.pointer, _sel_maximumWriteValueLengthForType_, type.value);
  }

  /// writeValue:forCharacteristic:type:
  void writeValue(objc.NSData data,
      {required CBCharacteristic forCharacteristic,
      required CBCharacteristicWriteType type}) {
    objc.checkOsVersionInternal(
        'CBPeripheral.writeValue:forCharacteristic:type:',
        macOS: (false, (10, 7, 0)));
    _objc_msgSend_188up4e(
        this.ref.pointer,
        _sel_writeValue_forCharacteristic_type_,
        data.ref.pointer,
        forCharacteristic.ref.pointer,
        type.value);
  }

  /// setNotifyValue:forCharacteristic:
  void setNotifyValue(bool enabled,
      {required CBCharacteristic forCharacteristic}) {
    objc.checkOsVersionInternal(
        'CBPeripheral.setNotifyValue:forCharacteristic:',
        macOS: (false, (10, 7, 0)));
    _objc_msgSend_hk7n97(
        this.ref.pointer,
        _sel_setNotifyValue_forCharacteristic_,
        enabled,
        forCharacteristic.ref.pointer);
  }

  /// discoverDescriptorsForCharacteristic:
  void discoverDescriptorsForCharacteristic(CBCharacteristic characteristic) {
    objc.checkOsVersionInternal(
        'CBPeripheral.discoverDescriptorsForCharacteristic:',
        macOS: (false, (10, 7, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer,
        _sel_discoverDescriptorsForCharacteristic_, characteristic.ref.pointer);
  }

  /// readValueForDescriptor:
  void readValueForDescriptor(CBDescriptor descriptor) {
    objc.checkOsVersionInternal('CBPeripheral.readValueForDescriptor:',
        macOS: (false, (10, 7, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_readValueForDescriptor_, descriptor.ref.pointer);
  }

  /// writeValue:forDescriptor:
  void writeValue$1(objc.NSData data, {required CBDescriptor forDescriptor}) {
    objc.checkOsVersionInternal('CBPeripheral.writeValue:forDescriptor:',
        macOS: (false, (10, 7, 0)));
    _objc_msgSend_pfv6jd(this.ref.pointer, _sel_writeValue_forDescriptor_,
        data.ref.pointer, forDescriptor.ref.pointer);
  }

  /// openL2CAPChannel:
  void openL2CAPChannel(int PSM) {
    objc.checkOsVersionInternal('CBPeripheral.openL2CAPChannel:',
        macOS: (false, (10, 14, 0)));
    _objc_msgSend_15f11yh(this.ref.pointer, _sel_openL2CAPChannel_, PSM);
  }

  /// init
  CBPeripheral init() {
    objc.checkOsVersionInternal('CBPeripheral.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return CBPeripheral.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static CBPeripheral new$() {
    final _ret = _objc_msgSend_151sglz(_class_CBPeripheral, _sel_new);
    return CBPeripheral.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static CBPeripheral allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_CBPeripheral, _sel_allocWithZone_, zone);
    return CBPeripheral.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static CBPeripheral alloc() {
    final _ret = _objc_msgSend_151sglz(_class_CBPeripheral, _sel_alloc);
    return CBPeripheral.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  CBPeripheral self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return CBPeripheral.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  CBPeripheral retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return CBPeripheral.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  CBPeripheral autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return CBPeripheral.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of CBPeripheral constructed with the default `new` method.
  factory CBPeripheral() => new$();
}

late final _sel_centralManager_didDiscoverPeripheral_advertisementData_RSSI_ =
    objc.registerName(
        "centralManager:didDiscoverPeripheral:advertisementData:RSSI:");
void
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSDictionary_NSNumber_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3,
            ffi.Pointer<objc.ObjCObject> arg4) =>
        block.ref.target
                .cast<
                    ffi.NativeFunction<
                        ffi.Void Function(
                            ffi.Pointer<ffi.Void> arg0,
                            ffi.Pointer<objc.ObjCObject> arg1,
                            ffi.Pointer<objc.ObjCObject> arg2,
                            ffi.Pointer<objc.ObjCObject> arg3,
                            ffi.Pointer<objc.ObjCObject> arg4)>>()
                .asFunction<
                    void Function(
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>()(
            arg0, arg1, arg2, arg3, arg4);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSDictionary_NSNumber_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSDictionary_NSNumber_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSDictionary_NSNumber_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3,
            ffi.Pointer<objc.ObjCObject> arg4) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3, arg4);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSDictionary_NSNumber_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSDictionary_NSNumber_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSDictionary_NSNumber_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3,
        ffi.Pointer<objc.ObjCObject> arg4) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3, arg4);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSDictionary_NSNumber_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSDictionary_NSNumber_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSDictionary_NSNumber_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3,
        ffi.Pointer<objc.ObjCObject> arg4) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3, arg4);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSDictionary_NSNumber_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSDictionary_NSNumber_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSDictionary_NSNumber_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSDictionary_NSNumber_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral, objc.NSDictionary, objc.NSNumber)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSDictionary_NSNumber {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager,
              CBPeripheral, objc.NSDictionary, objc.NSNumber)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  CBCentralManager,
                  CBPeripheral,
                  objc.NSDictionary,
                  objc.NSNumber)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager,
              CBPeripheral, objc.NSDictionary, objc.NSNumber)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3, ffi.Pointer<objc.ObjCObject> arg4)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager,
                      CBPeripheral, objc.NSDictionary, objc.NSNumber)>(
              objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSDictionary_NSNumber_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral, objc.NSDictionary, objc.NSNumber)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral, objc.NSDictionary, objc.NSNumber) fn, {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral, objc.NSDictionary, objc.NSNumber)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSDictionary_NSNumber_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3, ffi.Pointer<objc.ObjCObject> arg4) => fn(
                      arg0,
                      CBCentralManager.castFromPointer(arg1, retain: true, release: true),
                      CBPeripheral.castFromPointer(arg2, retain: true, release: true),
                      objc.NSDictionary.castFromPointer(arg3, retain: true, release: true),
                      objc.NSNumber.castFromPointer(arg4, retain: true, release: true)),
                  keepIsolateAlive),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral,
          objc.NSDictionary, objc.NSNumber)> listener(
      void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral,
              objc.NSDictionary, objc.NSNumber)
          fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSDictionary_NSNumber_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3,
                ffi.Pointer<objc.ObjCObject> arg4) =>
            fn(
                arg0,
                CBCentralManager.castFromPointer(arg1,
                    retain: false, release: true),
                CBPeripheral.castFromPointer(arg2,
                    retain: false, release: true),
                objc.NSDictionary.castFromPointer(arg3,
                    retain: false, release: true),
                objc.NSNumber.castFromPointer(arg4,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _CoreBluetooth_wrapListenerBlock_8jfq1p(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            CBCentralManager,
            CBPeripheral,
            objc.NSDictionary,
            objc.NSNumber)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral,
          objc.NSDictionary, objc.NSNumber)> blocking(
      void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral,
              objc.NSDictionary, objc.NSNumber)
          fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSDictionary_NSNumber_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3,
                ffi.Pointer<objc.ObjCObject> arg4) =>
            fn(
                arg0,
                CBCentralManager.castFromPointer(arg1,
                    retain: false, release: true),
                CBPeripheral.castFromPointer(arg2,
                    retain: false, release: true),
                objc.NSDictionary.castFromPointer(arg3,
                    retain: false, release: true),
                objc.NSNumber.castFromPointer(arg4,
                    retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSDictionary_NSNumber_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3,
                ffi.Pointer<objc.ObjCObject> arg4) =>
            fn(
                arg0,
                CBCentralManager.castFromPointer(arg1,
                    retain: false, release: true),
                CBPeripheral.castFromPointer(arg2,
                    retain: false, release: true),
                objc.NSDictionary.castFromPointer(arg3,
                    retain: false, release: true),
                objc.NSNumber.castFromPointer(arg4,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _CoreBluetooth_wrapBlockingBlock_8jfq1p(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            CBCentralManager,
            CBPeripheral,
            objc.NSDictionary,
            objc.NSNumber)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral, objc.NSDictionary, objc.NSNumber)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSDictionary_NSNumber_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral,
            objc.NSDictionary, objc.NSNumber)> {
  void call(ffi.Pointer<ffi.Void> arg0, CBCentralManager arg1,
          CBPeripheral arg2, objc.NSDictionary arg3, objc.NSNumber arg4) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<objc.ObjCObject> arg3,
                          ffi.Pointer<objc.ObjCObject> arg4)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer,
          arg0,
          arg1.ref.pointer,
          arg2.ref.pointer,
          arg3.ref.pointer,
          arg4.ref.pointer);
}

late final _sel_centralManager_didConnectPeripheral_ =
    objc.registerName("centralManager:didConnectPeripheral:");
void _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager,
                  CBPeripheral)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                      arg0,
                      CBCentralManager.castFromPointer(arg1, retain: true, release: true),
                      CBPeripheral.castFromPointer(arg2, retain: true, release: true)),
                  keepIsolateAlive),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral)> listener(
      void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                CBCentralManager.castFromPointer(arg1,
                    retain: false, release: true),
                CBPeripheral.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _CoreBluetooth_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager,
            CBPeripheral)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral)> blocking(
      void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                CBCentralManager.castFromPointer(arg1,
                    retain: false, release: true),
                CBPeripheral.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                CBCentralManager.castFromPointer(arg1,
                    retain: false, release: true),
                CBPeripheral.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _CoreBluetooth_wrapBlockingBlock_fjrv01(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager,
            CBPeripheral)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral)> {
  void call(ffi.Pointer<ffi.Void> arg0, CBCentralManager arg1,
          CBPeripheral arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_centralManager_didFailToConnectPeripheral_error_ =
    objc.registerName("centralManager:didFailToConnectPeripheral:error:");
void
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2,
                        ffi.Pointer<objc.ObjCObject> arg3)>>()
            .asFunction<
                void Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager,
              CBPeripheral, objc.NSError?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  CBCentralManager,
                  CBPeripheral,
                  objc.NSError?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager,
              CBPeripheral, objc.NSError?)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager,
                      CBPeripheral, objc.NSError?)>(
              objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral, objc.NSError?)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral, objc.NSError?) fn, {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral, objc.NSError?)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3) => fn(
                      arg0,
                      CBCentralManager.castFromPointer(arg1, retain: true, release: true),
                      CBPeripheral.castFromPointer(arg2, retain: true, release: true),
                      arg3.address == 0 ? null : objc.NSError.castFromPointer(arg3, retain: true, release: true)),
                  keepIsolateAlive),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral,
          objc.NSError?)> listener(
      void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral,
              objc.NSError?)
          fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                CBCentralManager.castFromPointer(arg1,
                    retain: false, release: true),
                CBPeripheral.castFromPointer(arg2,
                    retain: false, release: true),
                arg3.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg3,
                        retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _CoreBluetooth_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral,
            objc.NSError?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral,
          objc.NSError?)> blocking(
      void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral,
              objc.NSError?)
          fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                CBCentralManager.castFromPointer(arg1,
                    retain: false, release: true),
                CBPeripheral.castFromPointer(arg2,
                    retain: false, release: true),
                arg3.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg3,
                        retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                CBCentralManager.castFromPointer(arg1,
                    retain: false, release: true),
                CBPeripheral.castFromPointer(arg2,
                    retain: false, release: true),
                arg3.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg3,
                        retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _CoreBluetooth_wrapBlockingBlock_1tz5yf(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral,
            objc.NSError?)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral,
            objc.NSError?)> {
  void call(ffi.Pointer<ffi.Void> arg0, CBCentralManager arg1,
          CBPeripheral arg2, objc.NSError? arg3) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<objc.ObjCObject> arg3)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0,
          arg1.ref.pointer, arg2.ref.pointer, arg3?.ref.pointer ?? ffi.nullptr);
}

late final _sel_centralManager_didDisconnectPeripheral_error_ =
    objc.registerName("centralManager:didDisconnectPeripheral:error:");
late final _sel_centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_ =
    objc.registerName(
        "centralManager:didDisconnectPeripheral:timestamp:isReconnecting:error:");
void
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_CFAbsoluteTime_bool_NSError_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            double arg3,
            bool arg4,
            ffi.Pointer<objc.ObjCObject> arg5) =>
        block.ref.target
                .cast<
                    ffi.NativeFunction<
                        ffi.Void Function(
                            ffi.Pointer<ffi.Void> arg0,
                            ffi.Pointer<objc.ObjCObject> arg1,
                            ffi.Pointer<objc.ObjCObject> arg2,
                            ffi.Double arg3,
                            ffi.Bool arg4,
                            ffi.Pointer<objc.ObjCObject> arg5)>>()
                .asFunction<
                    void Function(
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        double,
                        bool,
                        ffi.Pointer<objc.ObjCObject>)>()(
            arg0, arg1, arg2, arg3, arg4, arg5);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_CFAbsoluteTime_bool_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Double,
                    ffi.Bool,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_CFAbsoluteTime_bool_NSError_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_CFAbsoluteTime_bool_NSError_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            double arg3,
            bool arg4,
            ffi.Pointer<objc.ObjCObject> arg5) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            double,
            bool,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3, arg4, arg5);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_CFAbsoluteTime_bool_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Double,
                    ffi.Bool,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_CFAbsoluteTime_bool_NSError_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_CFAbsoluteTime_bool_NSError_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        double arg3,
        bool arg4,
        ffi.Pointer<objc.ObjCObject> arg5) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      double,
      bool,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3, arg4, arg5);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Double,
            ffi.Bool,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_CFAbsoluteTime_bool_NSError_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Double,
                ffi.Bool,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_CFAbsoluteTime_bool_NSError_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_CFAbsoluteTime_bool_NSError_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        double arg3,
        bool arg4,
        ffi.Pointer<objc.ObjCObject> arg5) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        double,
        bool,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3, arg4, arg5);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Double,
            ffi.Bool,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_CFAbsoluteTime_bool_NSError_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Double,
                ffi.Bool,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_CFAbsoluteTime_bool_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Double,
            ffi.Bool,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_CFAbsoluteTime_bool_NSError_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Double,
                ffi.Bool,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_CFAbsoluteTime_bool_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral, ffi.Double, ffi.Bool, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_CFAbsoluteTime_bool_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager,
              CBPeripheral, ffi.Double, ffi.Bool, objc.NSError?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  CBCentralManager,
                  CBPeripheral,
                  ffi.Double,
                  ffi.Bool,
                  objc.NSError?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CBCentralManager,
          CBPeripheral,
          ffi.Double,
          ffi.Bool,
          objc.NSError?)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Double arg3, ffi.Bool arg4, ffi.Pointer<objc.ObjCObject> arg5)>> ptr) =>
      objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager,
                  CBPeripheral, ffi.Double, ffi.Bool, objc.NSError?)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_CFAbsoluteTime_bool_NSError_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral, ffi.Double, ffi.Bool, objc.NSError?)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral, double, bool, objc.NSError?) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral, ffi.Double, ffi.Bool, objc.NSError?)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_CFAbsoluteTime_bool_NSError_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          double arg3,
                          bool arg4,
                          ffi.Pointer<objc.ObjCObject> arg5) =>
                      fn(arg0, CBCentralManager.castFromPointer(arg1, retain: true, release: true), CBPeripheral.castFromPointer(arg2, retain: true, release: true), arg3, arg4, arg5.address == 0 ? null : objc.NSError.castFromPointer(arg5, retain: true, release: true)),
                  keepIsolateAlive),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral,
          ffi.Double, ffi.Bool, objc.NSError?)> listener(
      void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral,
              double, bool, objc.NSError?)
          fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_CFAbsoluteTime_bool_NSError_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                double arg3,
                bool arg4,
                ffi.Pointer<objc.ObjCObject> arg5) =>
            fn(
                arg0,
                CBCentralManager.castFromPointer(arg1,
                    retain: false, release: true),
                CBPeripheral.castFromPointer(arg2,
                    retain: false, release: true),
                arg3,
                arg4,
                arg5.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg5,
                        retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _CoreBluetooth_wrapListenerBlock_o4q9mk(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            CBCentralManager,
            CBPeripheral,
            ffi.Double,
            ffi.Bool,
            objc.NSError?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral,
          ffi.Double, ffi.Bool, objc.NSError?)> blocking(
      void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral,
              double, bool, objc.NSError?)
          fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_CFAbsoluteTime_bool_NSError_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                double arg3,
                bool arg4,
                ffi.Pointer<objc.ObjCObject> arg5) =>
            fn(
                arg0,
                CBCentralManager.castFromPointer(arg1,
                    retain: false, release: true),
                CBPeripheral.castFromPointer(arg2,
                    retain: false, release: true),
                arg3,
                arg4,
                arg5.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg5,
                        retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_CFAbsoluteTime_bool_NSError_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                double arg3,
                bool arg4,
                ffi.Pointer<objc.ObjCObject> arg5) =>
            fn(
                arg0,
                CBCentralManager.castFromPointer(arg1,
                    retain: false, release: true),
                CBPeripheral.castFromPointer(arg2,
                    retain: false, release: true),
                arg3,
                arg4,
                arg5.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg5,
                        retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _CoreBluetooth_wrapBlockingBlock_o4q9mk(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            CBCentralManager,
            CBPeripheral,
            ffi.Double,
            ffi.Bool,
            objc.NSError?)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral, ffi.Double, ffi.Bool, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_CFAbsoluteTime_bool_NSError_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral,
            ffi.Double, ffi.Bool, objc.NSError?)> {
  void call(ffi.Pointer<ffi.Void> arg0, CBCentralManager arg1,
          CBPeripheral arg2, double arg3, bool arg4, objc.NSError? arg5) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Double arg3,
                          ffi.Bool arg4,
                          ffi.Pointer<objc.ObjCObject> arg5)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      double,
                      bool,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer,
          arg0,
          arg1.ref.pointer,
          arg2.ref.pointer,
          arg3,
          arg4,
          arg5?.ref.pointer ?? ffi.nullptr);
}

late final _sel_centralManager_connectionEventDidOccur_forPeripheral_ =
    objc.registerName("centralManager:connectionEventDidOccur:forPeripheral:");
void
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBConnectionEvent_CBPeripheral_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            int arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Long arg2,
                        ffi.Pointer<objc.ObjCObject> arg3)>>()
            .asFunction<
                void Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    int,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBConnectionEvent_CBPeripheral_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Long,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBConnectionEvent_CBPeripheral_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBConnectionEvent_CBPeripheral_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            int arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBConnectionEvent_CBPeripheral_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Long,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBConnectionEvent_CBPeripheral_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBConnectionEvent_CBPeripheral_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        int arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      int,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Long,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBConnectionEvent_CBPeripheral_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Long,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBConnectionEvent_CBPeripheral_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBConnectionEvent_CBPeripheral_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        int arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Long,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBConnectionEvent_CBPeripheral_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Long,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBConnectionEvent_CBPeripheral_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Long,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBConnectionEvent_CBPeripheral_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Long,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBConnectionEvent_CBPeripheral_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, ffi.Long, CBPeripheral)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBConnectionEvent_CBPeripheral {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, CBCentralManager, ffi.Long, CBPeripheral)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  CBCentralManager,
                  ffi.Long,
                  CBPeripheral)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, ffi.Long, CBPeripheral)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Long arg2, ffi.Pointer<objc.ObjCObject> arg3)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager,
                      ffi.Long, CBPeripheral)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBConnectionEvent_CBPeripheral_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, ffi.Long, CBPeripheral)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBConnectionEvent, CBPeripheral) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, ffi.Long, CBPeripheral)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBConnectionEvent_CBPeripheral_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, int arg2, ffi.Pointer<objc.ObjCObject> arg3) => fn(
                      arg0,
                      CBCentralManager.castFromPointer(arg1, retain: true, release: true),
                      CBConnectionEvent.fromValue(arg2),
                      CBPeripheral.castFromPointer(arg3, retain: true, release: true)),
                  keepIsolateAlive),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, CBCentralManager, ffi.Long, CBPeripheral)>
      listener(
          void Function(ffi.Pointer<ffi.Void>, CBCentralManager,
                  CBConnectionEvent, CBPeripheral)
              fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBConnectionEvent_CBPeripheral_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                int arg2, ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                CBCentralManager.castFromPointer(arg1,
                    retain: false, release: true),
                CBConnectionEvent.fromValue(arg2),
                CBPeripheral.castFromPointer(arg3,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _CoreBluetooth_wrapListenerBlock_5ut4yu(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, ffi.Long,
            CBPeripheral)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, CBCentralManager, ffi.Long, CBPeripheral)>
      blocking(
          void Function(ffi.Pointer<ffi.Void>, CBCentralManager,
                  CBConnectionEvent, CBPeripheral)
              fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBConnectionEvent_CBPeripheral_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                int arg2, ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                CBCentralManager.castFromPointer(arg1,
                    retain: false, release: true),
                CBConnectionEvent.fromValue(arg2),
                CBPeripheral.castFromPointer(arg3,
                    retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBConnectionEvent_CBPeripheral_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                int arg2, ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                CBCentralManager.castFromPointer(arg1,
                    retain: false, release: true),
                CBConnectionEvent.fromValue(arg2),
                CBPeripheral.castFromPointer(arg3,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _CoreBluetooth_wrapBlockingBlock_5ut4yu(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, ffi.Long,
            CBPeripheral)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, ffi.Long, CBPeripheral)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBConnectionEvent_CBPeripheral_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>, CBCentralManager, ffi.Long, CBPeripheral)> {
  void call(ffi.Pointer<ffi.Void> arg0, CBCentralManager arg1,
          CBConnectionEvent arg2, CBPeripheral arg3) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Long arg2,
                          ffi.Pointer<objc.ObjCObject> arg3)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      int,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer, arg2.value, arg3.ref.pointer);
}

late final _sel_centralManager_didUpdateANCSAuthorizationForPeripheral_ = objc
    .registerName("centralManager:didUpdateANCSAuthorizationForPeripheral:");

/// CBCentralManagerDelegate
interface class CBCentralManagerDelegate extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  CBCentralManagerDelegate._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [CBCentralManagerDelegate] that points to the same underlying object as [other].
  CBCentralManagerDelegate.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CBCentralManagerDelegate] that wraps the given raw object pointer.
  CBCentralManagerDelegate.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CBCentralManagerDelegate].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(obj.ref.pointer, _sel_conformsToProtocol_,
        _protocol_CBCentralManagerDelegate);
  }

  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_CBCentralManagerDelegate.cast());

  /// Builds an object that implements the CBCentralManagerDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static CBCentralManagerDelegate implement(
      {required void Function(CBCentralManager) centralManagerDidUpdateState_,
      void Function(CBCentralManager, objc.NSDictionary)?
          centralManager_willRestoreState_,
      void Function(
              CBCentralManager, CBPeripheral, objc.NSDictionary, objc.NSNumber)?
          centralManager_didDiscoverPeripheral_advertisementData_RSSI_,
      void Function(CBCentralManager, CBPeripheral)?
          centralManager_didConnectPeripheral_,
      void Function(CBCentralManager, CBPeripheral, objc.NSError?)?
          centralManager_didFailToConnectPeripheral_error_,
      void Function(CBCentralManager, CBPeripheral, objc.NSError?)?
          centralManager_didDisconnectPeripheral_error_,
      void Function(
              CBCentralManager, CBPeripheral, double, bool, objc.NSError?)?
          centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_,
      void Function(CBCentralManager, CBConnectionEvent, CBPeripheral)?
          centralManager_connectionEventDidOccur_forPeripheral_,
      void Function(CBCentralManager, CBPeripheral)?
          centralManager_didUpdateANCSAuthorizationForPeripheral_,
      bool $keepIsolateAlive = true}) {
    final builder =
        objc.ObjCProtocolBuilder(debugName: 'CBCentralManagerDelegate');
    CBCentralManagerDelegate.centralManagerDidUpdateState_
        .implement(builder, centralManagerDidUpdateState_);
    CBCentralManagerDelegate.centralManager_willRestoreState_
        .implement(builder, centralManager_willRestoreState_);
    CBCentralManagerDelegate
        .centralManager_didDiscoverPeripheral_advertisementData_RSSI_
        .implement(builder,
            centralManager_didDiscoverPeripheral_advertisementData_RSSI_);
    CBCentralManagerDelegate.centralManager_didConnectPeripheral_
        .implement(builder, centralManager_didConnectPeripheral_);
    CBCentralManagerDelegate.centralManager_didFailToConnectPeripheral_error_
        .implement(builder, centralManager_didFailToConnectPeripheral_error_);
    CBCentralManagerDelegate.centralManager_didDisconnectPeripheral_error_
        .implement(builder, centralManager_didDisconnectPeripheral_error_);
    CBCentralManagerDelegate
        .centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_
        .implement(builder,
            centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_);
    CBCentralManagerDelegate
        .centralManager_connectionEventDidOccur_forPeripheral_
        .implement(
            builder, centralManager_connectionEventDidOccur_forPeripheral_);
    CBCentralManagerDelegate
        .centralManager_didUpdateANCSAuthorizationForPeripheral_
        .implement(
            builder, centralManager_didUpdateANCSAuthorizationForPeripheral_);
    builder.addProtocol($protocol);
    return CBCentralManagerDelegate.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the CBCentralManagerDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(objc.ObjCProtocolBuilder builder,
      {required void Function(CBCentralManager) centralManagerDidUpdateState_,
      void Function(CBCentralManager, objc.NSDictionary)?
          centralManager_willRestoreState_,
      void Function(
              CBCentralManager, CBPeripheral, objc.NSDictionary, objc.NSNumber)?
          centralManager_didDiscoverPeripheral_advertisementData_RSSI_,
      void Function(CBCentralManager, CBPeripheral)?
          centralManager_didConnectPeripheral_,
      void Function(CBCentralManager, CBPeripheral, objc.NSError?)?
          centralManager_didFailToConnectPeripheral_error_,
      void Function(CBCentralManager, CBPeripheral, objc.NSError?)?
          centralManager_didDisconnectPeripheral_error_,
      void Function(
              CBCentralManager, CBPeripheral, double, bool, objc.NSError?)?
          centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_,
      void Function(CBCentralManager, CBConnectionEvent, CBPeripheral)?
          centralManager_connectionEventDidOccur_forPeripheral_,
      void Function(CBCentralManager, CBPeripheral)?
          centralManager_didUpdateANCSAuthorizationForPeripheral_,
      bool $keepIsolateAlive = true}) {
    CBCentralManagerDelegate.centralManagerDidUpdateState_
        .implement(builder, centralManagerDidUpdateState_);
    CBCentralManagerDelegate.centralManager_willRestoreState_
        .implement(builder, centralManager_willRestoreState_);
    CBCentralManagerDelegate
        .centralManager_didDiscoverPeripheral_advertisementData_RSSI_
        .implement(builder,
            centralManager_didDiscoverPeripheral_advertisementData_RSSI_);
    CBCentralManagerDelegate.centralManager_didConnectPeripheral_
        .implement(builder, centralManager_didConnectPeripheral_);
    CBCentralManagerDelegate.centralManager_didFailToConnectPeripheral_error_
        .implement(builder, centralManager_didFailToConnectPeripheral_error_);
    CBCentralManagerDelegate.centralManager_didDisconnectPeripheral_error_
        .implement(builder, centralManager_didDisconnectPeripheral_error_);
    CBCentralManagerDelegate
        .centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_
        .implement(builder,
            centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_);
    CBCentralManagerDelegate
        .centralManager_connectionEventDidOccur_forPeripheral_
        .implement(
            builder, centralManager_connectionEventDidOccur_forPeripheral_);
    CBCentralManagerDelegate
        .centralManager_didUpdateANCSAuthorizationForPeripheral_
        .implement(
            builder, centralManager_didUpdateANCSAuthorizationForPeripheral_);
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the CBCentralManagerDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static CBCentralManagerDelegate implementAsListener(
      {required void Function(CBCentralManager) centralManagerDidUpdateState_,
      void Function(CBCentralManager, objc.NSDictionary)?
          centralManager_willRestoreState_,
      void Function(
              CBCentralManager, CBPeripheral, objc.NSDictionary, objc.NSNumber)?
          centralManager_didDiscoverPeripheral_advertisementData_RSSI_,
      void Function(CBCentralManager, CBPeripheral)?
          centralManager_didConnectPeripheral_,
      void Function(CBCentralManager, CBPeripheral, objc.NSError?)?
          centralManager_didFailToConnectPeripheral_error_,
      void Function(CBCentralManager, CBPeripheral, objc.NSError?)?
          centralManager_didDisconnectPeripheral_error_,
      void Function(
              CBCentralManager, CBPeripheral, double, bool, objc.NSError?)?
          centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_,
      void Function(CBCentralManager, CBConnectionEvent, CBPeripheral)?
          centralManager_connectionEventDidOccur_forPeripheral_,
      void Function(CBCentralManager, CBPeripheral)?
          centralManager_didUpdateANCSAuthorizationForPeripheral_,
      bool $keepIsolateAlive = true}) {
    final builder =
        objc.ObjCProtocolBuilder(debugName: 'CBCentralManagerDelegate');
    CBCentralManagerDelegate.centralManagerDidUpdateState_
        .implementAsListener(builder, centralManagerDidUpdateState_);
    CBCentralManagerDelegate.centralManager_willRestoreState_
        .implementAsListener(builder, centralManager_willRestoreState_);
    CBCentralManagerDelegate
        .centralManager_didDiscoverPeripheral_advertisementData_RSSI_
        .implementAsListener(builder,
            centralManager_didDiscoverPeripheral_advertisementData_RSSI_);
    CBCentralManagerDelegate.centralManager_didConnectPeripheral_
        .implementAsListener(builder, centralManager_didConnectPeripheral_);
    CBCentralManagerDelegate.centralManager_didFailToConnectPeripheral_error_
        .implementAsListener(
            builder, centralManager_didFailToConnectPeripheral_error_);
    CBCentralManagerDelegate.centralManager_didDisconnectPeripheral_error_
        .implementAsListener(
            builder, centralManager_didDisconnectPeripheral_error_);
    CBCentralManagerDelegate
        .centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_
        .implementAsListener(builder,
            centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_);
    CBCentralManagerDelegate
        .centralManager_connectionEventDidOccur_forPeripheral_
        .implementAsListener(
            builder, centralManager_connectionEventDidOccur_forPeripheral_);
    CBCentralManagerDelegate
        .centralManager_didUpdateANCSAuthorizationForPeripheral_
        .implementAsListener(
            builder, centralManager_didUpdateANCSAuthorizationForPeripheral_);
    builder.addProtocol($protocol);
    return CBCentralManagerDelegate.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the CBCentralManagerDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as listeners will
  /// be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsListener(objc.ObjCProtocolBuilder builder,
      {required void Function(CBCentralManager) centralManagerDidUpdateState_,
      void Function(CBCentralManager, objc.NSDictionary)?
          centralManager_willRestoreState_,
      void Function(
              CBCentralManager, CBPeripheral, objc.NSDictionary, objc.NSNumber)?
          centralManager_didDiscoverPeripheral_advertisementData_RSSI_,
      void Function(CBCentralManager, CBPeripheral)?
          centralManager_didConnectPeripheral_,
      void Function(CBCentralManager, CBPeripheral, objc.NSError?)?
          centralManager_didFailToConnectPeripheral_error_,
      void Function(CBCentralManager, CBPeripheral, objc.NSError?)?
          centralManager_didDisconnectPeripheral_error_,
      void Function(
              CBCentralManager, CBPeripheral, double, bool, objc.NSError?)?
          centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_,
      void Function(CBCentralManager, CBConnectionEvent, CBPeripheral)?
          centralManager_connectionEventDidOccur_forPeripheral_,
      void Function(CBCentralManager, CBPeripheral)?
          centralManager_didUpdateANCSAuthorizationForPeripheral_,
      bool $keepIsolateAlive = true}) {
    CBCentralManagerDelegate.centralManagerDidUpdateState_
        .implementAsListener(builder, centralManagerDidUpdateState_);
    CBCentralManagerDelegate.centralManager_willRestoreState_
        .implementAsListener(builder, centralManager_willRestoreState_);
    CBCentralManagerDelegate
        .centralManager_didDiscoverPeripheral_advertisementData_RSSI_
        .implementAsListener(builder,
            centralManager_didDiscoverPeripheral_advertisementData_RSSI_);
    CBCentralManagerDelegate.centralManager_didConnectPeripheral_
        .implementAsListener(builder, centralManager_didConnectPeripheral_);
    CBCentralManagerDelegate.centralManager_didFailToConnectPeripheral_error_
        .implementAsListener(
            builder, centralManager_didFailToConnectPeripheral_error_);
    CBCentralManagerDelegate.centralManager_didDisconnectPeripheral_error_
        .implementAsListener(
            builder, centralManager_didDisconnectPeripheral_error_);
    CBCentralManagerDelegate
        .centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_
        .implementAsListener(builder,
            centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_);
    CBCentralManagerDelegate
        .centralManager_connectionEventDidOccur_forPeripheral_
        .implementAsListener(
            builder, centralManager_connectionEventDidOccur_forPeripheral_);
    CBCentralManagerDelegate
        .centralManager_didUpdateANCSAuthorizationForPeripheral_
        .implementAsListener(
            builder, centralManager_didUpdateANCSAuthorizationForPeripheral_);
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the CBCentralManagerDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as blocking listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static CBCentralManagerDelegate implementAsBlocking(
      {required void Function(CBCentralManager) centralManagerDidUpdateState_,
      void Function(CBCentralManager, objc.NSDictionary)?
          centralManager_willRestoreState_,
      void Function(
              CBCentralManager, CBPeripheral, objc.NSDictionary, objc.NSNumber)?
          centralManager_didDiscoverPeripheral_advertisementData_RSSI_,
      void Function(CBCentralManager, CBPeripheral)?
          centralManager_didConnectPeripheral_,
      void Function(CBCentralManager, CBPeripheral, objc.NSError?)?
          centralManager_didFailToConnectPeripheral_error_,
      void Function(CBCentralManager, CBPeripheral, objc.NSError?)?
          centralManager_didDisconnectPeripheral_error_,
      void Function(
              CBCentralManager, CBPeripheral, double, bool, objc.NSError?)?
          centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_,
      void Function(CBCentralManager, CBConnectionEvent, CBPeripheral)?
          centralManager_connectionEventDidOccur_forPeripheral_,
      void Function(CBCentralManager, CBPeripheral)?
          centralManager_didUpdateANCSAuthorizationForPeripheral_,
      bool $keepIsolateAlive = true}) {
    final builder =
        objc.ObjCProtocolBuilder(debugName: 'CBCentralManagerDelegate');
    CBCentralManagerDelegate.centralManagerDidUpdateState_
        .implementAsBlocking(builder, centralManagerDidUpdateState_);
    CBCentralManagerDelegate.centralManager_willRestoreState_
        .implementAsBlocking(builder, centralManager_willRestoreState_);
    CBCentralManagerDelegate
        .centralManager_didDiscoverPeripheral_advertisementData_RSSI_
        .implementAsBlocking(builder,
            centralManager_didDiscoverPeripheral_advertisementData_RSSI_);
    CBCentralManagerDelegate.centralManager_didConnectPeripheral_
        .implementAsBlocking(builder, centralManager_didConnectPeripheral_);
    CBCentralManagerDelegate.centralManager_didFailToConnectPeripheral_error_
        .implementAsBlocking(
            builder, centralManager_didFailToConnectPeripheral_error_);
    CBCentralManagerDelegate.centralManager_didDisconnectPeripheral_error_
        .implementAsBlocking(
            builder, centralManager_didDisconnectPeripheral_error_);
    CBCentralManagerDelegate
        .centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_
        .implementAsBlocking(builder,
            centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_);
    CBCentralManagerDelegate
        .centralManager_connectionEventDidOccur_forPeripheral_
        .implementAsBlocking(
            builder, centralManager_connectionEventDidOccur_forPeripheral_);
    CBCentralManagerDelegate
        .centralManager_didUpdateANCSAuthorizationForPeripheral_
        .implementAsBlocking(
            builder, centralManager_didUpdateANCSAuthorizationForPeripheral_);
    builder.addProtocol($protocol);
    return CBCentralManagerDelegate.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the CBCentralManagerDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as blocking
  /// listeners will be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsBlocking(objc.ObjCProtocolBuilder builder,
      {required void Function(CBCentralManager) centralManagerDidUpdateState_,
      void Function(CBCentralManager, objc.NSDictionary)?
          centralManager_willRestoreState_,
      void Function(
              CBCentralManager, CBPeripheral, objc.NSDictionary, objc.NSNumber)?
          centralManager_didDiscoverPeripheral_advertisementData_RSSI_,
      void Function(CBCentralManager, CBPeripheral)?
          centralManager_didConnectPeripheral_,
      void Function(CBCentralManager, CBPeripheral, objc.NSError?)?
          centralManager_didFailToConnectPeripheral_error_,
      void Function(CBCentralManager, CBPeripheral, objc.NSError?)?
          centralManager_didDisconnectPeripheral_error_,
      void Function(
              CBCentralManager, CBPeripheral, double, bool, objc.NSError?)?
          centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_,
      void Function(CBCentralManager, CBConnectionEvent, CBPeripheral)?
          centralManager_connectionEventDidOccur_forPeripheral_,
      void Function(CBCentralManager, CBPeripheral)?
          centralManager_didUpdateANCSAuthorizationForPeripheral_,
      bool $keepIsolateAlive = true}) {
    CBCentralManagerDelegate.centralManagerDidUpdateState_
        .implementAsBlocking(builder, centralManagerDidUpdateState_);
    CBCentralManagerDelegate.centralManager_willRestoreState_
        .implementAsBlocking(builder, centralManager_willRestoreState_);
    CBCentralManagerDelegate
        .centralManager_didDiscoverPeripheral_advertisementData_RSSI_
        .implementAsBlocking(builder,
            centralManager_didDiscoverPeripheral_advertisementData_RSSI_);
    CBCentralManagerDelegate.centralManager_didConnectPeripheral_
        .implementAsBlocking(builder, centralManager_didConnectPeripheral_);
    CBCentralManagerDelegate.centralManager_didFailToConnectPeripheral_error_
        .implementAsBlocking(
            builder, centralManager_didFailToConnectPeripheral_error_);
    CBCentralManagerDelegate.centralManager_didDisconnectPeripheral_error_
        .implementAsBlocking(
            builder, centralManager_didDisconnectPeripheral_error_);
    CBCentralManagerDelegate
        .centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_
        .implementAsBlocking(builder,
            centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_);
    CBCentralManagerDelegate
        .centralManager_connectionEventDidOccur_forPeripheral_
        .implementAsBlocking(
            builder, centralManager_connectionEventDidOccur_forPeripheral_);
    CBCentralManagerDelegate
        .centralManager_didUpdateANCSAuthorizationForPeripheral_
        .implementAsBlocking(
            builder, centralManager_didUpdateANCSAuthorizationForPeripheral_);
    builder.addProtocol($protocol);
  }

  /// centralManagerDidUpdateState:
  static final centralManagerDidUpdateState_ =
      objc.ObjCProtocolListenableMethod<void Function(CBCentralManager)>(
    _protocol_CBCentralManagerDelegate,
    _sel_centralManagerDidUpdateState_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _CoreBluetooth_protocolTrampoline_18v1jvf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CBCentralManagerDelegate,
      _sel_centralManagerDidUpdateState_,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (void Function(CBCentralManager) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBCentralManager.fromFunction(
            (ffi.Pointer<ffi.Void> _, CBCentralManager arg1) => func(arg1)),
    (void Function(CBCentralManager) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBCentralManager.listener(
            (ffi.Pointer<ffi.Void> _, CBCentralManager arg1) => func(arg1)),
    (void Function(CBCentralManager) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBCentralManager.blocking(
            (ffi.Pointer<ffi.Void> _, CBCentralManager arg1) => func(arg1)),
  );

  /// centralManager:willRestoreState:
  static final centralManager_willRestoreState_ =
      objc.ObjCProtocolListenableMethod<
          void Function(CBCentralManager, objc.NSDictionary)>(
    _protocol_CBCentralManagerDelegate,
    _sel_centralManager_willRestoreState_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _CoreBluetooth_protocolTrampoline_fjrv01)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CBCentralManagerDelegate,
      _sel_centralManager_willRestoreState_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(CBCentralManager, objc.NSDictionary) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_NSDictionary.fromFunction(
            (ffi.Pointer<ffi.Void> _, CBCentralManager arg1,
                    objc.NSDictionary arg2) =>
                func(arg1, arg2)),
    (void Function(CBCentralManager, objc.NSDictionary) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_NSDictionary.listener(
            (ffi.Pointer<ffi.Void> _, CBCentralManager arg1,
                    objc.NSDictionary arg2) =>
                func(arg1, arg2)),
    (void Function(CBCentralManager, objc.NSDictionary) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_NSDictionary.blocking(
            (ffi.Pointer<ffi.Void> _, CBCentralManager arg1,
                    objc.NSDictionary arg2) =>
                func(arg1, arg2)),
  );

  /// centralManager:didDiscoverPeripheral:advertisementData:RSSI:
  static final centralManager_didDiscoverPeripheral_advertisementData_RSSI_ =
      objc.ObjCProtocolListenableMethod<
          void Function(CBCentralManager, CBPeripheral, objc.NSDictionary,
              objc.NSNumber)>(
    _protocol_CBCentralManagerDelegate,
    _sel_centralManager_didDiscoverPeripheral_advertisementData_RSSI_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _CoreBluetooth_protocolTrampoline_8jfq1p)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CBCentralManagerDelegate,
      _sel_centralManager_didDiscoverPeripheral_advertisementData_RSSI_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(CBCentralManager, CBPeripheral, objc.NSDictionary,
                objc.NSNumber)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSDictionary_NSNumber
            .fromFunction((ffi.Pointer<ffi.Void> _,
                    CBCentralManager arg1,
                    CBPeripheral arg2,
                    objc.NSDictionary arg3,
                    objc.NSNumber arg4) =>
                func(arg1, arg2, arg3, arg4)),
    (void Function(CBCentralManager, CBPeripheral, objc.NSDictionary,
                objc.NSNumber)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSDictionary_NSNumber
            .listener((ffi.Pointer<ffi.Void> _,
                    CBCentralManager arg1,
                    CBPeripheral arg2,
                    objc.NSDictionary arg3,
                    objc.NSNumber arg4) =>
                func(arg1, arg2, arg3, arg4)),
    (void Function(CBCentralManager, CBPeripheral, objc.NSDictionary,
                objc.NSNumber)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSDictionary_NSNumber
            .blocking((ffi.Pointer<ffi.Void> _,
                    CBCentralManager arg1,
                    CBPeripheral arg2,
                    objc.NSDictionary arg3,
                    objc.NSNumber arg4) =>
                func(arg1, arg2, arg3, arg4)),
  );

  /// centralManager:didConnectPeripheral:
  static final centralManager_didConnectPeripheral_ =
      objc.ObjCProtocolListenableMethod<
          void Function(CBCentralManager, CBPeripheral)>(
    _protocol_CBCentralManagerDelegate,
    _sel_centralManager_didConnectPeripheral_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _CoreBluetooth_protocolTrampoline_fjrv01)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CBCentralManagerDelegate,
      _sel_centralManager_didConnectPeripheral_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(CBCentralManager, CBPeripheral) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral.fromFunction(
            (ffi.Pointer<ffi.Void> _, CBCentralManager arg1,
                    CBPeripheral arg2) =>
                func(arg1, arg2)),
    (void Function(CBCentralManager, CBPeripheral) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral.listener(
            (ffi.Pointer<ffi.Void> _, CBCentralManager arg1,
                    CBPeripheral arg2) =>
                func(arg1, arg2)),
    (void Function(CBCentralManager, CBPeripheral) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral.blocking(
            (ffi.Pointer<ffi.Void> _, CBCentralManager arg1,
                    CBPeripheral arg2) =>
                func(arg1, arg2)),
  );

  /// centralManager:didFailToConnectPeripheral:error:
  static final centralManager_didFailToConnectPeripheral_error_ =
      objc.ObjCProtocolListenableMethod<
          void Function(CBCentralManager, CBPeripheral, objc.NSError?)>(
    _protocol_CBCentralManagerDelegate,
    _sel_centralManager_didFailToConnectPeripheral_error_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _CoreBluetooth_protocolTrampoline_1tz5yf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CBCentralManagerDelegate,
      _sel_centralManager_didFailToConnectPeripheral_error_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(CBCentralManager, CBPeripheral, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError
            .fromFunction((ffi.Pointer<ffi.Void> _, CBCentralManager arg1,
                    CBPeripheral arg2, objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(CBCentralManager, CBPeripheral, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError
            .listener((ffi.Pointer<ffi.Void> _, CBCentralManager arg1,
                    CBPeripheral arg2, objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(CBCentralManager, CBPeripheral, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError
            .blocking((ffi.Pointer<ffi.Void> _, CBCentralManager arg1,
                    CBPeripheral arg2, objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// centralManager:didDisconnectPeripheral:error:
  static final centralManager_didDisconnectPeripheral_error_ =
      objc.ObjCProtocolListenableMethod<
          void Function(CBCentralManager, CBPeripheral, objc.NSError?)>(
    _protocol_CBCentralManagerDelegate,
    _sel_centralManager_didDisconnectPeripheral_error_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _CoreBluetooth_protocolTrampoline_1tz5yf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CBCentralManagerDelegate,
      _sel_centralManager_didDisconnectPeripheral_error_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(CBCentralManager, CBPeripheral, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError
            .fromFunction((ffi.Pointer<ffi.Void> _, CBCentralManager arg1,
                    CBPeripheral arg2, objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(CBCentralManager, CBPeripheral, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError
            .listener((ffi.Pointer<ffi.Void> _, CBCentralManager arg1,
                    CBPeripheral arg2, objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(CBCentralManager, CBPeripheral, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError
            .blocking((ffi.Pointer<ffi.Void> _, CBCentralManager arg1,
                    CBPeripheral arg2, objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// centralManager:didDisconnectPeripheral:timestamp:isReconnecting:error:
  static final centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_ =
      objc.ObjCProtocolListenableMethod<
          void Function(
              CBCentralManager, CBPeripheral, double, bool, objc.NSError?)>(
    _protocol_CBCentralManagerDelegate,
    _sel_centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Double,
                        ffi.Bool,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _CoreBluetooth_protocolTrampoline_o4q9mk)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CBCentralManagerDelegate,
      _sel_centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(CBCentralManager, CBPeripheral, double, bool, objc.NSError?)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_CFAbsoluteTime_bool_NSError
            .fromFunction((ffi.Pointer<ffi.Void> _,
                    CBCentralManager arg1,
                    CBPeripheral arg2,
                    double arg3,
                    bool arg4,
                    objc.NSError? arg5) =>
                func(arg1, arg2, arg3, arg4, arg5)),
    (void Function(CBCentralManager, CBPeripheral, double, bool, objc.NSError?)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_CFAbsoluteTime_bool_NSError
            .listener((ffi.Pointer<ffi.Void> _,
                    CBCentralManager arg1,
                    CBPeripheral arg2,
                    double arg3,
                    bool arg4,
                    objc.NSError? arg5) =>
                func(arg1, arg2, arg3, arg4, arg5)),
    (void Function(CBCentralManager, CBPeripheral, double, bool, objc.NSError?)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_CFAbsoluteTime_bool_NSError
            .blocking((ffi.Pointer<ffi.Void> _,
                    CBCentralManager arg1,
                    CBPeripheral arg2,
                    double arg3,
                    bool arg4,
                    objc.NSError? arg5) =>
                func(arg1, arg2, arg3, arg4, arg5)),
  );

  /// centralManager:connectionEventDidOccur:forPeripheral:
  static final centralManager_connectionEventDidOccur_forPeripheral_ =
      objc.ObjCProtocolListenableMethod<
          void Function(CBCentralManager, CBConnectionEvent, CBPeripheral)>(
    _protocol_CBCentralManagerDelegate,
    _sel_centralManager_connectionEventDidOccur_forPeripheral_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Long,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _CoreBluetooth_protocolTrampoline_5ut4yu)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CBCentralManagerDelegate,
      _sel_centralManager_connectionEventDidOccur_forPeripheral_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(CBCentralManager, CBConnectionEvent, CBPeripheral) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBConnectionEvent_CBPeripheral
            .fromFunction((ffi.Pointer<ffi.Void> _, CBCentralManager arg1,
                    CBConnectionEvent arg2, CBPeripheral arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(CBCentralManager, CBConnectionEvent, CBPeripheral) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBConnectionEvent_CBPeripheral
            .listener((ffi.Pointer<ffi.Void> _, CBCentralManager arg1,
                    CBConnectionEvent arg2, CBPeripheral arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(CBCentralManager, CBConnectionEvent, CBPeripheral) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBConnectionEvent_CBPeripheral
            .blocking((ffi.Pointer<ffi.Void> _, CBCentralManager arg1,
                    CBConnectionEvent arg2, CBPeripheral arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// centralManager:didUpdateANCSAuthorizationForPeripheral:
  static final centralManager_didUpdateANCSAuthorizationForPeripheral_ =
      objc.ObjCProtocolListenableMethod<
          void Function(CBCentralManager, CBPeripheral)>(
    _protocol_CBCentralManagerDelegate,
    _sel_centralManager_didUpdateANCSAuthorizationForPeripheral_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _CoreBluetooth_protocolTrampoline_fjrv01)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CBCentralManagerDelegate,
      _sel_centralManager_didUpdateANCSAuthorizationForPeripheral_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(CBCentralManager, CBPeripheral) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral.fromFunction(
            (ffi.Pointer<ffi.Void> _, CBCentralManager arg1,
                    CBPeripheral arg2) =>
                func(arg1, arg2)),
    (void Function(CBCentralManager, CBPeripheral) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral.listener(
            (ffi.Pointer<ffi.Void> _, CBCentralManager arg1,
                    CBPeripheral arg2) =>
                func(arg1, arg2)),
    (void Function(CBCentralManager, CBPeripheral) func) =>
        ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral.blocking(
            (ffi.Pointer<ffi.Void> _, CBCentralManager arg1,
                    CBPeripheral arg2) =>
                func(arg1, arg2)),
  );
}

late final _sel_isScanning = objc.registerName("isScanning");
late final _sel_supportsFeatures_ = objc.registerName("supportsFeatures:");
final _objc_msgSend_172tl3q = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_initWithDelegate_queue_ =
    objc.registerName("initWithDelegate:queue:");
final _objc_msgSend_15qeuct = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_initWithDelegate_queue_options_ =
    objc.registerName("initWithDelegate:queue:options:");
final _objc_msgSend_11spmsz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_retrievePeripheralsWithIdentifiers_ =
    objc.registerName("retrievePeripheralsWithIdentifiers:");
late final _sel_retrieveConnectedPeripheralsWithServices_ =
    objc.registerName("retrieveConnectedPeripheralsWithServices:");
late final _sel_scanForPeripheralsWithServices_options_ =
    objc.registerName("scanForPeripheralsWithServices:options:");
late final _sel_stopScan = objc.registerName("stopScan");
late final _sel_connectPeripheral_options_ =
    objc.registerName("connectPeripheral:options:");
late final _sel_cancelPeripheralConnection_ =
    objc.registerName("cancelPeripheralConnection:");
late final _sel_registerForConnectionEventsWithOptions_ =
    objc.registerName("registerForConnectionEventsWithOptions:");

/// CBCentralManager
class CBCentralManager extends CBManager {
  CBCentralManager._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('CBCentralManager', macOS: (false, (10, 7, 0)));
  }

  /// Constructs a [CBCentralManager] that points to the same underlying object as [other].
  CBCentralManager.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CBCentralManager] that wraps the given raw object pointer.
  CBCentralManager.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CBCentralManager].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_CBCentralManager);
  }

  /// delegate
  CBCentralManagerDelegate? get delegate {
    objc.checkOsVersionInternal('CBCentralManager.delegate',
        macOS: (false, (10, 7, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_delegate);
    return _ret.address == 0
        ? null
        : CBCentralManagerDelegate.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// setDelegate:
  set delegate(CBCentralManagerDelegate? value) {
    objc.checkOsVersionInternal('CBCentralManager.setDelegate:',
        macOS: (false, (10, 7, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setDelegate_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// isScanning
  bool get isScanning {
    objc.checkOsVersionInternal('CBCentralManager.isScanning',
        macOS: (false, (10, 13, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isScanning);
  }

  /// supportsFeatures:
  static bool supportsFeatures(CBCentralManagerFeature features) {
    objc.checkOsVersionInternal('CBCentralManager.supportsFeatures:',
        iOS: (false, (13, 0, 0)), macOS: (true, null));
    return _objc_msgSend_172tl3q(
        _class_CBCentralManager, _sel_supportsFeatures_, features.value);
  }

  /// init
  CBCentralManager init() {
    objc.checkOsVersionInternal('CBCentralManager.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return CBCentralManager.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithDelegate:queue:
  CBCentralManager initWithDelegate(CBCentralManagerDelegate? delegate$1,
      {objc.NSObject? queue}) {
    objc.checkOsVersionInternal('CBCentralManager.initWithDelegate:queue:',
        macOS: (false, (10, 7, 0)));
    final _ret = _objc_msgSend_15qeuct(
        this.ref.retainAndReturnPointer(),
        _sel_initWithDelegate_queue_,
        delegate$1?.ref.pointer ?? ffi.nullptr,
        queue?.ref.pointer ?? ffi.nullptr);
    return CBCentralManager.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithDelegate:queue:options:
  CBCentralManager initWithDelegate$1(CBCentralManagerDelegate? delegate$1,
      {objc.NSObject? queue, objc.NSDictionary? options}) {
    objc.checkOsVersionInternal(
        'CBCentralManager.initWithDelegate:queue:options:',
        macOS: (false, (10, 9, 0)));
    final _ret = _objc_msgSend_11spmsz(
        this.ref.retainAndReturnPointer(),
        _sel_initWithDelegate_queue_options_,
        delegate$1?.ref.pointer ?? ffi.nullptr,
        queue?.ref.pointer ?? ffi.nullptr,
        options?.ref.pointer ?? ffi.nullptr);
    return CBCentralManager.castFromPointer(_ret, retain: false, release: true);
  }

  /// retrievePeripheralsWithIdentifiers:
  objc.NSArray retrievePeripheralsWithIdentifiers(objc.NSArray identifiers) {
    objc.checkOsVersionInternal(
        'CBCentralManager.retrievePeripheralsWithIdentifiers:',
        macOS: (false, (10, 9, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_retrievePeripheralsWithIdentifiers_, identifiers.ref.pointer);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// retrieveConnectedPeripheralsWithServices:
  objc.NSArray retrieveConnectedPeripheralsWithServices(
      objc.NSArray serviceUUIDs) {
    objc.checkOsVersionInternal(
        'CBCentralManager.retrieveConnectedPeripheralsWithServices:',
        macOS: (false, (10, 9, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer,
        _sel_retrieveConnectedPeripheralsWithServices_,
        serviceUUIDs.ref.pointer);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// scanForPeripheralsWithServices:options:
  void scanForPeripheralsWithServices(objc.NSArray? serviceUUIDs,
      {objc.NSDictionary? options}) {
    objc.checkOsVersionInternal(
        'CBCentralManager.scanForPeripheralsWithServices:options:',
        macOS: (false, (10, 7, 0)));
    _objc_msgSend_pfv6jd(
        this.ref.pointer,
        _sel_scanForPeripheralsWithServices_options_,
        serviceUUIDs?.ref.pointer ?? ffi.nullptr,
        options?.ref.pointer ?? ffi.nullptr);
  }

  /// stopScan
  void stopScan() {
    objc.checkOsVersionInternal('CBCentralManager.stopScan',
        macOS: (false, (10, 7, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_stopScan);
  }

  /// connectPeripheral:options:
  void connectPeripheral(CBPeripheral peripheral,
      {objc.NSDictionary? options}) {
    objc.checkOsVersionInternal('CBCentralManager.connectPeripheral:options:',
        macOS: (false, (10, 7, 0)));
    _objc_msgSend_pfv6jd(this.ref.pointer, _sel_connectPeripheral_options_,
        peripheral.ref.pointer, options?.ref.pointer ?? ffi.nullptr);
  }

  /// cancelPeripheralConnection:
  void cancelPeripheralConnection(CBPeripheral peripheral) {
    objc.checkOsVersionInternal('CBCentralManager.cancelPeripheralConnection:',
        macOS: (false, (10, 7, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_cancelPeripheralConnection_,
        peripheral.ref.pointer);
  }

  /// registerForConnectionEventsWithOptions:
  void registerForConnectionEventsWithOptions(objc.NSDictionary? options) {
    objc.checkOsVersionInternal(
        'CBCentralManager.registerForConnectionEventsWithOptions:',
        iOS: (false, (13, 0, 0)),
        macOS: (true, null));
    _objc_msgSend_xtuoz7(
        this.ref.pointer,
        _sel_registerForConnectionEventsWithOptions_,
        options?.ref.pointer ?? ffi.nullptr);
  }

  /// authorization
  static CBManagerAuthorization getAuthorization$1() {
    objc.checkOsVersionInternal('CBCentralManager.authorization',
        iOS: (false, (13, 1, 0)), macOS: (false, (10, 15, 0)));
    final _ret =
        _objc_msgSend_1pjspfw(_class_CBCentralManager, _sel_authorization);
    return CBManagerAuthorization.fromValue(_ret);
  }

  /// new
  static CBCentralManager new$() {
    final _ret = _objc_msgSend_151sglz(_class_CBCentralManager, _sel_new);
    return CBCentralManager.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static CBCentralManager allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_CBCentralManager, _sel_allocWithZone_, zone);
    return CBCentralManager.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static CBCentralManager alloc() {
    final _ret = _objc_msgSend_151sglz(_class_CBCentralManager, _sel_alloc);
    return CBCentralManager.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  CBCentralManager self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return CBCentralManager.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  CBCentralManager retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return CBCentralManager.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  CBCentralManager autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return CBCentralManager.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of CBCentralManager constructed with the default `new` method.
  factory CBCentralManager() => new$();
}

enum CBATTError {
  CBATTErrorSuccess(0),
  CBATTErrorInvalidHandle(1),
  CBATTErrorReadNotPermitted(2),
  CBATTErrorWriteNotPermitted(3),
  CBATTErrorInvalidPdu(4),
  CBATTErrorInsufficientAuthentication(5),
  CBATTErrorRequestNotSupported(6),
  CBATTErrorInvalidOffset(7),
  CBATTErrorInsufficientAuthorization(8),
  CBATTErrorPrepareQueueFull(9),
  CBATTErrorAttributeNotFound(10),
  CBATTErrorAttributeNotLong(11),
  CBATTErrorInsufficientEncryptionKeySize(12),
  CBATTErrorInvalidAttributeValueLength(13),
  CBATTErrorUnlikelyError(14),
  CBATTErrorInsufficientEncryption(15),
  CBATTErrorUnsupportedGroupType(16),
  CBATTErrorInsufficientResources(17);

  final int value;
  const CBATTError(this.value);

  static CBATTError fromValue(int value) => switch (value) {
        0 => CBATTErrorSuccess,
        1 => CBATTErrorInvalidHandle,
        2 => CBATTErrorReadNotPermitted,
        3 => CBATTErrorWriteNotPermitted,
        4 => CBATTErrorInvalidPdu,
        5 => CBATTErrorInsufficientAuthentication,
        6 => CBATTErrorRequestNotSupported,
        7 => CBATTErrorInvalidOffset,
        8 => CBATTErrorInsufficientAuthorization,
        9 => CBATTErrorPrepareQueueFull,
        10 => CBATTErrorAttributeNotFound,
        11 => CBATTErrorAttributeNotLong,
        12 => CBATTErrorInsufficientEncryptionKeySize,
        13 => CBATTErrorInvalidAttributeValueLength,
        14 => CBATTErrorUnlikelyError,
        15 => CBATTErrorInsufficientEncryption,
        16 => CBATTErrorUnsupportedGroupType,
        17 => CBATTErrorInsufficientResources,
        _ => throw ArgumentError('Unknown value for CBATTError: $value'),
      };
}

enum CBPeripheralManagerAuthorizationStatus {
  CBPeripheralManagerAuthorizationStatusNotDetermined(0),
  CBPeripheralManagerAuthorizationStatusRestricted(1),
  CBPeripheralManagerAuthorizationStatusDenied(2),
  CBPeripheralManagerAuthorizationStatusAuthorized(3);

  final int value;
  const CBPeripheralManagerAuthorizationStatus(this.value);

  static CBPeripheralManagerAuthorizationStatus fromValue(int value) =>
      switch (value) {
        0 => CBPeripheralManagerAuthorizationStatusNotDetermined,
        1 => CBPeripheralManagerAuthorizationStatusRestricted,
        2 => CBPeripheralManagerAuthorizationStatusDenied,
        3 => CBPeripheralManagerAuthorizationStatusAuthorized,
        _ => throw ArgumentError(
            'Unknown value for CBPeripheralManagerAuthorizationStatus: $value'),
      };
}

enum CBPeripheralManagerConnectionLatency {
  CBPeripheralManagerConnectionLatencyLow(0),
  CBPeripheralManagerConnectionLatencyMedium(1),
  CBPeripheralManagerConnectionLatencyHigh(2);

  final int value;
  const CBPeripheralManagerConnectionLatency(this.value);

  static CBPeripheralManagerConnectionLatency fromValue(int value) =>
      switch (value) {
        0 => CBPeripheralManagerConnectionLatencyLow,
        1 => CBPeripheralManagerConnectionLatencyMedium,
        2 => CBPeripheralManagerConnectionLatencyHigh,
        _ => throw ArgumentError(
            'Unknown value for CBPeripheralManagerConnectionLatency: $value'),
      };
}

late final _class_CBPeripheralManager = objc.getClass("CBPeripheralManager");

/// WARNING: CBPeripheralManagerDelegate is a stub. To generate bindings for this class, include
/// CBPeripheralManagerDelegate in your config's objc-protocols list.
///
/// CBPeripheralManagerDelegate
interface class CBPeripheralManagerDelegate extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  CBPeripheralManagerDelegate._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [CBPeripheralManagerDelegate] that points to the same underlying object as [other].
  CBPeripheralManagerDelegate.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CBPeripheralManagerDelegate] that wraps the given raw object pointer.
  CBPeripheralManagerDelegate.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_isAdvertising = objc.registerName("isAdvertising");
late final _sel_authorizationStatus = objc.registerName("authorizationStatus");
final _objc_msgSend_qq2srq = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_startAdvertising_ = objc.registerName("startAdvertising:");
late final _sel_stopAdvertising = objc.registerName("stopAdvertising");

/// WARNING: CBCentral is a stub. To generate bindings for this class, include
/// CBCentral in your config's objc-interfaces list.
///
/// CBCentral
class CBCentral extends CBPeer {
  CBCentral._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('CBCentral', macOS: (false, (10, 9, 0)));
  }

  /// Constructs a [CBCentral] that points to the same underlying object as [other].
  CBCentral.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CBCentral] that wraps the given raw object pointer.
  CBCentral.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_setDesiredConnectionLatency_forCentral_ =
    objc.registerName("setDesiredConnectionLatency:forCentral:");
final _objc_msgSend_lzo2ed = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Long,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            ffi.Pointer<objc.ObjCObject>)>();

/// WARNING: CBMutableService is a stub. To generate bindings for this class, include
/// CBMutableService in your config's objc-interfaces list.
///
/// CBMutableService
class CBMutableService extends CBService {
  CBMutableService._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('CBMutableService', macOS: (false, (10, 9, 0)));
  }

  /// Constructs a [CBMutableService] that points to the same underlying object as [other].
  CBMutableService.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CBMutableService] that wraps the given raw object pointer.
  CBMutableService.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_addService_ = objc.registerName("addService:");
late final _sel_removeService_ = objc.registerName("removeService:");
late final _sel_removeAllServices = objc.registerName("removeAllServices");

/// WARNING: CBATTRequest is a stub. To generate bindings for this class, include
/// CBATTRequest in your config's objc-interfaces list.
///
/// CBATTRequest
class CBATTRequest extends objc.NSObject {
  CBATTRequest._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('CBATTRequest', macOS: (false, (10, 9, 0)));
  }

  /// Constructs a [CBATTRequest] that points to the same underlying object as [other].
  CBATTRequest.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CBATTRequest] that wraps the given raw object pointer.
  CBATTRequest.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_respondToRequest_withResult_ =
    objc.registerName("respondToRequest:withResult:");
final _objc_msgSend_1euuq6h = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Long)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int)>();

/// WARNING: CBMutableCharacteristic is a stub. To generate bindings for this class, include
/// CBMutableCharacteristic in your config's objc-interfaces list.
///
/// CBMutableCharacteristic
class CBMutableCharacteristic extends CBCharacteristic {
  CBMutableCharacteristic._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('CBMutableCharacteristic',
        macOS: (false, (10, 9, 0)));
  }

  /// Constructs a [CBMutableCharacteristic] that points to the same underlying object as [other].
  CBMutableCharacteristic.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CBMutableCharacteristic] that wraps the given raw object pointer.
  CBMutableCharacteristic.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_updateValue_forCharacteristic_onSubscribedCentrals_ =
    objc.registerName("updateValue:forCharacteristic:onSubscribedCentrals:");
final _objc_msgSend_gtxojt = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_publishL2CAPChannelWithEncryption_ =
    objc.registerName("publishL2CAPChannelWithEncryption:");
final _objc_msgSend_1s56lr9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Bool)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, bool)>();
late final _sel_unpublishL2CAPChannel_ =
    objc.registerName("unpublishL2CAPChannel:");

/// CBPeripheralManager
class CBPeripheralManager extends CBManager {
  CBPeripheralManager._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('CBPeripheralManager',
        macOS: (false, (10, 9, 0)));
  }

  /// Constructs a [CBPeripheralManager] that points to the same underlying object as [other].
  CBPeripheralManager.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CBPeripheralManager] that wraps the given raw object pointer.
  CBPeripheralManager.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CBPeripheralManager].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_CBPeripheralManager);
  }

  /// delegate
  CBPeripheralManagerDelegate? get delegate {
    objc.checkOsVersionInternal('CBPeripheralManager.delegate',
        macOS: (false, (10, 9, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_delegate);
    return _ret.address == 0
        ? null
        : CBPeripheralManagerDelegate.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// setDelegate:
  set delegate(CBPeripheralManagerDelegate? value) {
    objc.checkOsVersionInternal('CBPeripheralManager.setDelegate:',
        macOS: (false, (10, 9, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setDelegate_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// isAdvertising
  bool get isAdvertising {
    objc.checkOsVersionInternal('CBPeripheralManager.isAdvertising',
        macOS: (false, (10, 9, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isAdvertising);
  }

  /// authorizationStatus
  static CBPeripheralManagerAuthorizationStatus authorizationStatus() {
    objc.checkOsVersionInternal('CBPeripheralManager.authorizationStatus',
        macOS: (false, (10, 9, 0)));
    final _ret = _objc_msgSend_qq2srq(
        _class_CBPeripheralManager, _sel_authorizationStatus);
    return CBPeripheralManagerAuthorizationStatus.fromValue(_ret);
  }

  /// init
  CBPeripheralManager init() {
    objc.checkOsVersionInternal('CBPeripheralManager.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return CBPeripheralManager.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// initWithDelegate:queue:
  CBPeripheralManager initWithDelegate(CBPeripheralManagerDelegate? delegate$1,
      {objc.NSObject? queue}) {
    objc.checkOsVersionInternal('CBPeripheralManager.initWithDelegate:queue:',
        iOS: (false, (6, 0, 0)), macOS: (false, (10, 9, 0)));
    final _ret = _objc_msgSend_15qeuct(
        this.ref.retainAndReturnPointer(),
        _sel_initWithDelegate_queue_,
        delegate$1?.ref.pointer ?? ffi.nullptr,
        queue?.ref.pointer ?? ffi.nullptr);
    return CBPeripheralManager.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// initWithDelegate:queue:options:
  CBPeripheralManager initWithDelegate$1(
      CBPeripheralManagerDelegate? delegate$1,
      {objc.NSObject? queue,
      objc.NSDictionary? options}) {
    objc.checkOsVersionInternal(
        'CBPeripheralManager.initWithDelegate:queue:options:',
        iOS: (false, (7, 0, 0)),
        macOS: (false, (10, 9, 0)));
    final _ret = _objc_msgSend_11spmsz(
        this.ref.retainAndReturnPointer(),
        _sel_initWithDelegate_queue_options_,
        delegate$1?.ref.pointer ?? ffi.nullptr,
        queue?.ref.pointer ?? ffi.nullptr,
        options?.ref.pointer ?? ffi.nullptr);
    return CBPeripheralManager.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// startAdvertising:
  void startAdvertising(objc.NSDictionary? advertisementData) {
    objc.checkOsVersionInternal('CBPeripheralManager.startAdvertising:',
        macOS: (false, (10, 9, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_startAdvertising_,
        advertisementData?.ref.pointer ?? ffi.nullptr);
  }

  /// stopAdvertising
  void stopAdvertising() {
    objc.checkOsVersionInternal('CBPeripheralManager.stopAdvertising',
        macOS: (false, (10, 9, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_stopAdvertising);
  }

  /// setDesiredConnectionLatency:forCentral:
  void setDesiredConnectionLatency(CBPeripheralManagerConnectionLatency latency,
      {required CBCentral forCentral}) {
    objc.checkOsVersionInternal(
        'CBPeripheralManager.setDesiredConnectionLatency:forCentral:',
        macOS: (false, (10, 9, 0)));
    _objc_msgSend_lzo2ed(
        this.ref.pointer,
        _sel_setDesiredConnectionLatency_forCentral_,
        latency.value,
        forCentral.ref.pointer);
  }

  /// addService:
  void addService(CBMutableService service) {
    objc.checkOsVersionInternal('CBPeripheralManager.addService:',
        macOS: (false, (10, 9, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_addService_, service.ref.pointer);
  }

  /// removeService:
  void removeService(CBMutableService service) {
    objc.checkOsVersionInternal('CBPeripheralManager.removeService:',
        macOS: (false, (10, 9, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_removeService_, service.ref.pointer);
  }

  /// removeAllServices
  void removeAllServices() {
    objc.checkOsVersionInternal('CBPeripheralManager.removeAllServices',
        macOS: (false, (10, 9, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_removeAllServices);
  }

  /// respondToRequest:withResult:
  void respondToRequest(CBATTRequest request,
      {required CBATTError withResult}) {
    objc.checkOsVersionInternal(
        'CBPeripheralManager.respondToRequest:withResult:',
        macOS: (false, (10, 9, 0)));
    _objc_msgSend_1euuq6h(this.ref.pointer, _sel_respondToRequest_withResult_,
        request.ref.pointer, withResult.value);
  }

  /// updateValue:forCharacteristic:onSubscribedCentrals:
  bool updateValue(objc.NSData value,
      {required CBMutableCharacteristic forCharacteristic,
      objc.NSArray? onSubscribedCentrals}) {
    objc.checkOsVersionInternal(
        'CBPeripheralManager.updateValue:forCharacteristic:onSubscribedCentrals:',
        macOS: (false, (10, 9, 0)));
    return _objc_msgSend_gtxojt(
        this.ref.pointer,
        _sel_updateValue_forCharacteristic_onSubscribedCentrals_,
        value.ref.pointer,
        forCharacteristic.ref.pointer,
        onSubscribedCentrals?.ref.pointer ?? ffi.nullptr);
  }

  /// publishL2CAPChannelWithEncryption:
  void publishL2CAPChannelWithEncryption(bool encryptionRequired) {
    objc.checkOsVersionInternal(
        'CBPeripheralManager.publishL2CAPChannelWithEncryption:',
        macOS: (false, (10, 14, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer,
        _sel_publishL2CAPChannelWithEncryption_, encryptionRequired);
  }

  /// unpublishL2CAPChannel:
  void unpublishL2CAPChannel(int PSM) {
    objc.checkOsVersionInternal('CBPeripheralManager.unpublishL2CAPChannel:',
        macOS: (false, (10, 14, 0)));
    _objc_msgSend_15f11yh(this.ref.pointer, _sel_unpublishL2CAPChannel_, PSM);
  }

  /// authorization
  static CBManagerAuthorization getAuthorization$1() {
    objc.checkOsVersionInternal('CBPeripheralManager.authorization',
        iOS: (false, (13, 1, 0)), macOS: (false, (10, 15, 0)));
    final _ret =
        _objc_msgSend_1pjspfw(_class_CBPeripheralManager, _sel_authorization);
    return CBManagerAuthorization.fromValue(_ret);
  }

  /// new
  static CBPeripheralManager new$() {
    final _ret = _objc_msgSend_151sglz(_class_CBPeripheralManager, _sel_new);
    return CBPeripheralManager.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static CBPeripheralManager allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_CBPeripheralManager, _sel_allocWithZone_, zone);
    return CBPeripheralManager.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static CBPeripheralManager alloc() {
    final _ret = _objc_msgSend_151sglz(_class_CBPeripheralManager, _sel_alloc);
    return CBPeripheralManager.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  CBPeripheralManager self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return CBPeripheralManager.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  CBPeripheralManager retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return CBPeripheralManager.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  CBPeripheralManager autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return CBPeripheralManager.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a new instance of CBPeripheralManager constructed with the default `new` method.
  factory CBPeripheralManager() => new$();
}

enum CBAttributePermissions {
  CBAttributePermissionsReadable(1),
  CBAttributePermissionsWriteable(2),
  CBAttributePermissionsReadEncryptionRequired(4),
  CBAttributePermissionsWriteEncryptionRequired(8);

  final int value;
  const CBAttributePermissions(this.value);

  static CBAttributePermissions fromValue(int value) => switch (value) {
        1 => CBAttributePermissionsReadable,
        2 => CBAttributePermissionsWriteable,
        4 => CBAttributePermissionsReadEncryptionRequired,
        8 => CBAttributePermissionsWriteEncryptionRequired,
        _ => throw ArgumentError(
            'Unknown value for CBAttributePermissions: $value'),
      };
}
